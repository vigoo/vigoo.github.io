<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>vigoo&#x27;s software development blog - rust</title>
    <link rel="self" type="application/atom+xml" href="https://blog.vigoo.dev/tags/rust/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.vigoo.dev"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-09-19T00:00:00+00:00</updated>
    <id>https://blog.vigoo.dev/tags/rust/atom.xml</id>
    <entry xml:lang="en">
        <title>Golem 1.3&#x27;s new JavaScript engine</title>
        <published>2025-09-19T00:00:00+00:00</published>
        <updated>2025-09-19T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Daniel Vigovszky
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.vigoo.dev/posts/golem-new-js-engine/"/>
        <id>https://blog.vigoo.dev/posts/golem-new-js-engine/</id>
        
        <content type="html" xml:base="https://blog.vigoo.dev/posts/golem-new-js-engine/">&lt;p&gt;As we are rapidly approaching the release data for Golem 1.3, a major update, I&#x27;m going to publish a series of small posts talking about some of the technical details of this new release. In this first one, let&#x27;s talk about the &lt;em&gt;new JavaScript engine&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;javascript-support-in-previous-versions&quot;&gt;JavaScript support in previous versions&lt;&#x2F;h2&gt;
&lt;p&gt;In previous Golem versions we tried to support JavaScript (and TypeScript) using the &quot;official&quot; way of using these languages in the WASM Component Model: using the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;ComponentizeJS&quot;&gt;ComponentizeJs project&lt;&#x2F;a&gt;. This embeds a special version of the &lt;a href=&quot;https:&#x2F;&#x2F;spidermonkey.dev&quot;&gt;SpiderMonkey JS engine&lt;&#x2F;a&gt;, called StarlingMonkey in a WASM component together with the user&#x27;s JS code, and generates import and export bindings based on the component model interface definition (WIT). In addition to this, ComponentizeJs also does a &lt;em&gt;preinitialization step&lt;&#x2F;em&gt; - basically pre-running and snapshotting parts of the resulting component compile time to make the component&#x27;s initialization time quicker.&lt;&#x2F;p&gt;
&lt;p&gt;Although this all sounds very good, this project is still considered &lt;em&gt;experimental&lt;&#x2F;em&gt; and we ran into serious issues with it, especially around it&#x27;s implementation of &lt;code&gt;fetch&lt;&#x2F;code&gt; and async boundaries. We reported these issues, and also tried to fix some of them ourselves, but working on this project is extremely difficult and we did not reach a point where our users would be guaranteed to be able to build on top of these core JS APIs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-new-engine&quot;&gt;The new engine&lt;&#x2F;h2&gt;
&lt;p&gt;Instead trying to fix ComponentizeJs or waiting for others to do so, we decided to try to &lt;em&gt;replace it&lt;&#x2F;em&gt; for the next Golem release. This worked out so well that we were able to refocus our language support to be primarily TypeScript for the next release.&lt;&#x2F;p&gt;
&lt;p&gt;So what did I do?&lt;&#x2F;p&gt;
&lt;p&gt;The goal was to have a similar solution - take the user&#x27;s JS and an interface definition (&lt;a href=&quot;https:&#x2F;&#x2F;component-model.bytecodealliance.org&#x2F;design&#x2F;wit.html&quot;&gt;WIT&lt;&#x2F;a&gt;) and get a WebAssembly component implementing this interface by running the user&#x27;s JavaScript code. But we wanted something that is significantly easier to work with, and easier to extend with more and more &quot;build-in&quot; JS APIs. This is important for us as we want people to be able to use as many existing libraries in their Golem applications as possible. There must be a trade-off somewhere, of course - and there are two that I&#x27;m going to talk about in details. First, our new engine supposed to have worse performance than ComponentizeJs, although it has not been benchmarked yet; and the second one is the need of a Rust compiler toolchain to convert the JavaScript code to WASM. This, however, is not affecting Golem users due to some other changes we introduced; more about it later.&lt;&#x2F;p&gt;
&lt;p&gt;So with all these constraints, I ended up creating &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golemcloud&#x2F;wasm-rquickjs&quot;&gt;wasm-rquickjs&lt;&#x2F;a&gt;, with the following properties:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;It&#x27;s built on the &lt;a href=&quot;https:&#x2F;&#x2F;quickjs-ng.github.io&#x2F;quickjs&#x2F;&quot;&gt;QuickJS-NG engine&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;But, to make it much easier to maintain and extend, it is using this engine through Rust, using the excellent &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;DelSkayn&#x2F;rquickjs&quot;&gt;rquickjs crate&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;It generates glue code to bridge the JS world with the Rust bindings generated by &lt;code&gt;wit-bindgen-rust&lt;&#x2F;code&gt; for the component model exports and imports&lt;&#x2F;li&gt;
&lt;li&gt;And also defines a growing set of built-in JS APIs, some implemented from scratch, others by taking various open-source polyfill libraries&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The result is a CLI tool (&lt;code&gt;wasm-rquickjs-cli&lt;&#x2F;code&gt;) and embeddable Rust library that can take a WIT world, a JS file, and ends up generating a standalone Rust crate that, when compiled using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bytecodealliance&#x2F;cargo-component&quot;&gt;cargo-component&lt;&#x2F;a&gt;, emits the WASM that we need.&lt;&#x2F;p&gt;
&lt;p&gt;It also support emitting TypeScript module definitions for all the imports and exports of the component.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;details&quot;&gt;Details&lt;&#x2F;h2&gt;
&lt;p&gt;To understand why I chose to go with generating Rust crates and using the above mentioned &lt;code&gt;rquickjs&lt;&#x2F;code&gt; library, let&#x27;s take a closer look at how things are done within &lt;code&gt;wasm-rquickjs&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;defining-built-in-apis&quot;&gt;Defining built-in APIs&lt;&#x2F;h3&gt;
&lt;p&gt;We wanted to be able to easily increase the set of supported built-in APIs to have increased compatibility with the existing JS ecosystem. Some of these APIs can be introduced with pure JS polyfill libraries, but many of them requires to be somehow implemented on top of imported WebAssemby system interfaces (WASI). A good example can be implementing (a subset of) the &lt;code&gt;node:fs&lt;&#x2F;code&gt; API to work with files and filesystems.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;rquickjs&lt;&#x2F;code&gt; crate really makes this very easy to do - it has a convenient way to bind native Rust functions into the JavaScript context, and it also solves the difficult problem of bridging the world of JS promises with &lt;em&gt;async Rust&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This means we can write Rust functions in which we can use the Rust standard library or any other imported WIT bindings and then call these functions from JS. For example we can define a &lt;code&gt;read_file&lt;&#x2F;code&gt; function that exposes &lt;code&gt;std::fs::read&lt;&#x2F;code&gt; for JavaScript:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;rquickjs&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;function&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;read_file&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;: String, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;: Ctx&amp;lt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) -&amp;gt;   List&amp;lt;(Option&amp;lt;TypedArray&amp;lt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;, Option&amp;lt;String&amp;gt;)&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; path &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Path::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;path);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span&gt;std::fs::read(path) {
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(bytes) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; typed_array &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;        TypedArray::new_copy(ctx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;bytes)
&lt;&#x2F;span&gt;&lt;span&gt;          .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;expect&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Failed to create TypedArray&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;      List((Some(typed_array), None))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    Err(err) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; error_message &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Failed to read file &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{path:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{err}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;      List((None, Some(error_message)))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then the actual JavaScript API can be implemented in JS itself, using these native functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;export function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;readFile&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;optionsOrCallback&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;callback&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;contents&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;error&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;read_file&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;error &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;undefined&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;buffer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Buffer&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;from&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;contents&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;callback&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;buffer&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;callback&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;undefined&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;error&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This makes it really convenient to add support for more and more APIs, and as mentioned earlier, these native functions can be &lt;code&gt;async&lt;&#x2F;code&gt; Rust functions too, which simply translates to async JS functions.&lt;&#x2F;p&gt;
&lt;p&gt;For example, part of the &lt;code&gt;fetch&lt;&#x2F;code&gt; implementation is sending the request body asynchronously:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;async function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;sendBody&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;bodyWriter&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;body&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;reader &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;body&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;getReader&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;done&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;reader&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;done&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;bodyWriter&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;writeRequestBodyChunk&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;bodyWriter&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;finishBody&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;writeRequestBodyChunk&lt;&#x2F;code&gt; method is a native Rust method defined like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;rquickjs&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;methods&lt;&#x2F;span&gt;&lt;span&gt;(rename_all &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;camelCase&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;WrappedRequestBodyWriter {
&lt;&#x2F;span&gt;&lt;span&gt;    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;qjs&lt;&#x2F;span&gt;&lt;span&gt;(constructor)]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        WrappedRequestBodyWriter { writer: None }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;write_request_body_chunk&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;chunk&lt;&#x2F;span&gt;&lt;span&gt;: TypedArray&amp;lt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;implementing-imports&quot;&gt;Implementing imports&lt;&#x2F;h3&gt;
&lt;p&gt;With the above technique, we could have a precompiled WASM JS engine that is capable of running user code while providing them a fix set of supported APIs. This is what a similar project, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;second-state&#x2F;wasmedge-quickjs&quot;&gt;wasmedge-quickjs&lt;&#x2F;a&gt; does.&lt;&#x2F;p&gt;
&lt;p&gt;But &lt;code&gt;wasm-rquickjs&lt;&#x2F;code&gt; does not stop here - it uses the same method of defining JS modules with native Rust bindings to define a JS module for &lt;em&gt;each imported WIT interface&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So a code generator takes the WIT imports, and emits Rust code in the style of the above examples that exposes these WIT imports to JavaScript by calling the Rust WIT bindings, generated by &lt;code&gt;wit-bindgen-rust&lt;&#x2F;code&gt; (this happens automatically under the hood when using the already mentioned &lt;code&gt;cargo-component&lt;&#x2F;code&gt; build tool).&lt;&#x2F;p&gt;
&lt;p&gt;Every data type WIT supports is mapped to a specific JS construct, and &lt;em&gt;resources&lt;&#x2F;em&gt; are mapped to JS classes. The following example shows the generated function for one of the exported functions of &lt;code&gt;golem:llm&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golemcloud&#x2F;golem-ai&quot;&gt;from the Golem AI libraries&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;rquickjs&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;function&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;messages&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;crate::bindings::golem::llm::llm::Message&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;config&lt;&#x2F;span&gt;&lt;span&gt;: crate::bindings::golem::llm::llm::Config,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; crate::bindings::golem::llm::llm::ChatEvent {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; result: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;::bindings::golem::llm::llm::ChatEvent &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= crate&lt;&#x2F;span&gt;&lt;span&gt;::bindings::golem::llm::llm::send(
&lt;&#x2F;span&gt;&lt;span&gt;        messages.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span&gt;| v).collect::&amp;lt;Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;as_slice&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;config,
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;    result
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This simply uses &lt;code&gt;rquickjs&lt;&#x2F;code&gt;&#x27;s native binding macro to do the hard work, and calls the generated Rust bindings under the hood.&lt;&#x2F;p&gt;
&lt;p&gt;Of course to make this work, &lt;code&gt;rquickjs&lt;&#x2F;code&gt; also needs to know how to encode these data types, such as the LLM &lt;code&gt;Message&lt;&#x2F;code&gt;, as JS. So the code generator also emits instances of the &lt;code&gt;ToJs&lt;&#x2F;code&gt; and &lt;code&gt;FromJs&lt;&#x2F;code&gt; type classes, such as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; rquickjs::IntoJs&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;crate::bindings::golem::llm::llm::Message {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into_js&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;rquickjs::Ctx&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  ) -&amp;gt; rquickjs::Result&amp;lt;rquickjs::Value&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; obj &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;rquickjs::Object::new(ctx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;())&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; role: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;::bindings::golem::llm::llm::Role &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.role;
&lt;&#x2F;span&gt;&lt;span&gt;    obj.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;set&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;role&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, role)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(obj.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into_value&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; rquickjs::FromJs&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;crate::bindings::golem::llm::llm::Message {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;from_js&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_ctx&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;rquickjs::Ctx&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;: rquickjs::Value&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  ) -&amp;gt; rquickjs::Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; obj &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;rquickjs::Object::from_value(value)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; role: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;::bindings::golem::llm::llm::Role &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; obj.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;role&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The main difficulty was not generating these JS mappings - it was matching the expected signatures of &lt;code&gt;wit-bindgen-rust&lt;&#x2F;code&gt;, as it has some complex rules for deciding when to pass things by value or by reference.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementing-exports&quot;&gt;Implementing exports&lt;&#x2F;h3&gt;
&lt;p&gt;For all the exported interfaces in a component&#x27;s WIT definition, &lt;code&gt;wit-bindgen-rust&lt;&#x2F;code&gt; generates a &lt;em&gt;trait&lt;&#x2F;em&gt; to be implemented. We expect the JS developers to implement all these imports with some well defined rules (interfaces becoming exported objects, kebab-case names becoming camel cased, etc.). With the assumption that the user&#x27;s JS code implements all the exports, &lt;code&gt;wasm-rquickjs&lt;&#x2F;code&gt; can generate implementations for these rust traits that are calling into the QuickJS engine, running these functions.&lt;&#x2F;p&gt;
&lt;p&gt;Part of the problem is very similar to what we have with imports - converting from the Rust types (coming from the WIT types) to JS types. This is done using the same conversion type classes we already talked about.&lt;&#x2F;p&gt;
&lt;p&gt;When setting up the JS context, we always store a reference to the user&#x27;s module in a global variable, so the generated export code can easily access it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; module: Object &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; ctx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;globals&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;userModule&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;expect&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Failed to get userModule&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There are similar global helper tables for tracking the class instances for WIT resource instances.&lt;&#x2F;p&gt;
&lt;p&gt;Once we have the module object, we can apply the naming rules and find the function value and call it with &lt;code&gt;rquickjs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call_with_this&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;, A, R&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;: Ctx&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;function&lt;&#x2F;span&gt;&lt;span&gt;: Function&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;: Object&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: A,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; rquickjs::Result&amp;lt;R&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    A: IntoArgs&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    R: FromJs&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;js&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; num &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; args.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;num_args&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; accum_args &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Args::new(ctx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(), num &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    accum_args.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;(this)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    args.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into_args&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; accum_args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    function.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call_arg&lt;&#x2F;span&gt;&lt;span&gt;(accum_args)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A nice property we can offer is that we don&#x27;t have to constrain the user to always implement the exported functions as async JavaScript functions. We can simply check the return value before trying to convert it to the Rust equivalent whether it is a &lt;code&gt;Promise&lt;&#x2F;code&gt; or not. And if it is, we can just &lt;code&gt;await&lt;&#x2F;code&gt; it in the Rust code!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;is_promise&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; promise: Promise &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into_promise&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; promise_future &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; promise.into_future::&amp;lt;R&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; promise_future.await {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;async-all-the-way-down&quot;&gt;Async all the way down&lt;&#x2F;h3&gt;
&lt;p&gt;This seamless integration of the JS and Rust async world is a key component in making &lt;code&gt;wasm-rquickjs&lt;&#x2F;code&gt; easy to work with. But it&#x27;s not enough that &lt;code&gt;rquickjs&lt;&#x2F;code&gt; implements the boundary between JS and Rust. The end result is a WASM component, which is single threaded and only provides a very specific set of system APIs to build on; we cannot just use Tokio for example as our Rust runtime (at the time of writing). At the bottom of all the Rust and JS async stacks, there is single small WASI API supporting all this: &lt;code&gt;wasi:io&#x2F;poll&lt;&#x2F;code&gt;. &lt;a href=&quot;https:&#x2F;&#x2F;blog.yoshuawuyts.com&#x2F;building-an-async-runtime-for-wasi&#x2F;&quot;&gt;Yoshua Wuyts has an excellent blog post&lt;&#x2F;a&gt; about the topic. &lt;code&gt;wasm-rquickjs&lt;&#x2F;code&gt; builds on his &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;wasi-async-runtime&#x2F;latest&#x2F;wasi_async_runtime&#x2F;&quot;&gt;&lt;code&gt;wasi_async_runtime&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; crate (and soon will be migrated to the newer &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;wstd&#x2F;latest&#x2F;wstd&#x2F;&quot;&gt;&lt;code&gt;wstd&lt;&#x2F;code&gt; crate&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trade-offs&quot;&gt;Trade-offs&lt;&#x2F;h2&gt;
&lt;p&gt;As I mentioned in the introduction, this approach naturally comes with some trade-offs when comparing to ComponentizeJs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;performance&quot;&gt;Performance&lt;&#x2F;h3&gt;
&lt;p&gt;We are not doing any precompilation at the moment, so component initialization time for bigger projects is definitely supposed to be slower. On the other hand the engine itself is much smaller than the modified SpiderMonkey in ComponentizeJs, so this may balance out the difference in some cases. I also expect SpiderMonkey to be faster in general than QuickJS, although this is not as clear &lt;a href=&quot;https:&#x2F;&#x2F;cfallin.org&#x2F;blog&#x2F;2023&#x2F;10&#x2F;11&#x2F;spidermonkey-pbl&#x2F;&quot;&gt;because SpiderMonkey also has to run in interpreter mode&lt;&#x2F;a&gt; on WASM.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rust-compilation&quot;&gt;Rust compilation&lt;&#x2F;h3&gt;
&lt;p&gt;A more serious trade-off is that by generating a Rust crate, we force the JS&#x2F;TS users to have a Rust tool-chain available and compile these generated crates to WASM.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve spent a lot of effort in the past year hiding the complexity of having these build tools, and especially having the &lt;em&gt;correct version&lt;&#x2F;em&gt; of WASM &#x2F; component model related tools automatically set up and invoked by hiding the component creating process in Golem&#x27;s own CLI interface.&lt;&#x2F;p&gt;
&lt;p&gt;Still, having to set up Rust to just run a simple JavaScript snippet on Golem is too much to ask. We worked around this issue by not allowing users to work directly on the component model level anymore - no WIT, no composition for them. This way we can embed a precompiled WASM binary in our tooling that can be combined with the user&#x27;s JavaScript code to form a final WASM component. I am going to write a separate post about this decision and its technical details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golemcloud&#x2F;wasm-rquickjs&#x2F;&quot;&gt;wasm-rquickjs&lt;&#x2F;a&gt; turned out to be a very capable alternative for ComponentizeJs, that is much easier to iterate on. It is a standalone project, completely usable outside of Golem; if the above two trade-offs are acceptable, it provides a nice experience of writing JavaScript or TypeScript code for the WASM Component Model.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>[Video] Missing Testing Features in Rust @ LambdaConf 2025</title>
        <published>2025-06-23T00:00:00+00:00</published>
        <updated>2025-06-23T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Daniel Vigovszky
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.vigoo.dev/posts/missing-testing-features-in-rust/"/>
        <id>https://blog.vigoo.dev/posts/missing-testing-features-in-rust/</id>
        
        <content type="html" xml:base="https://blog.vigoo.dev/posts/missing-testing-features-in-rust/">&lt;p&gt;My talk at &lt;a href=&quot;https:&#x2F;&#x2F;www.lambdaconf.us&quot;&gt;LambdaConf 2025&lt;&#x2F;a&gt; about my Rust test framework &lt;a href=&quot;https:&#x2F;&#x2F;test-r.vigoo.dev&quot;&gt;test-r&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;iframe width=&quot;800&quot; height=&quot;450&quot; src=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;embed&#x2F;Yf5oIj816mw?list=PL7DZ7q3nEWhwo2OmeaMzNggy7sof9qg5p&quot; title=&quot;Daniel Vigovszky - Missing Testing Features in Rust&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen&gt;&lt;&#x2F;iframe&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Golem&#x27;s Rust transaction API</title>
        <published>2024-04-13T00:00:00+00:00</published>
        <updated>2024-04-13T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Daniel Vigovszky
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.vigoo.dev/posts/golem-rust-transaction-api/"/>
        <id>https://blog.vigoo.dev/posts/golem-rust-transaction-api/</id>
        
        <content type="html" xml:base="https://blog.vigoo.dev/posts/golem-rust-transaction-api/">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;A few weeks ago we have added a new set of &lt;em&gt;host functions&lt;&#x2F;em&gt; to &lt;a href=&quot;https:&#x2F;&#x2F;golem.cloud&quot;&gt;Golem&lt;&#x2F;a&gt;, which allow programs running on this platform to control some of the persistency and transactional behavior of the executor. You can learn about these low-level functions on &lt;a href=&quot;https:&#x2F;&#x2F;learn.golem.cloud&#x2F;docs&#x2F;transaction-api&quot;&gt;the corresponding learn page&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These exported functions allow a lot of control but they are very low level, and definitely not pleasant to use directly. To make them nicer we can write language-specific wrapper libraries on top of them, providing a first class experience for the supported programming languages.&lt;&#x2F;p&gt;
&lt;p&gt;The first such wrapper library is &lt;a href=&quot;http:&#x2F;&#x2F;github.com&#x2F;golemcloud&#x2F;golem-rust&quot;&gt;golem-rust&lt;&#x2F;a&gt;, and this post explains some of the Rust specific technical details of how this library works.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;regional-changes&quot;&gt;Regional changes&lt;&#x2F;h2&gt;
&lt;p&gt;The easy part is providing higher level support for temporarily changing the executor&#x27;s behavior. The common property of these host functions is that they come in pairs:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;mark-begin-operation&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;mark-end-operation&lt;&#x2F;code&gt; pair defines a region that is treated as an atomic operation&lt;&#x2F;li&gt;
&lt;li&gt;We can get the current retry policy and change it to something else with the &lt;code&gt;get-retry-policy&lt;&#x2F;code&gt; and &lt;code&gt;set-retry-policy&lt;&#x2F;code&gt; functions&lt;&#x2F;li&gt;
&lt;li&gt;We can control persistency with &lt;code&gt;get-oplog-persistence-level&lt;&#x2F;code&gt; and &lt;code&gt;set-oplog-persistence-level&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;And we can change whether the executor assumes that external calls are idempotent using the &lt;code&gt;get-idempotence-mode&lt;&#x2F;code&gt; and &lt;code&gt;set-idempotence-mode&lt;&#x2F;code&gt; pair.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For all these, a simple way to make them more safe and more idiomatic is to connect the lifetime of the temporarily changed behavior to the lifetime of a rust variable. For example in the following snippet, the whole function will be treated as an atomic region, but as soon the function returns, the region ends:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;some_atomic_operation&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; _atomic &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;golem_rust::mark_atomic_operation();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Implement these wrappers is quite simple. First we need to define &lt;em&gt;data type&lt;&#x2F;em&gt; which the wrapper will return. Let&#x27;s call it &lt;code&gt;AtomicOperationGuard&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;AtomicOperationGuard {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span&gt;: OplogIndex,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We store the return value of Golem&#x27;s &lt;code&gt;mark-begin-operation&lt;&#x2F;code&gt; in it, as we have to pass this value to the &lt;code&gt;mark-end-operation&lt;&#x2F;code&gt; when we want to close the atomic region.&lt;&#x2F;p&gt;
&lt;p&gt;We want to close the atomic region when this value is dropped - so we can call Golem&#x27;s &lt;code&gt;mark-end-operation&lt;&#x2F;code&gt; in an explicitly implemented &lt;code&gt;drop&lt;&#x2F;code&gt; function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Drop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;AtomicOperationGuard {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;drop&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;mark_end_operation&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.begin);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Finally we define the wrapper function which returns this guard value:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;must_use&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;mark_atomic_operation&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; AtomicOperationGuard {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; begin &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;mark_begin_operation&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    AtomicOperationGuard { begin }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By using the &lt;code&gt;#[must_use]&lt;&#x2F;code&gt; attribute we can make the compiler give a warning if the result value is not used - this is important, because that would mean that the atomic region gets closed as soon as it has been opened.&lt;&#x2F;p&gt;
&lt;p&gt;With this basic building block we can also support an alternative style where we pass a function to be executed with the temporary change in Golem&#x27;s behavior. These are higher order functions, taking a function as a parameter, and just using the already defined wrapper to apply the change:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;atomically&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: impl FnOnce() -&amp;gt; T) -&amp;gt; T {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; _guard &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;mark_atomic_operation&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The same pattern can be used for all the mentioned host function pairs to get a pair of wrappers (one returning a guard, the other taking a function as a parameter):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;use_retry_policy&lt;&#x2F;code&gt; and &lt;code&gt;with_retry_policy&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;use_idempotence_mode&lt;&#x2F;code&gt; and &lt;code&gt;with_idempotence_mode&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;use_persistence_level&lt;&#x2F;code&gt; and &lt;code&gt;with_persistence_level&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;transactions&quot;&gt;Transactions&lt;&#x2F;h2&gt;
&lt;p&gt;Golem provides &lt;strong&gt;durable execution&lt;&#x2F;strong&gt; and that comes with guarantees that your program will always run until it terminates, and (by default) all external operations are performed &lt;em&gt;at least once&lt;&#x2F;em&gt;. (Here &lt;em&gt;at least once&lt;&#x2F;em&gt; is the guarantee we can provide - naturally it does not mean that we just rerun all operations in case of a failure event. Golem tries to perform every operation exactly once but this cannot be guaranteed without special collaboration with the remote host. This behavior can be switched to &lt;em&gt;at most once&lt;&#x2F;em&gt; by changing the &lt;strong&gt;idempotence mode&lt;&#x2F;strong&gt; with the helper functions we defined above.)&lt;&#x2F;p&gt;
&lt;p&gt;Many times external operations (such as HTTP calls to remote hosts) need to be executed &lt;em&gt;transactionally&lt;&#x2F;em&gt;. If some of the operations failed the transaction need to be rolled back - &lt;strong&gt;compensation actions&lt;&#x2F;strong&gt; need to undo whatever the already successfully performed operations did.&lt;&#x2F;p&gt;
&lt;p&gt;We identified and implemented two different transaction types - both provide different guarantees and both can be useful.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;strong&gt;fallible transaction&lt;&#x2F;strong&gt; only deals with domain errors. Within the transaction every &lt;strong&gt;operation&lt;&#x2F;strong&gt; that succeeds gets recorded. If an operation fails, all the recorded operations get &lt;em&gt;compensated&lt;&#x2F;em&gt; in reverse order before the transaction block returns with a failure.&lt;&#x2F;p&gt;
&lt;p&gt;What if anything non-domain specific failure happens to the worker? It can be an unexpected fatal error, hardware failure, an executor restarted because of a deployment, etc. A fallible transaction is completely implemented as regular user code, so Golem&#x27;s durable execution guarantees apply to it. If for example the executor dies while 3 operation were completed out of the 5 in the transaction, the execution will continue from where it was - continuing with the 4th operation. If the 4th operation fails with a domain error, and the &lt;code&gt;golem-rust&lt;&#x2F;code&gt; library starts executing the compensation actions, and then a random failure causes a panic in the middle of this, the execution will continue from the middle of the compensation actions making sure that all the operations are properly rolled back.&lt;&#x2F;p&gt;
&lt;p&gt;Another possibility is what we call &lt;strong&gt;infallible transaction&lt;&#x2F;strong&gt;s. Here we say that the transaction must not fail - but still if a step fails in it, we want to run compensation actions before we retry.&lt;&#x2F;p&gt;
&lt;p&gt;To implement this we need some of the low-level transaction controls Golem provides. First of all, we need to mark the whole transaction as an &lt;em&gt;atomic region&lt;&#x2F;em&gt;. This way if a (non domain level) failure happens during the transaction, the previously performed external operations will be automatically retried as the atomic region was never committed.&lt;&#x2F;p&gt;
&lt;p&gt;We can capture the domain errors in user code and perform the compensation actions just like in the &lt;em&gt;fallible transaction&lt;&#x2F;em&gt; case. But what should we do when all operations have been rolled back? We can use the &lt;code&gt;set-oplog-index&lt;&#x2F;code&gt; host function to tell Golem to &quot;go back in time&quot; to the beginning of the transaction, forget everything that was performed after it, and start executing the transaction again.&lt;&#x2F;p&gt;
&lt;p&gt;There is a third, more complete version of &lt;strong&gt;infallible transactions&lt;&#x2F;strong&gt; which is not implemented yet - in this version we can guarantee that the compensation actions are performed even in case of a non-domain failure event. This can be implemented with the existing features of Golem but it is out of the scope of this post.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;operation-and-transaction&quot;&gt;Operation and Transaction&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s see how we can implement this transaction feature.&lt;&#x2F;p&gt;
&lt;p&gt;The first thing we need to define is an &lt;em&gt;operation&lt;&#x2F;em&gt; - something that pairs an arbitrary action with a compensation action that undoes it. We can define it as a trait with two methods:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Operation: Clone {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;In: Clone;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Out: Clone;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Err: Clone;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; Executes the operation which may fail with a domain error
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;In) -&amp;gt; Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Out, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Err&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; Executes a compensation action for the operation.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;compensate&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;In, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Out) -&amp;gt; Result&amp;lt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Err&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the operation succeeds, its result of type &lt;code&gt;Out&lt;&#x2F;code&gt; will be stored - if it fails, &lt;code&gt;compensate&lt;&#x2F;code&gt; will be called for all the previous operations with these stored output values.&lt;&#x2F;p&gt;
&lt;p&gt;We also need something that defines the boundaries of a transaction, and allows executing these operations. Here we can create two slightly different interfaces for fallible and infallible transactions - to make it more user friendly.&lt;&#x2F;p&gt;
&lt;p&gt;For fallible transactions we can define a higher order function where the user&#x27;s logic itself can fail, and in the end we get back a transaction result:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;fallible_transaction&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Out, Err: Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: impl FnOnce(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;mut FallibleTransaction&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;Err&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;) -&amp;gt; Result&amp;lt;Out, Err&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; TransactionResult&amp;lt;Out, Err&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The result type here is just an alias to the standard Rust &lt;code&gt;Result&lt;&#x2F;code&gt; type, in which the error type will be &lt;code&gt;TransactionFailure&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span&gt;TransactionResult&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;Out, Err&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;gt; = &lt;&#x2F;span&gt;&lt;span&gt;Result&amp;lt;Out, TransactionFailure&amp;lt;Err&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;TransactionFailure&amp;lt;Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; One of the operations failed with an error, and the transaction was fully rolled back.
&lt;&#x2F;span&gt;&lt;span&gt;    FailedAndRolledBackCompletely(Err),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; One of the operations failed with an error, and the transaction was partially rolled back
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; because the compensation action of one of the operations also failed.
&lt;&#x2F;span&gt;&lt;span&gt;    FailedAndRolledBackPartially {
&lt;&#x2F;span&gt;&lt;span&gt;        failure: Err,
&lt;&#x2F;span&gt;&lt;span&gt;        compensation_failure: Err,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function we pass to &lt;code&gt;fallible_transaction&lt;&#x2F;code&gt; gets a mutable reference to a transaction object - this is what we can use to execute operations:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;FallibleTransaction {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Err: Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; FallibleTransaction&amp;lt;Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;OpIn: Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;, OpOut: Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;: impl Operation&amp;lt;In = OpIn, Out = OpOut, Err = Err&amp;gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: OpIn,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;OpOut, Err&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks a bit verbose but all it says is you can pass an arbitrary &lt;code&gt;Operation&lt;&#x2F;code&gt; to this function, but all of them needs to have the same failure type, and you provide an _input_value for your operation. This separation of operation and input makes it possible to define reusable operations by implementing the &lt;code&gt;Operation&lt;&#x2F;code&gt; trait manually - we will see more ways to define operations later.&lt;&#x2F;p&gt;
&lt;p&gt;We also define a similar function and corresponding data type for &lt;em&gt;infallible transactions&lt;&#x2F;em&gt;. There are two main differences:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;infallible_transaction&lt;&#x2F;code&gt; function&#x27;s result type is simply &lt;code&gt;Out&lt;&#x2F;code&gt; - it can never fail&lt;&#x2F;li&gt;
&lt;li&gt;Similarly, &lt;code&gt;execute&lt;&#x2F;code&gt; it self cannot fail and this means that the transactional function itself cannot fail - and no need to use &lt;code&gt;?&lt;&#x2F;code&gt; or other ways to deal with result types.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Storing the compensation actions in these structs is easy - we can just create closures capturing the input and output values and calling the trait&#x27;s &lt;code&gt;compensate&lt;&#x2F;code&gt; function, and store these closures in a vec:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;CompensationAction&amp;lt;Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;action&lt;&#x2F;span&gt;&lt;span&gt;: Box&amp;lt;dyn Fn() -&amp;gt; Result&amp;lt;(), Err&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Err&amp;gt; CompensationAction&amp;lt;Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.action)()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;FallibleTransaction&amp;lt;Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;compensations&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;CompensationAction&amp;lt;Err&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A last thing we can do in this level of the API is to think about cases where one would write generic code that works both with fallible and infallible transactions. Using a unified interface would not be as nice as using the dedicated one - as it deal with error types even if the transaction can never fail - but may provide better code reusability. We can hide the difference by defining a trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Transaction&amp;lt;Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;OpIn: Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;, OpOut: Clone &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;: impl Operation&amp;lt;In = OpIn, Out = OpOut, Err = Err&amp;gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: OpIn,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;OpOut, Err&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;fail&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;error&lt;&#x2F;span&gt;&lt;span&gt;: Err) -&amp;gt; Result&amp;lt;(), Err&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Out&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: impl FnOnce(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;mut Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Out, Err&amp;gt;) -&amp;gt; TransactionResult&amp;lt;Out, Err&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The trait provides a way to execute operations and explicitly fail the transaction, and it also generalizes the &lt;code&gt;fallible_transaction&lt;&#x2F;code&gt; and &lt;code&gt;infallible_transaction&lt;&#x2F;code&gt; function with a static function called &lt;code&gt;run&lt;&#x2F;code&gt;. Implementing this interface for our two transaction types is straightforward.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;defining-operations&quot;&gt;Defining operations&lt;&#x2F;h3&gt;
&lt;p&gt;We defined an &lt;code&gt;Operation&lt;&#x2F;code&gt; trait but haven&#x27;t talked yet about how we will declare new operations. One obvious way is to define a type and implement the trait for it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;CreateAccount {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; configuration
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Operation &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;CreateAccount {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;In  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; AccountDetails;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Out &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; AccountId;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Err &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; DomainError;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: AccountDetails) -&amp;gt; Result&amp;lt;AccountId, DomainError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;      todo!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Create the account&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;compensate&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: AccountDetails, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;: AccountId) -&amp;gt; Result&amp;lt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;      todo!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Delete the account&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The library provides a more concise way to define ad-hoc operations by just passing two functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;In: Clone, Out: Clone, Err: Clone&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;execute_fn&lt;&#x2F;span&gt;&lt;span&gt;: impl Fn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;In&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Out, Err&amp;gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;compensate_fn&lt;&#x2F;span&gt;&lt;span&gt;: impl Fn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;In&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;Out&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), Err&amp;gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; impl Operation&amp;lt;In = In, Out = Out, Err = Err&amp;gt; { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; op &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;move |&lt;&#x2F;span&gt;&lt;span&gt;account_details: AccountDetails&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    todo!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Create the account&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;	},
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;move |&lt;&#x2F;span&gt;&lt;span&gt;account_details: AccountDetails, account_id: AccountId&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    todo!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Delete the account&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  });
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Under the hood this creates a struct called &lt;code&gt;FnOperation&lt;&#x2F;code&gt; storing these two closures in it.&lt;&#x2F;p&gt;
&lt;p&gt;There is a third way though. Let&#x27;s see how it looks like, and then explore how it can be implemented with &lt;em&gt;Rust macros&lt;&#x2F;em&gt;!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;golem_operation&lt;&#x2F;span&gt;&lt;span&gt;(compensation&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;delete_account)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;AccountId, DomainError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  todo!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Create the account&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;delete_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;account_id&lt;&#x2F;span&gt;&lt;span&gt;: AccountId) -&amp;gt; Result&amp;lt;(), DomainError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  todo!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Delete the account&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;infallible_transaction&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tx&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; account_id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;vigoo&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;x@y&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;operation-macro&quot;&gt;Operation macro&lt;&#x2F;h3&gt;
&lt;p&gt;In the above example &lt;code&gt;golem_operation&lt;&#x2F;code&gt; is a macro. It is a function executed compile time that takes the annotated item - in this case the &lt;code&gt;create_account&lt;&#x2F;code&gt; function and &lt;strong&gt;transforms&lt;&#x2F;strong&gt; it to something else.&lt;&#x2F;p&gt;
&lt;p&gt;The first thing to figure out when writing a macro like that is what exactly we want to transform the function into. Let&#x27;s see what this macro generates, and then I explain how to get there.&lt;&#x2F;p&gt;
&lt;p&gt;If we expand the macro for the above example we get the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;AccountId, DomainError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    todo!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Create the account&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span&gt;CreateAccount {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;AccountId, DomainError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: Transaction&amp;lt;DomainError&amp;gt;&amp;gt; CreateAccount &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;mut T {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;AccountId, DomainError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;            |(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;): (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;)| {
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_account&lt;&#x2F;span&gt;&lt;span&gt;(username, email)
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            |(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;): (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;op_result&lt;&#x2F;span&gt;&lt;span&gt;: AccountId| {
&lt;&#x2F;span&gt;&lt;span&gt;    	        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call_compensation_function&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                delete_account,
&lt;&#x2F;span&gt;&lt;span&gt;                op_result,
&lt;&#x2F;span&gt;&lt;span&gt;                (username, email)
&lt;&#x2F;span&gt;&lt;span&gt;              ).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map_err&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;err&lt;&#x2F;span&gt;&lt;span&gt;| err.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        }), (username, email))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So seems like the macro leaves the function in its original form, but generates some additional items: a &lt;em&gt;trait&lt;&#x2F;em&gt; which contains the same function signature as the annotated one, and then an &lt;em&gt;implementation&lt;&#x2F;em&gt; for this trait for any &lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; where &lt;code&gt;T&lt;&#x2F;code&gt; is a &lt;code&gt;Transaction&amp;lt;DomainError&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;As I explained above, &lt;code&gt;Transaction&lt;&#x2F;code&gt; is a trait that provides a unified interface for both the fallible and infallible transactions. With this instance we define an &lt;strong&gt;extension method&lt;&#x2F;strong&gt; for the &lt;code&gt;tx&lt;&#x2F;code&gt; value we get in our transaction functions - this is what allows us to write &lt;code&gt;tx.create_account&lt;&#x2F;code&gt; in the above example.&lt;&#x2F;p&gt;
&lt;p&gt;Two more details to notice:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Our &lt;code&gt;Operation&lt;&#x2F;code&gt; type deals with a single input value but our annotated function can have arbitrary number of parameters. We can solve this by defining the operation&#x27;s input as a &lt;strong&gt;tuple&lt;&#x2F;strong&gt; containing all the function parameters.&lt;&#x2F;li&gt;
&lt;li&gt;The compensation function (&lt;code&gt;delete_action&lt;&#x2F;code&gt;) is not called directly, but through a helper called &lt;code&gt;call_compensation_function&lt;&#x2F;code&gt;. This allows us to support compensation functions of different shapes, and I will explain how it works in details.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;defining-the-macro-and-parsing-the-function&quot;&gt;Defining the macro and parsing the function&lt;&#x2F;h4&gt;
&lt;p&gt;This type of Rust macro which is invoked by annotating items in the code is called a &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;procedural-macros.html&quot;&gt;proc-macro&lt;&#x2F;a&gt;. We need to create a separate Rust &lt;em&gt;crate&lt;&#x2F;em&gt; for defining the macro, and set &lt;code&gt;proc-macro = true&lt;&#x2F;code&gt; in its &lt;code&gt;Cargo.toml&lt;&#x2F;code&gt; file and then create a top-level function annotated with &lt;code&gt;#[proc_macro_attribute]&lt;&#x2F;code&gt; to define our macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;proc_macro_attribute&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;golem_operation&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;attr&lt;&#x2F;span&gt;&lt;span&gt;: TokenStream, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;item&lt;&#x2F;span&gt;&lt;span&gt;: TokenStream) -&amp;gt; TokenStream {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust macros are transformations on &lt;strong&gt;token streams&lt;&#x2F;strong&gt;. The first parameter of our macro gets the &lt;em&gt;parameters&lt;&#x2F;em&gt; passed to the macro - so in our example it will contain a stream of tokens representing &lt;code&gt;compensation=delete_account&lt;&#x2F;code&gt;. The second parameter is the annotated item itself - in our case it&#x27;s a stream of tokens of the whole function definition including its body.&lt;&#x2F;p&gt;
&lt;p&gt;The result of the function is also a token stream and the easiest thing we can do is to just return &lt;code&gt;item&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;proc_macro_attribute&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;golem_operation&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;attr&lt;&#x2F;span&gt;&lt;span&gt;: TokenStream, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;item&lt;&#x2F;span&gt;&lt;span&gt;: TokenStream) -&amp;gt; TokenStream {
&lt;&#x2F;span&gt;&lt;span&gt;  item
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a valid macro that does not do anything.&lt;&#x2F;p&gt;
&lt;p&gt;We somehow have to generate a trait and a trait implementation with only having these two token streams. Before we can generate anything we need to understand the annotated function - we need its name, its parameters, its result type etc.&lt;&#x2F;p&gt;
&lt;p&gt;We can use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;&quot;&gt;syn&lt;&#x2F;a&gt; create for this to parse the stream of tokens into a Rust AST.&lt;&#x2F;p&gt;
&lt;p&gt;To parse &lt;code&gt;item&lt;&#x2F;code&gt; as a function, we can write:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ast: ItemFn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;syn::parse(item).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;expect&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Expected a function&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is something we can extract information from, for example &lt;code&gt;ItemFn&lt;&#x2F;code&gt; has the following contents:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ItemFn {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;attrs&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Attribute&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;vis&lt;&#x2F;span&gt;&lt;span&gt;: Visibility,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;sig&lt;&#x2F;span&gt;&lt;span&gt;: Signature,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;block&lt;&#x2F;span&gt;&lt;span&gt;: Box&amp;lt;Block&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And &lt;code&gt;sig&lt;&#x2F;code&gt; contains things like the function&#x27;s name, parameters and return type. It is important to keep in mind though that this is just a parsed AST from the tokens - the whole transformation runs before any type checking and we don&#x27;t have any way to identify actual Rust types. We only see what&#x27;s in the source code.&lt;&#x2F;p&gt;
&lt;p&gt;For example in our macro we expect that the annotated function returns with a &lt;code&gt;Result&lt;&#x2F;code&gt; type and we need to look into this type because we will use the success and error types in separate places in the generated code.&lt;&#x2F;p&gt;
&lt;p&gt;We cannot do this in a 100% reliable way. We can look for things like the result type &lt;em&gt;looks like&lt;&#x2F;em&gt; a &lt;code&gt;Result&amp;lt;Out, Err&amp;gt;&lt;&#x2F;code&gt;, and we may support some additional forms such as &lt;code&gt;std::result::Result&amp;lt;Out, Err&amp;gt;&lt;&#x2F;code&gt;, but if the user defined a type alias and uses that, a macro that looks at the AST cannot know that it is equal to a result type. In many cases these limitations can be solved by applying type level programming - we could have a trait that extracts the success and error types of a &lt;code&gt;Result&lt;&#x2F;code&gt; and is not implemented for any other type, and then generate code from the macro that uses these helper types.&lt;&#x2F;p&gt;
&lt;p&gt;The current implementation of the &lt;code&gt;golem_operation&lt;&#x2F;code&gt; macro does not do this for determining the result types, so it has this limitation that it only works if you use the &quot;standard&quot; way of writing &lt;code&gt;Result&amp;lt;Out, Err&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This looks like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;result_type&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;ty&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Type) -&amp;gt; Option&amp;lt;(Type, Type)&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; ty {
&lt;&#x2F;span&gt;&lt;span&gt;        Type::Group(group) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;result_type&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;group.elem),
&lt;&#x2F;span&gt;&lt;span&gt;        Type::Paren(paren) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;result_type&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;paren.elem),
&lt;&#x2F;span&gt;&lt;span&gt;        Type::Path(type_path) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;					&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; idents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; type_path.path.segments.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;segment&lt;&#x2F;span&gt;&lt;span&gt;| segment.ident.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;()).collect::&amp;lt;Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#e06c75;color:#fafafa;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; idents &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span&gt;vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Result&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;] { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ... some more cases
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; last_segment &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; type_path.path.segments.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;last&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;syn::PathArguments::AngleBracketed(generics) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;last_segment.arguments &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None };
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; generics.args.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;syn::GenericArgument::Type(success_type) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;generics.args[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;            };
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;syn::GenericArgument::Type(err_type) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;generics.args[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span&gt;						};
&lt;&#x2F;span&gt;&lt;span&gt;            Some((success_type.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;(), err_type.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;()))
&lt;&#x2F;span&gt;&lt;span&gt;          }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ... other cases returning None
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once we have all the information we need - the function&#x27;s name, its parameters, the successful and failed result types, all in &lt;code&gt;syn&lt;&#x2F;code&gt; AST nodes, we can generate the additional code that we can return in the end as the new token stream.&lt;&#x2F;p&gt;
&lt;p&gt;To generate token stream we use the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;quote&#x2F;latest&#x2F;quote&#x2F;&quot;&gt;quote library&lt;&#x2F;a&gt;. This library provides the &lt;code&gt;quote!&lt;&#x2F;code&gt; macro, which itself generates a &lt;code&gt;TokenStream&lt;&#x2F;code&gt; . (Although it is not the same &lt;code&gt;TokenStream&lt;&#x2F;code&gt; as the one we need to return from the macro. The macro requires &lt;code&gt;proc_macro::TokenStream&lt;&#x2F;code&gt; and &lt;code&gt;quote!&lt;&#x2F;code&gt; returns &lt;code&gt;proc_macro2::TokenStream&lt;&#x2F;code&gt;. Fortunately it can be simply converted with &lt;code&gt;.into()&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;We write a single &lt;code&gt;quote!&lt;&#x2F;code&gt; for producing the result of the macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;quote! {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;ast
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;trait #&lt;&#x2F;span&gt;&lt;span&gt;traitname {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;fnsig;
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: golem_rust::Transaction&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#e06c75;color:#fafafa;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;err&amp;gt;&amp;gt; #traitname for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;mut T {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;fnsig {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;execute&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        golem_rust::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;          |#&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input_pattern&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;fnname&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;input_args), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;          },
&lt;&#x2F;span&gt;&lt;span&gt;          |#&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;compensation_pattern&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;compensate&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;compensation,
&lt;&#x2F;span&gt;&lt;span&gt;              (op_result,),
&lt;&#x2F;span&gt;&lt;span&gt;              (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;compensation_args), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            ).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map_err&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;err&lt;&#x2F;span&gt;&lt;span&gt;| err.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;          }
&lt;&#x2F;span&gt;&lt;span&gt;        ),
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span&gt;input_args), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      )
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;result.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; proc_macro2::TokenStream to proc_macro::TokenStream
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All the parts prefixed with &lt;code&gt;#&lt;&#x2F;code&gt; are references to rust variables outside of the quote, and they can be (and usually are) various &lt;code&gt;syn&lt;&#x2F;code&gt; AST nodes or raw token streams.&lt;&#x2F;p&gt;
&lt;p&gt;There is a special syntax for interpolating sequences of values. The case used in the above example is when you write &lt;code&gt;#(#var), *&lt;&#x2F;code&gt;. This means that &lt;code&gt;var&lt;&#x2F;code&gt; is expected to be an iterable variable (in our case it will be &lt;code&gt;Vec&amp;lt;_&amp;gt;&lt;&#x2F;code&gt; usually) and it interpolates each elements by inserting extra tokens, defined between &lt;code&gt;)&lt;&#x2F;code&gt; and &lt;code&gt;*&lt;&#x2F;code&gt;, between these elements. So this example would insert a comma and a space between the elements.&lt;&#x2F;p&gt;
&lt;p&gt;The above defined &lt;code&gt;quote&lt;&#x2F;code&gt; is a template that matches what we wanted to generate. All that&#x27;s needed is to define all these variables holding dynamic parts of the generated code. The &lt;code&gt;#ast&lt;&#x2F;code&gt; variable itself is the parsed function - so the first line of the quote just makes sure the original definition is part of the result.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;#succ&lt;&#x2F;code&gt; and &lt;code&gt;#err&lt;&#x2F;code&gt; types are extracted with the &lt;code&gt;result_type&lt;&#x2F;code&gt; helper function as described above. The others are just defined by either transforming and cloning AST nodes, or using &lt;code&gt;quote!&lt;&#x2F;code&gt; to generate sub token streams.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see a few examples!&lt;&#x2F;p&gt;
&lt;p&gt;The new trait&#x27;s name has to be an &lt;code&gt;Ident&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; fnname &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; fnsig.ident.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; traitname &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Ident::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;fnname.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;to_pascal_case&lt;&#x2F;span&gt;&lt;span&gt;(), fnsig.ident.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;span&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we use the &lt;code&gt;to_pascal_case&lt;&#x2F;code&gt; extension method provided by the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;heck&#x2F;latest&#x2F;heck&#x2F;&quot;&gt;heck crate&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Another example is the signature of the function that&#x27;s inside the trait. It is &lt;em&gt;almost&lt;&#x2F;em&gt; the same as the annotated feature, but it has to have a &lt;code&gt;self&lt;&#x2F;code&gt; parameter as the first parameter of it, that&#x27;s how it becomes an extension method on the transaction.&lt;&#x2F;p&gt;
&lt;p&gt;We can do this by cloning the annotated function&#x27;s signature and just adding a new parameter:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; fnsig &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; ast.sig.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;fnsig.inputs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;insert&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, parse_quote! { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that &lt;code&gt;parse_quote!&lt;&#x2F;code&gt; immediately parses the token stream generated by quote back to a &lt;code&gt;syn&lt;&#x2F;code&gt; AST node.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;compensation-function-shapes&quot;&gt;Compensation function shapes&lt;&#x2F;h4&gt;
&lt;p&gt;The last interesting bit is how the macro supports compensation functions of different shapes. What we support right now, is the following.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The compensation function has no parameters at all&lt;&#x2F;li&gt;
&lt;li&gt;The compensation function takes the output of the action but not the inputs&lt;&#x2F;li&gt;
&lt;li&gt;The compensation function takes the output and all the inputs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;With the account creation example this means all of these are valid:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;golem_operation&lt;&#x2F;span&gt;&lt;span&gt;(compensation&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;delete_account)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;AccountId, DomainError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;delete_account&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Result&amp;lt;(), DomainError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;delete_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;account_id&lt;&#x2F;span&gt;&lt;span&gt;: AccountId) -&amp;gt; Result&amp;lt;(), DomainError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;delete_account&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;account_id&lt;&#x2F;span&gt;&lt;span&gt;: AccountId, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;username&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;email&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), DomainError&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we could have the AST of &lt;code&gt;delete_account&lt;&#x2F;code&gt; from the macro, it would be easy to decide which shape we have - we would not even need to worry about not having actual types because we could just compare the parameter list and result type tokens of the two functions to be able to decide which way to go.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately our macro is on the &lt;code&gt;create_account&lt;&#x2F;code&gt; function and there is no way to access anything else about &lt;code&gt;delete_account&lt;&#x2F;code&gt; from it than the &lt;code&gt;compensation=delete_account&lt;&#x2F;code&gt; part which we passed as an attribute parameter.&lt;&#x2F;p&gt;
&lt;p&gt;Before solving this problem let&#x27;s see how we can get the &lt;em&gt;name&lt;&#x2F;em&gt; of the compensation function, at least:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; args &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;parse_macro_input!(args with Punctuated::&amp;lt;Meta, syn::Token&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#e06c75;color:#fafafa;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;[,]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;::parse_terminated);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; compensation &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;None;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; arg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; args {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Meta::NameValue(name_value) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; arg {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; name_value.path.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_ident&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; name_value.value;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;compensation&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      compensation &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Some(value);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We parse the macro&#x27;s input into a list of &lt;code&gt;Meta&lt;&#x2F;code&gt; nodes, and look for the &lt;code&gt;NameValue&lt;&#x2F;code&gt; cases representing the attribute arguments having the &lt;code&gt;x=y&lt;&#x2F;code&gt; form. If the key is &lt;code&gt;compensation&lt;&#x2F;code&gt; we store the value, which has the type &lt;code&gt;Expr&lt;&#x2F;code&gt; (expression AST node) and we can interpolate this expression node directly in the quoted code to get our function name.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s go back to the primary problem - how can we generate code that invokes this function which can have three different shapes, if we cannot know which one it is?&lt;&#x2F;p&gt;
&lt;p&gt;First we define a &lt;strong&gt;trait&lt;&#x2F;strong&gt; that abstracts this problem for us:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CompensationFunction&amp;lt;In, Out, Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;: Out, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: In) -&amp;gt; Result&amp;lt;(), Err&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This always has the same shape - we just pass both the results and the inputs to it, and the trait&#x27;s implementation can decide to use any of these parameters to actually call the compensation function or not.&lt;&#x2F;p&gt;
&lt;p&gt;We can define a function that takes an arbitrary value &lt;code&gt;T&lt;&#x2F;code&gt; for which we have an implementation of this trait, and just call it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call_compensation_function&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;In, Out, Err&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: impl CompensationFunction&amp;lt;In, Out, Err&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;: Out,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: In,
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    f.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(result, input)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this, we can simply generate code from the macro that passes &lt;strong&gt;the actual compensation function&lt;&#x2F;strong&gt; to the &lt;code&gt;f&lt;&#x2F;code&gt; parameter of &lt;code&gt;call_compensation_function&lt;&#x2F;code&gt;, and always pass both the result and the input!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call_compensation_function&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;  delete_account,
&lt;&#x2F;span&gt;&lt;span&gt;  op_result,
&lt;&#x2F;span&gt;&lt;span&gt;  (username, email)
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To make this work we need instances of &lt;code&gt;CompensationFunction&lt;&#x2F;code&gt; for arbitrary function types.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s try to define it for the function with no parameters (the first supported shape):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F, Err&amp;gt; CompensationFunction&amp;lt;(), (), Err&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;F
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    F: FnOnce() -&amp;gt; Result&amp;lt;(), Err&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_result&lt;&#x2F;span&gt;&lt;span&gt;: (),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_input&lt;&#x2F;span&gt;&lt;span&gt;: (),
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;(), (Err,)&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is not the final implementation as we will see soon. If we try to write an implementation for the second shape - where we only use the result and not the input, we immediately run into a problem:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F, Out, Err&amp;gt; CompensationFunction&amp;lt;(), Out, Err&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;F
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    F: FnOnce(Out) -&amp;gt; Result&amp;lt;(), Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error is about &lt;strong&gt;conflicting implementations&lt;&#x2F;strong&gt; of our trait:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0119]: conflicting implementations of trait `CompensationFunction&amp;lt;(), (), _&amp;gt;`
&lt;&#x2F;span&gt;&lt;span&gt;  --&amp;gt; golem-rust&#x2F;src&#x2F;transaction&#x2F;compfn.rs:45:1
&lt;&#x2F;span&gt;&lt;span&gt;   |
&lt;&#x2F;span&gt;&lt;span&gt;31 | &#x2F; impl&amp;lt;F, Err&amp;gt; CompensationFunction&amp;lt;(), (), Err&amp;gt; for F
&lt;&#x2F;span&gt;&lt;span&gt;32 | | where
&lt;&#x2F;span&gt;&lt;span&gt;33 | |     F: FnOnce() -&amp;gt; Result&amp;lt;(), Err&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   | |___________________________________- first implementation here
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;45 | &#x2F; impl&amp;lt;F, Out, Err&amp;gt; CompensationFunction&amp;lt;(), Out, Err&amp;gt; for F
&lt;&#x2F;span&gt;&lt;span&gt;46 | | where
&lt;&#x2F;span&gt;&lt;span&gt;47 | |     F: FnOnce(Out) -&amp;gt; Result&amp;lt;(), Err&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   | |______________________________________^ conflicting implementation
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These. two trait implementations &lt;strong&gt;overlap&lt;&#x2F;strong&gt;. Although it is not obvious at first glance why the two are overlapping, what happens is all the types involved in the overlap check can be unified:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The trait&#x27;s parameters -
&lt;ul&gt;
&lt;li&gt;the first is &lt;code&gt;()&lt;&#x2F;code&gt; in both cases&lt;&#x2F;li&gt;
&lt;li&gt;The second is &lt;code&gt;()&lt;&#x2F;code&gt; vs &lt;code&gt;Out&lt;&#x2F;code&gt;. Nothing prevents &lt;code&gt;Out&lt;&#x2F;code&gt; to be &lt;code&gt;()&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;The third can be anything in both cases&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;The type we implement the trait for
&lt;ul&gt;
&lt;li&gt;This is the confusing part - as we have two different function type signatures in the two cases! But these are only type bounds. We say we implement &lt;code&gt;CompensationFunction&lt;&#x2F;code&gt; for a type &lt;code&gt;F&lt;&#x2F;code&gt; which implements the trait &lt;code&gt;FnOnce() ...&lt;&#x2F;code&gt;. The problem is that in theory there can be a type that implements both these function traits, so this is not preventing the overlap either.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is something &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;blob&#x2F;master&#x2F;text&#x2F;1210-impl-specialization.md&quot;&gt;specialization&lt;&#x2F;a&gt; would solve but that is currently an unstable compiler feature.&lt;&#x2F;p&gt;
&lt;p&gt;If at least one of the above types could not be unified, we would not have an overlap, so that&#x27;s what we have to do. The simplest way to do so is to stop having unconstrained types in the trait&#x27;s type parameters such as &lt;code&gt;In&lt;&#x2F;code&gt; and &lt;code&gt;Out&lt;&#x2F;code&gt; and &lt;code&gt;Err&lt;&#x2F;code&gt; (Actually &lt;code&gt;Err&lt;&#x2F;code&gt; should not be affected by this, but I applied the same technique to all parameters at once in the library. This is something that could be potentially simplified in the future.).&lt;&#x2F;p&gt;
&lt;p&gt;So we just have to have a type parameter that can contain an arbitrary input or output type, but does not unify with &lt;code&gt;()&lt;&#x2F;code&gt;. We can do that by wrapping the output type in a tuple:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F, Out, Err&amp;gt; CompensationFunction&amp;lt;(), (Out,), (Err,)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;F
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    F: FnOnce(Out) -&amp;gt; Result&amp;lt;(), Err&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here instead of &lt;code&gt;Out&lt;&#x2F;code&gt; we use &lt;code&gt;(Out,)&lt;&#x2F;code&gt; which is a 1-tuple wrapping our output type. This no longer unifies with &lt;code&gt;()&lt;&#x2F;code&gt; so the compiler error is solved!&lt;&#x2F;p&gt;
&lt;p&gt;We can imagine additional trait implementations for one or more input parameters:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F, T1, Out, Err&amp;gt; CompensationFunction&amp;lt;(T1,), (Out,), (Err,)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;F
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    F: FnOnce(Out, T1) -&amp;gt; Result&amp;lt;(), Err&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;impl&amp;lt;F, T1, T2, Out, Err&amp;gt; CompensationFunction&amp;lt;(T1,T2), (Out,), (Err,)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; F
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    F: FnOnce(Out, T1, T2) -&amp;gt; Result&amp;lt;(), Err&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Two more problems to solve before we are done!&lt;&#x2F;p&gt;
&lt;p&gt;The first problem occurs when we try to use this mechanism for the first to compensation function shapes - when the result, or the result and the input are not used by the function.&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that these trait implementations bind the &lt;code&gt;In&lt;&#x2F;code&gt; and&#x2F;or &lt;code&gt;Out&lt;&#x2F;code&gt; types to &lt;code&gt;()&lt;&#x2F;code&gt; in these cases, which means that our &lt;code&gt;call&lt;&#x2F;code&gt; function will use the unit type for these parameters. For example for &lt;code&gt;delete_account&lt;&#x2F;code&gt; which does not takes the input parameters, it would have the following types if we replace the generic parameters with the inferred ones:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call_compensation_function&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: impl FnOnce(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;AccountId&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), DomainError&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;: AccountId,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: (),
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), DomainError&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And our macro will call it like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call_compensation_function&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;  delete_account,
&lt;&#x2F;span&gt;&lt;span&gt;  op_result,
&lt;&#x2F;span&gt;&lt;span&gt;  (username, email)
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This of course will not compile, because we pass &lt;code&gt;(&amp;amp;str, &amp;amp;str)&lt;&#x2F;code&gt; in place of a &lt;code&gt;()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a step back, and change our &lt;code&gt;CompensationFunction&lt;&#x2F;code&gt; trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;CompensationFunction&amp;lt;In, Out, Err&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;: impl TupleOrUnit&amp;lt;Out&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: impl TupleOrUnit&amp;lt;In&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  ) -&amp;gt; Result&amp;lt;(), Err&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Instead of directly taking &lt;code&gt;Out&lt;&#x2F;code&gt; and &lt;code&gt;In&lt;&#x2F;code&gt; in the parameters we now accept &lt;strong&gt;anything that implements TupleOrUnit&lt;&#x2F;strong&gt; for the given type.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;TupleOrUnit&lt;&#x2F;code&gt; is just a special conversion trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;TupleOrUnit&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; T;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What makes it special and what makes it solve our problem is what instances we have for it.&lt;&#x2F;p&gt;
&lt;p&gt;First of all we say that &lt;strong&gt;anything can be converted to unit&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; TupleOrUnit&amp;lt;()&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;T {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we use the same trick to avoid overlapping instances, and we say that 1-tuple, 2-tuple, etc. can be converted to itself only:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T1&amp;gt; TupleOrUnit&amp;lt;(T1, )&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; (T1, ) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (T1, ) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T1, T2&amp;gt; TupleOrUnit&amp;lt;(T1, T2, )&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; (T1, T2, ) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (T1, T2, ) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this we achieved that the &lt;code&gt;call_compensation_function&lt;&#x2F;code&gt; function is still type safe - it requires us to pass the proper &lt;code&gt;Out&lt;&#x2F;code&gt; and &lt;code&gt;In&lt;&#x2F;code&gt; types - but in the special case when either of these types are unit, it allows us to pass an arbitrary value instead of an actual &lt;code&gt;()&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This makes our macro complete.&lt;&#x2F;p&gt;
&lt;p&gt;The last thing to solve is to have enough instances of these two type classes - &lt;code&gt;CompensationFunction&lt;&#x2F;code&gt; and &lt;code&gt;TupleOrUnit&lt;&#x2F;code&gt; so our library works with more than 1 or 2 parameters. Writing them by hand is an option but we can easily generate them with another macro!&lt;&#x2F;p&gt;
&lt;p&gt;This time we don&#x27;t have to write a procedural macro - we can use a &lt;strong&gt;declarative macro&lt;&#x2F;strong&gt;s which are simpler, and they can be defined inline in the same module where we define these types.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s start with &lt;code&gt;TupleOrUnit&lt;&#x2F;code&gt; as it is a bit simpler. We use the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;macros-by-example.html&quot;&gt;macro_rules&lt;&#x2F;a&gt; macro which is basically a pattern match with a special syntax - you can match on what is passed to the macro, and generate code with interpolation similar to the &lt;code&gt;quote!&lt;&#x2F;code&gt; macro - but using &lt;code&gt;$&lt;&#x2F;code&gt; instead of &lt;code&gt;#&lt;&#x2F;code&gt; as the interpolation symbol. The following definition defines an instance of &lt;code&gt;TupleOrUnit&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;macro_rules! &lt;&#x2F;span&gt;&lt;span&gt;tuple_or_unit {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;ident&lt;&#x2F;span&gt;&lt;span&gt;),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;),*&amp;gt; TupleOrUnit&amp;lt;($(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;,)*)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; ($(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;,)*) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; ($(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;,)*) {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have a single case of our pattern match, which matches a &lt;strong&gt;comma-separated list of identifiers&lt;&#x2F;strong&gt;. We can refer to this list of identifiers as &lt;code&gt;ty&lt;&#x2F;code&gt;. Then we use the same syntax for interpolating sequences into the code as we have seen already in our procedural macro and just generate the instance.&lt;&#x2F;p&gt;
&lt;p&gt;We can call this macro with a list of type parameters (which are all &lt;em&gt;identifiers&lt;&#x2F;em&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;tuple_or_unit!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T3&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s do the same for generating &lt;code&gt;CompensationFunction&lt;&#x2F;code&gt; instances:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;macro_rules! &lt;&#x2F;span&gt;&lt;span&gt;compensation_function {
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;ident&lt;&#x2F;span&gt;&lt;span&gt;),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F, $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;),*, Out, Err&amp;gt; CompensationFunction&amp;lt;($(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;),*,), (Out,), (Err,)&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;F
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;            F: FnOnce(Out, $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;),*) -&amp;gt; Result&amp;lt;(), Err&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;out&lt;&#x2F;span&gt;&lt;span&gt;: impl TupleOrUnit&amp;lt;(Out,)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: impl TupleOrUnit&amp;lt;($(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;),*,)&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            ) -&amp;gt; Result&amp;lt;(), (Err,)&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;allow&lt;&#x2F;span&gt;&lt;span&gt;(non_snake_case)]
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;,)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(out,) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; out.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;(out, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map_err&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;err&lt;&#x2F;span&gt;&lt;span&gt;| (err,))
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only interesting part here is how we access the components of our tuple.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s imagine we pass &lt;code&gt;T1, T2, T3&lt;&#x2F;code&gt; as arguments to this macro, so &lt;code&gt;ty&lt;&#x2F;code&gt; is a sequence of three identifiers. We can interpolate this comma separated list into the type parameter part (&lt;code&gt;impl&amp;lt;F, $($ty),*, Out, Err&amp;gt;&lt;&#x2F;code&gt;) without any problems but this is still just a list of identifiers - and when we call our compensation function (&lt;code&gt;self&lt;&#x2F;code&gt;), we have to access the individual elements of this tuple and pass them to the function as separate parameters.&lt;&#x2F;p&gt;
&lt;p&gt;We could write it by hand like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;out&lt;&#x2F;span&gt;&lt;span&gt;: impl TupleOrUnit&amp;lt;(Out,)), input: impl TupleOrUnit&amp;lt;(T1, T2, T3)&amp;gt;) -&amp;gt; Result&amp;lt;(), Err&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#e06c75;color:#fafafa;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;out&lt;&#x2F;span&gt;&lt;span&gt;: Out = out.into();
&lt;&#x2F;span&gt;&lt;span&gt;  let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;T1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;T2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;T3&lt;&#x2F;span&gt;&lt;span&gt;) = input.into();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;out&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;.0, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;.1, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;.2)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It is possible to generate a list of accessors like this from a procedural macro, but not in a declarative one - we only have &lt;code&gt;ty&lt;&#x2F;code&gt; to work with. We can instead &lt;strong&gt;destructure&lt;&#x2F;strong&gt; the tuple and we can actually reuse the list of identifiers to do so!&lt;&#x2F;p&gt;
&lt;p&gt;In the above macro code, this can be seen as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;allow&lt;&#x2F;span&gt;&lt;span&gt;(non_snake_case)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;,)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;(out, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$ty&lt;&#x2F;span&gt;&lt;span&gt;),&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This translates to&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;allow&lt;&#x2F;span&gt;&lt;span&gt;(non_snake_case)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T3&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; input.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;(out, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;T3&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The error mapping is only necessary because currently the error typed is also wrapped into a tuple - this could enable additional function shapes where the compensation function never fails, for example, but it is not implemented yet.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;The library described here is open source and is available &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;golemcloud&#x2F;golem-rust&quot;&gt;on GitHub&lt;&#x2F;a&gt; and published &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;golem-rust&quot;&gt;to crates.io&lt;&#x2F;a&gt;. Documentation and examples will soon be added to &lt;a href=&quot;https:&#x2F;&#x2F;learn.golem.cloud&#x2F;docs&#x2F;intro&quot;&gt;Golem&#x27;s learn pages&lt;&#x2F;a&gt;. And of course this is just a first version I hope to see grow based on user feedback.&lt;&#x2F;p&gt;
&lt;p&gt;We also plan to have similar higher-level wrapper libraries for Golem&#x27;s features for the other supported languages - everything Golem provides is exposed through the WASM Component Model so any language supporting that have immediate access to the building blocks. All remains is writing idiomatic wrappers on top of them for each language.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Generating a Rust client library for ZIO Http endpoints</title>
        <published>2023-09-07T00:00:00+00:00</published>
        <updated>2023-09-07T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Daniel Vigovszky
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.vigoo.dev/posts/generating-a-rust-client-library-for-zio-http-endpoints/"/>
        <id>https://blog.vigoo.dev/posts/generating-a-rust-client-library-for-zio-http-endpoints/</id>
        
        <content type="html" xml:base="https://blog.vigoo.dev/posts/generating-a-rust-client-library-for-zio-http-endpoints/">&lt;p&gt;We at &lt;a href=&quot;https:&#x2F;&#x2F;golem.cloud&quot;&gt;Golem Cloud&lt;&#x2F;a&gt; built our first developer preview on top of the ZIO ecosystem, including &lt;a href=&quot;https:&#x2F;&#x2F;github.io&#x2F;zio&#x2F;zio-http&quot;&gt;ZIO Http&lt;&#x2F;a&gt; for defining and implementing our server&#x27;s REST API. By using &lt;strong&gt;ZIO Http&lt;&#x2F;strong&gt; we immediately had the ability to call our endpoints using endpoint &lt;strong&gt;client&lt;&#x2F;strong&gt;s, which allowed us to develop the first version of Golem&#x27;s &lt;strong&gt;CLI tool&lt;&#x2F;strong&gt; very rapidly.&lt;&#x2F;p&gt;
&lt;p&gt;Although very convenient for development, &lt;em&gt;using&lt;&#x2F;em&gt; a CLI tool built with Scala for the JVM is not a pleasant experience for the users due to the slow startup time. One possible solution is to compile to native using &lt;a href=&quot;https:&#x2F;&#x2F;www.graalvm.org&#x2F;22.0&#x2F;reference-manual&#x2F;native-image&#x2F;&quot;&gt;GraalVM Native Image&lt;&#x2F;a&gt; but it is very hard to set up and even when it works, it is extremely fragile - further changes to the code or updated dependencies can break it causing unexpected extra maintenance cost. After some initial experiments we dropped this idea - and instead chose to reimplement the CLI using &lt;strong&gt;Rust&lt;&#x2F;strong&gt; - a language being a much better fit for command line tools, and also already an important technology in our Golem stack.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zio-http&quot;&gt;ZIO Http&lt;&#x2F;h2&gt;
&lt;p&gt;If we rewrite &lt;code&gt;golem-cli&lt;&#x2F;code&gt; to Rust, we lose the convenience of using  &lt;strong&gt;endpoint definitions&lt;&#x2F;strong&gt; (written in Scala with ZIO Http, the ones we have for implementing the server) for calling our API, and we would also lose all the &lt;strong&gt;types&lt;&#x2F;strong&gt; used in these APIs as they are all defined as Scala case classes and enums. Just to have more context, let&#x27;s take a look at one of the endpoints!&lt;&#x2F;p&gt;
&lt;p&gt;A ZIO Http &lt;strong&gt;endpoint&lt;&#x2F;strong&gt; is just a definition of a single endpoint of a HTTP API, describing the routing as well the inputs and outputs of it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;getWorkerMetadata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    Endpoint(GET &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;v1&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt; &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;templates&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt; &#x2F; rawTemplateId &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;workers&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt; &#x2F; workerName)
&lt;&#x2F;span&gt;&lt;span&gt;      .header(Auth.tokenSecret)
&lt;&#x2F;span&gt;&lt;span&gt;      .outErrorCodec(errorCodec)
&lt;&#x2F;span&gt;&lt;span&gt;      .out[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerMetadata&lt;&#x2F;span&gt;&lt;span&gt;] ?? Doc.p(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Get the current worker status and metadata&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s see what we have here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the endpoint is reached by sending a &lt;strong&gt;GET&lt;&#x2F;strong&gt; request&lt;&#x2F;li&gt;
&lt;li&gt;the request &lt;strong&gt;path&lt;&#x2F;strong&gt; consists of some static segments as well as the &lt;em&gt;template id&lt;&#x2F;em&gt; and the &lt;em&gt;worker name&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;
&lt;li&gt;it also requires an &lt;strong&gt;authorization header&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;we define the kind of errors it can return&lt;&#x2F;li&gt;
&lt;li&gt;and finally it defines that the response&#x27;s &lt;strong&gt;body&lt;&#x2F;strong&gt; will contain a JSON representation (default in ZIO Http) of a type called &lt;code&gt;WorkerMetadata&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;What are &lt;code&gt;rawTemplateId&lt;&#x2F;code&gt; and &lt;code&gt;workerName&lt;&#x2F;code&gt;? These are so called &lt;strong&gt;path codecs&lt;&#x2F;strong&gt;, defined in a common place so they can be reused in multiple endpoints. They allow us to have dynamic parts of the request path mapped to specific types - so when we implement the endpoint (or call it in a client) we don&#x27;t have to pass strings and we can directly work with the business domain types, in this case &lt;code&gt;RawTemplateId&lt;&#x2F;code&gt; and &lt;code&gt;WorkerName&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The simplest way to define path codecs is to &lt;strong&gt;transform&lt;&#x2F;strong&gt; an existing one:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;workerName&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;PathCodec&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerName&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  string(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;worker-name&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).transformOrFailLeft(WorkerName.make(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;).toErrorEither, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;.value)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here the &lt;code&gt;make&lt;&#x2F;code&gt; function is a &lt;strong&gt;ZIO Prelude&lt;&#x2F;strong&gt; &lt;a href=&quot;https:&#x2F;&#x2F;zio.github.io&#x2F;zio-prelude&#x2F;docs&#x2F;functionaldatatypes&#x2F;validation&quot;&gt;&lt;code&gt;Validation&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; which we have to convert to an &lt;code&gt;Either&lt;&#x2F;code&gt; for the transform function. Validations can contain more than one failures, as opposed to &lt;code&gt;Either&lt;&#x2F;code&gt;s, which allows us to compose them in a way that we can keep multiple errors instead of immediately returning with the first failure.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;tokenSecret&lt;&#x2F;code&gt; is similar, but it is a &lt;code&gt;HeaderCodec&lt;&#x2F;code&gt; describing what type of header it is and how the value of the given header should be mapped to a specific type (a token, in this case).&lt;&#x2F;p&gt;
&lt;p&gt;What is &lt;code&gt;WorkerMetadata&lt;&#x2F;code&gt; and how does ZIO Http know how to produce a JSON from it?&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s just a simple &lt;em&gt;case class&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; WorkerMetadata&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;workerId&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;ComponentInstanceId&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;accountId&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;AccountId&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;env&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;status&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;InstanceStatus&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;templateVersion&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Int&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;retryCount&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Int
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But with an implicit &lt;strong&gt;derived&lt;&#x2F;strong&gt; &lt;strong&gt;ZIO Schema&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; WorkerMetadata {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;implicit val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schema&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;: Schema[WorkerMetadata] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;DeriveSchema.gen[WorkerMetadata]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We will talk more about ZIO Schema below - for now all we need to know is it describes the structure of Scala types, and this information can be used to serialize data into various formats, including JSON.&lt;&#x2F;p&gt;
&lt;p&gt;Once we have our endpoints defined like this, we can do several things with them - they are just data describing what an endpoint looks like!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;implementing-an-endpoint&quot;&gt;Implementing an endpoint&lt;&#x2F;h3&gt;
&lt;p&gt;When developing a &lt;em&gt;server&lt;&#x2F;em&gt;, the most important thing to do with an endpoint is to &lt;strong&gt;implement&lt;&#x2F;strong&gt; it. Implementing an endpoint looks like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;getWorkerMetadataImpl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    getWorkerMetadata.implement {
&lt;&#x2F;span&gt;&lt;span&gt;      Handler.fromFunctionZIO { (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;rawTemplateId&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;workerName&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authTokenId&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ... ZIO program returning a WorkerMetadata
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;em&gt;type&lt;&#x2F;em&gt; of &lt;code&gt;getWorkerMetadataImpl&lt;&#x2F;code&gt; is &lt;code&gt;Route&lt;&#x2F;code&gt; - it is no longer just a description of what an endpoint looks like, it defines a specific HTTP route and its associated &lt;em&gt;request handler&lt;&#x2F;em&gt;, implemented by a ZIO effect (remember that ZIO effects are also values - we &lt;em&gt;describe&lt;&#x2F;em&gt; what we need to do when a request comes in, but executing it will be the responsibility of the server implementation).&lt;&#x2F;p&gt;
&lt;p&gt;The nice thing about ZIO Http endpoints is that they are completely type safe. I&#x27;ve hidden the type signature in the previous code snippets but actually &lt;code&gt;getWorkerMetadata&lt;&#x2F;code&gt; has the type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;Endpoint[
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RawTemplateId&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerName&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RawTemplateId&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerName&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;TokenSecret&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerEndpointError&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerMetadata&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;None
&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here the &lt;em&gt;second&lt;&#x2F;em&gt; type parameter defines the &lt;strong&gt;input&lt;&#x2F;strong&gt; of the request handler and the &lt;em&gt;forth&lt;&#x2F;em&gt; type parameter defines the &lt;strong&gt;output&lt;&#x2F;strong&gt; the server constructs the response from.&lt;&#x2F;p&gt;
&lt;p&gt;With these types, we really just have to implement a (ZIO) function from the input to the output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;RawTemplateId&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;WorkerName&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;TokenSecret&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;ZIO[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Any&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerEndpointError&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;WorkerMetadata&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and this is exactly what we pass to &lt;code&gt;Handler.fromFunctionZIO&lt;&#x2F;code&gt; in the above example.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;calling-an-endpoint&quot;&gt;Calling an endpoint&lt;&#x2F;h3&gt;
&lt;p&gt;The same endpoint values can also be used to make requests to our API from clients such as &lt;code&gt;golem-cli&lt;&#x2F;code&gt;. Taking advantage of the same type safe representation we can just call &lt;code&gt;apply&lt;&#x2F;code&gt; on the endpoint definition passing its input as a parameter to get an &lt;strong&gt;invocation&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;invocation &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; getInstanceMetadata(rawTemplateId, workerName, token)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;this invocation can be &lt;strong&gt;executed&lt;&#x2F;strong&gt; to perform the actual request using an &lt;code&gt;EndpointExecutor&lt;&#x2F;code&gt; which can be easily constructed from a ZIO Http &lt;code&gt;Client&lt;&#x2F;code&gt; and some other parameters like the URL of the remote server:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;executor(invocation).flatMap { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;workerMetadata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; 
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-task&quot;&gt;The task&lt;&#x2F;h2&gt;
&lt;p&gt;So can we do anything to keep this convenient way of calling our endpoints when migrating the CLI to Rust? At the time of writing we already had more than 60 endpoints, with many complex types used in them - defining them by hand in Rust, and keeping the Scala and Rust code in sync sounds like a nightmare.&lt;&#x2F;p&gt;
&lt;p&gt;The ideal case would be to have something like this in Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Worker {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;  async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_worker_metadata&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;template_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;TemplateId, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;worker_name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;WorkerName, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authorization&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Token) -&amp;gt; Result&amp;lt;WorkerMetadata, WorkerError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;with an implementation that just requires the same amount of configuration as the Scala endpoint executor (server URL, etc), and all the referenced types like &lt;code&gt;WorkerMetadata&lt;&#x2F;code&gt; would be an exact clone of the Scala types just in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Fortunately we can have (almost) this by taking advantage of the declarative nature of ZIO Http and ZIO Schema!&lt;&#x2F;p&gt;
&lt;p&gt;In the rest of this post we will see how we can &lt;strong&gt;generate Rust code&lt;&#x2F;strong&gt; using a combination of ZIO libraries to automatically have all our type definitions and client implementation ready to use from the Rust version of &lt;code&gt;golem-cli&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-building-blocks&quot;&gt;The building blocks&lt;&#x2F;h2&gt;
&lt;p&gt;We want to generate from an arbitrary set of ZIO Http &lt;code&gt;Endpoint&lt;&#x2F;code&gt; definitions a &lt;strong&gt;Rust crate&lt;&#x2F;strong&gt; ready to be compiled, published and used. We will take advantage of the following libraries:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zio.dev&#x2F;zio-http&#x2F;&quot;&gt;ZIO Http&lt;&#x2F;a&gt; as the source of &lt;strong&gt;endpoint&lt;&#x2F;strong&gt; definitions&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zio.dev&#x2F;zio-schema&#x2F;&quot;&gt;ZIO Schema&lt;&#x2F;a&gt; for observing the &lt;strong&gt;type&lt;&#x2F;strong&gt; definitions&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zio.dev&#x2F;zio-parser&#x2F;&quot;&gt;ZIO Parser&lt;&#x2F;a&gt; because it has a composable &lt;strong&gt;printer&lt;&#x2F;strong&gt; concept&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zio.dev&#x2F;zio-nio&#x2F;&quot;&gt;ZIO NIO&lt;&#x2F;a&gt; for working with the &lt;strong&gt;filesystem&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zio.dev&#x2F;zio-prelude&#x2F;&quot;&gt;ZIO Prelude&lt;&#x2F;a&gt; for implementing the stateful endpoint&#x2F;type discovery in a purely functional way&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;generating-rust-code&quot;&gt;Generating Rust code&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s start with the actual source code generation. This is something that can be done in many different ways - one extreme could be to just concatenate strings (or use a &lt;code&gt;StringBuilder&lt;&#x2F;code&gt;) while the other is to build a full real Rust &lt;em&gt;AST&lt;&#x2F;em&gt; and pretty print that. I had a &lt;a href=&quot;https:&#x2F;&#x2F;blog.vigoo.dev&#x2F;posts&#x2F;funscala2021-talk&#x2F;&quot;&gt;talk on Function Scala 2021 about the topic&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For this task I chose a technique which is somewhere in the middle and provides some extent of composability while also allowing use to do just the amount of abstraction we want to. The idea is that we define a &lt;em&gt;Rust code generator model&lt;&#x2F;em&gt; which does not have to strictly follow the actual generated language&#x27;s concepts, and then define a pretty printer for this model. This way we only have to model the subset of the language we need for the code generator, and we can keep simplifications or even complete string fragments in it if that makes our life easier.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see how this works with some examples!&lt;&#x2F;p&gt;
&lt;p&gt;We will have to generate &lt;em&gt;type definitions&lt;&#x2F;em&gt; so we can define a Scala &lt;em&gt;enum&lt;&#x2F;em&gt; describing what kind of type definitions we want to generate:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;enum RustDef:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;TypeAlias(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;typ&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derives&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;Newtype(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;typ&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derives&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;Struct(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;fields&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Field&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derives&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;isPublic&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Boolean&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;Enum(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;cases&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derives&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;Impl(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tpe&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;functions&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;ImplTrait(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;implemented&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;forType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;functions&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;Function(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Parameter&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;returnType&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;body&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;isPublic&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Boolean&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can make this as convenient to use as we want, for example adding constructors like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;fields&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Field&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Name&lt;&#x2F;code&gt; is an opaque string type with extension methods to convert between various cases like pascal case, snake case, etc. &lt;code&gt;RustType&lt;&#x2F;code&gt; is a similar &lt;em&gt;enum&lt;&#x2F;em&gt; to &lt;code&gt;RustDef&lt;&#x2F;code&gt;, containing all the different type descriptions we will have to use. But it is definitely not how a proper Rust parser would define what a type is - for example we can have a &lt;code&gt;RustType.Option&lt;&#x2F;code&gt; as a shortcut for wrapping a Rust type in Rust&#x27;s own option type, just because it makes our code generator simpler to write.&lt;&#x2F;p&gt;
&lt;p&gt;So once we have this model (which in practice evolves together with the code generator, usually starting with a few simple case classes) we can use &lt;strong&gt;ZIO Parser&lt;&#x2F;strong&gt;&#x27;s printer feature to define composable elements constructing Rust source code.&lt;&#x2F;p&gt;
&lt;p&gt;We start by defining a module and a type alias for our printer:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; Rust&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Rust[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Printer&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Char&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and then just define building blocks - what these building blocks are depends completely on us, and the only thing it affects is how well you can compose them. Having very small building blocks may reduce the readability of the code generator, but using too large chunks reduces their composability and makes it harder to change or refactor.&lt;&#x2F;p&gt;
&lt;p&gt;We can define some short aliases for often used characters or string fragments:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;gt&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Rust&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Any&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Printer.print(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;&amp;#39;&amp;gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;lt&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Rust&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Any&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Printer.print(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;bracketed&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;](&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;inner&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Rust&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;]): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Rust&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  lt ~ inner ~ gt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and we have to define &lt;code&gt;Rust&lt;&#x2F;code&gt; printers for each of our model types. For example for the &lt;code&gt;RustType&lt;&#x2F;code&gt; enum it could be something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Rust&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Printer.byValue:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;RustType.Primitive(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;)             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; str(name)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;RustType.Option(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;inner&lt;&#x2F;span&gt;&lt;span&gt;)               &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; typename(RustType.Primitive(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Option&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)) ~ bracketed(typename(inner))
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;RustType.Vec(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;inner&lt;&#x2F;span&gt;&lt;span&gt;)                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; typename(RustType.Primitive(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Vec&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)) ~ bracketed(typename(inner))
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;RustType.SelectFromModule(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;path&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;typ&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Printer.anyString.repeatWithSep(dcolon)(path) ~ dcolon ~ typename(typ)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;RustType.Parametric(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    str(name) ~ bracketed(typename.repeatWithSep(comma)(params))
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can see that &lt;code&gt;typename&lt;&#x2F;code&gt; uses itself to recursively generate inner type names, for example when generating type parameters of tuple members. It also demonstrates that we can extract patterns such as &lt;code&gt;bracketed&lt;&#x2F;code&gt; to simplify our printer definitions and eliminate repetition.&lt;&#x2F;p&gt;
&lt;p&gt;Another nice feature we get by using a general purpose printer library like ZIO Parser is that we can use the built-in combinators to get printers for new types. One example is the sequential composition of printers. For example the following fragment:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;p &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;pub &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) ~ name ~ str(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) ~ typename
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;would have the type &lt;code&gt;Rust[(Name, RustType)]&lt;&#x2F;code&gt; and we can even make that a printer of a case class like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; PublicField&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;typ&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;p2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; p.from[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;PublicField&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where &lt;code&gt;p2&lt;&#x2F;code&gt; will have the type &lt;code&gt;Rust[PublicField&lt;&#x2F;code&gt;].&lt;&#x2F;p&gt;
&lt;p&gt;Another very useful combinator is &lt;strong&gt;repetition&lt;&#x2F;strong&gt;. For example if we have a printer for an enum&#x27;s case:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;enumCase&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Rust&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;we can simply use one of the repetition combinators to make a printer for a &lt;em&gt;list of enum cases&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;enumCases&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Rust&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;]] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enumCase.*
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or as in the &lt;code&gt;typename&lt;&#x2F;code&gt; example above:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;typename.repeatWithSep(comma)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;to have a &lt;code&gt;Rust[Chunk[RustType]]&lt;&#x2F;code&gt; that inserts a comma between each element when printed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;inspecting-the-scala-types&quot;&gt;Inspecting the Scala types&lt;&#x2F;h2&gt;
&lt;p&gt;As we have seen the &lt;em&gt;endpoint DSL&lt;&#x2F;em&gt; uses &lt;strong&gt;ZIO Schema&lt;&#x2F;strong&gt; to capture information about the types being used in the endpoints (usually as request or response bodies, serialized into JSON). We can use the same information to generate &lt;strong&gt;Rust types&lt;&#x2F;strong&gt; from our Scala types!&lt;&#x2F;p&gt;
&lt;p&gt;The core data type defined by the ZIO Schema library is called &lt;code&gt;Schema&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;sealed trait&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Schema describes the structure of a Scala type &lt;code&gt;A&lt;&#x2F;code&gt; in a way we can inspect it from regular Scala code. Let&#x27;s imagine we have &lt;code&gt;Schema[WorkerMetadata]&lt;&#x2F;code&gt; coming from our endpoint definition and we have to generate an equivalent Rust &lt;code&gt;struct&lt;&#x2F;code&gt; with the same field names and field types.&lt;&#x2F;p&gt;
&lt;p&gt;The first thing to notice is that type definitions are recursive. Unless &lt;code&gt;WorkerMetadata&lt;&#x2F;code&gt; only contains fields of &lt;em&gt;primitive types&lt;&#x2F;em&gt; such as integer or string, our job does not end with generating a single Rust struct - we need to recursively generate all the other types &lt;code&gt;WorkerMetadata&lt;&#x2F;code&gt; is depending on! To capture this fact let&#x27;s introduce a type that represents everything we have to extract from a single (or a set of) schemas in order to generate Rust types from them:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; RustModel&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;typeRefs&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;], 
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;definitions&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;], 
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;requiredCrates&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Crate&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have &lt;code&gt;typeRefs&lt;&#x2F;code&gt; which associates a &lt;code&gt;RustType&lt;&#x2F;code&gt; with a schema so we can use it in future steps of our code generator to refer to a generated type in our Rust codebase. We have a list of &lt;code&gt;RustDef&lt;&#x2F;code&gt; values which are the generated type definitions, ready to be printed with out &lt;code&gt;Rust&lt;&#x2F;code&gt; pretty printer. And finally we can also gather a set of required extra rust &lt;em&gt;crates&lt;&#x2F;em&gt;, because some of the types considered &lt;em&gt;primitive types&lt;&#x2F;em&gt; by ZIO Schema are not having proper representations in the Rust standard library, only in external crates. Examples are UUIDs and various date&#x2F;time types.&lt;&#x2F;p&gt;
&lt;p&gt;So our job now is to write a function of&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;fromSchemas&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schemas&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Seq&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;]]): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Either&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustModel&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Either&lt;&#x2F;code&gt; result type is used to indicate failures. Even if we write a transformation that can produce from any &lt;code&gt;Schema&lt;&#x2F;code&gt; a proper &lt;code&gt;RustModel&lt;&#x2F;code&gt;, we always have to have an error result when working with ZIO Schema because it has an explicit failure case called &lt;code&gt;Schema.Fail&lt;&#x2F;code&gt;. If we process a schema and end up with a &lt;code&gt;Fail&lt;&#x2F;code&gt; node, we can&#x27;t do anything else than fail our code generator.&lt;&#x2F;p&gt;
&lt;p&gt;There are many important details to consider when implementing this function, but let&#x27;s just see first what the actual &lt;code&gt;Schema&lt;&#x2F;code&gt; type looks like. When we have a value of &lt;code&gt;Schema[?]&lt;&#x2F;code&gt; we can pattern match on it and implement the following cases:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Schema.Primitive&lt;&#x2F;code&gt; describes a primitive type - there are a lot of primitive types defined by ZIO Schema&#x27;s &lt;code&gt;StandardType&lt;&#x2F;code&gt; enum&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Enum&lt;&#x2F;code&gt; describes a type with multiple cases (a &lt;em&gt;sum type&lt;&#x2F;em&gt;) such as a &lt;code&gt;sealed trait&lt;&#x2F;code&gt; or &lt;code&gt;enum&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Record&lt;&#x2F;code&gt; describes a type with multiple fields (a &lt;em&gt;product type&lt;&#x2F;em&gt;) such as a &lt;code&gt;case class&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Map&lt;&#x2F;code&gt; represents a &lt;em&gt;map&lt;&#x2F;em&gt; with a key and value type&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Sequence&lt;&#x2F;code&gt; represents a &lt;em&gt;sequence&lt;&#x2F;em&gt; of items of a given element type&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Set&lt;&#x2F;code&gt; is a &lt;em&gt;set&lt;&#x2F;em&gt; of items of a given element type&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Optional&lt;&#x2F;code&gt; represents an &lt;em&gt;optional&lt;&#x2F;em&gt; type (like an &lt;code&gt;Option[T]&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Either&lt;&#x2F;code&gt; is a special case of sum types representing either one or the other type (like an &lt;code&gt;Either[A, B]&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Lazy&lt;&#x2F;code&gt; is used to safely encode recursive types, it contains a function that evaluates into an inner &lt;code&gt;Schema&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Dynamic&lt;&#x2F;code&gt; represents a type that is dynamic - like a &lt;code&gt;JSON&lt;&#x2F;code&gt; value&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Transform&lt;&#x2F;code&gt; assigns a transformation function that converts a &lt;em&gt;value&lt;&#x2F;em&gt; of a type represented by the schema to a value of some other type. As we have no way to inspect these functions (they are compiled Scala functions) in our code generator, this is not very interesting for us now.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Schema.Fail&lt;&#x2F;code&gt; as already mentioned represents a failure in describing the data type&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;When traversing a &lt;code&gt;Schema&lt;&#x2F;code&gt; recursively (for any reason), it is important to keep in mind that it &lt;em&gt;can&lt;&#x2F;em&gt; encode recursive types! A simple example is a binary tree:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; Tree&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;](&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;label&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;left&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Tree&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;right&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Tree&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can construct a &lt;code&gt;Schema[Tree[A]]&lt;&#x2F;code&gt; if we have a &lt;code&gt;Schema[A]&lt;&#x2F;code&gt;. This will be something like (pseudo-code):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;lazy val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tree&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Tree&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  Schema.Record(
&lt;&#x2F;span&gt;&lt;span&gt;    Field(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;label&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, Schema[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;]),
&lt;&#x2F;span&gt;&lt;span&gt;    Field(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;left&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, Schema.Optional(Schema.Lazy(() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; tree))),
&lt;&#x2F;span&gt;&lt;span&gt;    Field(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;right&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, Schema.Optional(Schema.Lazy(() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; tree)))
&lt;&#x2F;span&gt;&lt;span&gt;  )
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we are not prepared for recursive types we can easily get into an endless loop (or stack overflow) when processing these schemas.&lt;&#x2F;p&gt;
&lt;p&gt;This is just one example of things to keep track of while converting a schema into a set of Rust definitions. If fields refer to the self type we want to use &lt;code&gt;Box&lt;&#x2F;code&gt; so to put them on the heap. We also need to keep track of if everything within a generated type derives &lt;code&gt;Ord&lt;&#x2F;code&gt; and &lt;code&gt;Hash&lt;&#x2F;code&gt; - and if yes, we should derive an instance for the same type classes for our generated type as well.&lt;&#x2F;p&gt;
&lt;p&gt;My preferred way to implement such recursive stateful transformation functions is to use &lt;strong&gt;ZIO Prelude&lt;&#x2F;strong&gt;&#x27;s &lt;code&gt;ZPure&lt;&#x2F;code&gt; type. It&#x27;s type definition looks a little scary:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;sealed trait&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; ZPure&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;W&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;S1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;S2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;R&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;E&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;ZPure&lt;&#x2F;code&gt; describes a &lt;em&gt;purely functional computation&lt;&#x2F;em&gt; which can:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Emit log entries of type &lt;code&gt;W&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Works with an inital state of type &lt;code&gt;S1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Results in a final state of type &lt;code&gt;S2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Has access to some context of type &lt;code&gt;R&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Can fail with a value of &lt;code&gt;E&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Or succeed with a value of &lt;code&gt;A&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In this case we need the state, failure and result types only, but we could also take advantage of &lt;code&gt;W&lt;&#x2F;code&gt; to log debug information within our schema transformation function.&lt;&#x2F;p&gt;
&lt;p&gt;To make it easier to work with &lt;code&gt;ZPure&lt;&#x2F;code&gt; we can introduce a &lt;em&gt;type alias&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Fx[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;ZPure&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Nothing&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Any&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where &lt;code&gt;State&lt;&#x2F;code&gt; is our own &lt;em&gt;case class&lt;&#x2F;em&gt; containing everything we need:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; State&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;typeRefs&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;definitions&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustDef&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;requiredCrates&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Crate&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;processed&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;]],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;stack&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;]],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;nameTypeIdMap&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Set&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;TypeId&lt;&#x2F;span&gt;&lt;span&gt;]],
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schemaCaps&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Map&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Capabilities&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We won&#x27;t get into the details of the state type here, but I&#x27;m showing some fragments to get a feeling of working with &lt;code&gt;ZPure&lt;&#x2F;code&gt; values.&lt;&#x2F;p&gt;
&lt;p&gt;Some helper functions to manipulate the state can make our code much easier to read:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;private def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;getState&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;ZPure.get[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;private def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;updateState&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State&lt;&#x2F;span&gt;&lt;span&gt;): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Unit&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;ZPure.update[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;State&lt;&#x2F;span&gt;&lt;span&gt;](f)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example we can use &lt;code&gt;updateState&lt;&#x2F;code&gt;  to manipulate the &lt;code&gt;stack&lt;&#x2F;code&gt; field of the state around another computation - before running it, we add a schema to the stack, after that we remove it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;private def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;stacked&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;R&lt;&#x2F;span&gt;&lt;span&gt;](&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schema&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;])(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;R&lt;&#x2F;span&gt;&lt;span&gt;]): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;R&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  updateState(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; s.copy(stack &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; s.stack :+ schema))
&lt;&#x2F;span&gt;&lt;span&gt;    .zipRight(f)
&lt;&#x2F;span&gt;&lt;span&gt;    .zipLeft(updateState(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; s.copy(stack &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; s.stack.dropRight(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows us to decide whether we have to wrap a generated field&#x27;s type in &lt;code&gt;Box&lt;&#x2F;code&gt; in the rust code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;private def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;boxIfNeeded&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;](&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schema&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;]): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for
&lt;&#x2F;span&gt;&lt;span&gt;    state &amp;lt;- getState
&lt;&#x2F;span&gt;&lt;span&gt;    backRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; state.stack.contains(schema)
&lt;&#x2F;span&gt;&lt;span&gt;    rustType &amp;lt;- getRustType(schema)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;yield if&lt;&#x2F;span&gt;&lt;span&gt; backRef then RustType.box(rustType) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt; rustType
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By looking into &lt;code&gt;state.stack&lt;&#x2F;code&gt; we can decide if we are dealing with a recursive type or not, and make our decision regarding boxing the field.&lt;&#x2F;p&gt;
&lt;p&gt;Another example is to guard against infinite recursion when traversing the schema definition, as I explained before. We can define a helper function that just keeps track of all the visited schemas and shortcuts the computation if something has already been seen:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;private def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;ifNotProcessed&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;](&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;])(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Unit&lt;&#x2F;span&gt;&lt;span&gt;]): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Unit&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  getState.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;flatMap&lt;&#x2F;span&gt;&lt;span&gt;: state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; state.processed.contains(value) then ZPure.unit
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt; updateState(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;.copy(processed &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; state.processed + value)).zipRight(f)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Putting all these smaller combinators together we have an easy-to-read core recursive transformation function for converting the schema:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;private def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;process&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;](&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schema&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span&gt;]): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Fx&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Unit&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  ifNotProcessed(schema):
&lt;&#x2F;span&gt;&lt;span&gt;    getRustType(schema).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;flatMap&lt;&#x2F;span&gt;&lt;span&gt;: typeRef &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;      stacked(schema):
&lt;&#x2F;span&gt;&lt;span&gt;        schema &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the end to run a &lt;code&gt;Fx[A]&lt;&#x2F;code&gt; all we need to do is to provide an initial state:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;processSchema.provideState(State.empty).runEither
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;inspecting-the-endpoints&quot;&gt;Inspecting the endpoints&lt;&#x2F;h2&gt;
&lt;p&gt;We generated Rust code for all our types but we still need to generate HTTP clients. The basic idea is the same as what we have seen so far:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Traversing the &lt;code&gt;Endpoint&lt;&#x2F;code&gt; data structure for each endpoint we have&lt;&#x2F;li&gt;
&lt;li&gt;Generate some intermediate model&lt;&#x2F;li&gt;
&lt;li&gt;Pretty print this model to Rust code&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The conversion once again is recursive, can fail, and requires keeping track of various things, so we can use &lt;code&gt;ZPure&lt;&#x2F;code&gt; to implement it. Not repeating the same details, in this section we will talk about what exactly the endpoint descriptions look like and what we have be aware of when trying to process them.&lt;&#x2F;p&gt;
&lt;p&gt;The first problem to solve is that currently ZIO Http does not have a concept of multiple endpoints. We are not composing &lt;code&gt;Endpoint&lt;&#x2F;code&gt; values into an API, instead we first &lt;strong&gt;implement&lt;&#x2F;strong&gt; them to get &lt;code&gt;Route&lt;&#x2F;code&gt; values and compose those. We can no longer inspect the endpoint definitions from the composed routes, so unfortunately we have to repeat ourselves and somehow compose our set of endpoints for our code generator.&lt;&#x2F;p&gt;
&lt;p&gt;First we can define a &lt;code&gt;RustEndpoint&lt;&#x2F;code&gt; class, similar to the &lt;code&gt;RustModel&lt;&#x2F;code&gt; earlier, containing all the necessary information to generate Rust code for a &lt;strong&gt;single endpoint&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can construct it with a function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; RustEndpoint&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;fromEndpoint&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;PathInput&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Input&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Err&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Middleware &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;lt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;EndpointMiddleware&lt;&#x2F;span&gt;&lt;span&gt;](
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;endpoint&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Endpoint&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;PathInput&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Input&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Err&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Middleware&lt;&#x2F;span&gt;&lt;span&gt;],
&lt;&#x2F;span&gt;&lt;span&gt;  ): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Either&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustEndpoint&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The second thing to notice: endpoints do not have a name! If we look back to our initial example of &lt;code&gt;getWorkerMetadata&lt;&#x2F;code&gt;, it did not have a unique name except the Scala value it was assigned to. But we can&#x27;t observe that in our code generator (without writing a macro) so here we have chosen to just get a name as a string next to the definition.&lt;&#x2F;p&gt;
&lt;p&gt;Then we can define a &lt;strong&gt;collection&lt;&#x2F;strong&gt; of &lt;code&gt;RustEndpoint&lt;&#x2F;code&gt;s:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; RustEndpoints&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;originalEndpoints&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustEndpoint&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and define a &lt;code&gt;++&lt;&#x2F;code&gt; operator between &lt;code&gt;RustEndpoint&lt;&#x2F;code&gt; and &lt;code&gt;RustEndpoints&lt;&#x2F;code&gt;. In the end we can use these to define APIs like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for
&lt;&#x2F;span&gt;&lt;span&gt;      getDefaultProject &amp;lt;- fromEndpoint(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;getDefaultProject&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, ProjectEndpoints.getDefaultProject)
&lt;&#x2F;span&gt;&lt;span&gt;      getProjects       &amp;lt;- fromEndpoint(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;getProjects&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, ProjectEndpoints.getProjects)
&lt;&#x2F;span&gt;&lt;span&gt;      postProject       &amp;lt;- fromEndpoint(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;postProject&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, ProjectEndpoints.postProject)
&lt;&#x2F;span&gt;&lt;span&gt;      getProject        &amp;lt;- fromEndpoint(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;getProject&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, ProjectEndpoints.getProject)
&lt;&#x2F;span&gt;&lt;span&gt;      deleteProject     &amp;lt;- fromEndpoint(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;deleteProject&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, ProjectEndpoints.deleteProject)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;yield &lt;&#x2F;span&gt;&lt;span&gt;(getDefaultProject ++ getProjects ++ postProject ++ getProject ++ deleteProject).named(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Project&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The collection of endpoints also have a name (&lt;code&gt;&quot;Project&quot;&lt;&#x2F;code&gt;). In the code generator we can use these to have a separate &lt;strong&gt;client&lt;&#x2F;strong&gt; (trait and implementation) for each of these groups of endpoints.&lt;&#x2F;p&gt;
&lt;p&gt;When processing a single endpoint, we need to process the following parts of data:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Inputs (&lt;code&gt;endpoint.input&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;Outputs (&lt;code&gt;endpoint.output&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;Errors (&lt;code&gt;endpoint.error&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Everything we need is encoded in one of these three fields of an endpoint, and all three are built on the same abstraction called &lt;code&gt;HttpCodec&lt;&#x2F;code&gt;. Still there is a significant difference in what we want to do with inputs versus what we want to do with outputs and errors, so we can write two different traversals for gathering all the necessary information from them.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;inputs&quot;&gt;Inputs&lt;&#x2F;h3&gt;
&lt;p&gt;When gathering information from the inputs, we are going to run into the following cases:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Combine&lt;&#x2F;code&gt; means we have two different inputs; we need both, so we have to process both inner codecs sequentially, both extending our conversion function&#x27;s state.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Content&lt;&#x2F;code&gt; describes a &lt;strong&gt;request body&lt;&#x2F;strong&gt;. Here we have a &lt;code&gt;Schema&lt;&#x2F;code&gt; of our request body type and we can use the previously generated schema-to-rust type mapping to know how to refer to the generated rust type in our client code. It is important that in case there are &lt;strong&gt;multiple content codecs&lt;&#x2F;strong&gt;, that means the endpoint receives a &lt;code&gt;multipart&#x2F;form-data&lt;&#x2F;code&gt; body, while if there is only one codec, it accepts an &lt;code&gt;application&#x2F;json&lt;&#x2F;code&gt; representation of that.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.ContentStream&lt;&#x2F;code&gt; represents a body containing a stream of a given element type. We can model this as just a &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;&#x2F;code&gt; in the Rust side, but there is one special case here - if the element is a &lt;code&gt;Byte&lt;&#x2F;code&gt;, ZIO Http expects a simple byte stream of type &lt;code&gt;application&#x2F;octet-stream&lt;&#x2F;code&gt; instead of a JSON-encoded array of bytes.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Fallback&lt;&#x2F;code&gt; this represents the case when we should either use the first codec, &lt;em&gt;or&lt;&#x2F;em&gt; the second. A special case is when the &lt;code&gt;right&lt;&#x2F;code&gt; value of &lt;code&gt;Fallback&lt;&#x2F;code&gt; is &lt;code&gt;HttpCodec.Empty&lt;&#x2F;code&gt;. This is how ZIO Http represents optional inputs! We have to handle this specially in our code generator to mark some of the input parameters of the generated API as optional parameters. We don&#x27;t support currently the other cases (when &lt;code&gt;right&lt;&#x2F;code&gt; is not empty) as it is not frequently used and was not required for the &lt;em&gt;Golem API&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Header&lt;&#x2F;code&gt; means we need to send a &lt;em&gt;header&lt;&#x2F;em&gt; in the request, which can be a static (value described by the endpoint) or dynamic one (where we need to add an extra parameter to the generated function to get a value of the header). There are a couple of different primitive types supported for the value, such as string, numbers, UUIDs.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Method&lt;&#x2F;code&gt; defines the method to be used for calling the endpoint&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Path&lt;&#x2F;code&gt; describes the request path, which consists of a sequence of static and dynamic segments - for the dynamic segments the generated API need to have exposed function parameters of the appropriate type&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Query&lt;&#x2F;code&gt; similar to the header codec defines query parameters to be sent&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.TransformOrFail&lt;&#x2F;code&gt; transforms a value with a Scala function - the same case as with &lt;code&gt;Schema.Transform&lt;&#x2F;code&gt;. We cannot use the Scala function in our code generator so we just need to ignore this and go to the inner codec.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;HttpCodec.Annotated&lt;&#x2F;code&gt; attaches additional information to the codecs that we are currently not using, but it could be used to get documentation strings and include them in the generated code as comments, for example.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;outputs&quot;&gt;Outputs&lt;&#x2F;h3&gt;
&lt;p&gt;For outputs we are dealing with the same &lt;code&gt;HttpCodec&lt;&#x2F;code&gt; type but there are some significant differences:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;We can ignore &lt;code&gt;Path&lt;&#x2F;code&gt;, &lt;code&gt;Method&lt;&#x2F;code&gt;, &lt;code&gt;Query&lt;&#x2F;code&gt; as they have no meaning for outputs&lt;&#x2F;li&gt;
&lt;li&gt;We could look for &lt;em&gt;output headers&lt;&#x2F;em&gt; but currently we ignore them&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Fallback&lt;&#x2F;code&gt; on the other hand needs to be properly handled for outputs (errors, especially) because this is how the different error responses are encoded.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Status&lt;&#x2F;code&gt; is combined with &lt;code&gt;Content&lt;&#x2F;code&gt; in these &lt;code&gt;Fallback&lt;&#x2F;code&gt; nodes to describe cases. This complicates the code generator because we need to record &quot;possible outputs&quot; which are only added as real output once we are sure we will not get any other piece of information for them.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;To understand the error fallback handling better, let&#x27;s take a look at how it is defined in one of Golem&#x27;s endpoint groups:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;errorCodec&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;HttpCodec&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;HttpCodecType&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Status &lt;&#x2F;span&gt;&lt;span&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;HttpCodecType&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Content&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitsEndpointError&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  HttpCodec.enumeration[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitsEndpointError&lt;&#x2F;span&gt;&lt;span&gt;](
&lt;&#x2F;span&gt;&lt;span&gt;    HttpCodec.error[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitsEndpointError&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Unauthorized&lt;&#x2F;span&gt;&lt;span&gt;](Status.Unauthorized),
&lt;&#x2F;span&gt;&lt;span&gt;    HttpCodec.error[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitsEndpointError&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;ArgValidationError&lt;&#x2F;span&gt;&lt;span&gt;](Status.BadRequest),
&lt;&#x2F;span&gt;&lt;span&gt;    HttpCodec.error[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitsEndpointError&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitExceeded&lt;&#x2F;span&gt;&lt;span&gt;](Status.Forbidden),
&lt;&#x2F;span&gt;&lt;span&gt;    HttpCodec.error[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitsEndpointError&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;InternalError&lt;&#x2F;span&gt;&lt;span&gt;](Status.InternalServerError)
&lt;&#x2F;span&gt;&lt;span&gt;  )
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This leads to a series of nested &lt;code&gt;HttpCodec.Fallback&lt;&#x2F;code&gt;, &lt;code&gt;HttpCodec.Combine&lt;&#x2F;code&gt;, &lt;code&gt;HttpCodec.Status&lt;&#x2F;code&gt; and &lt;code&gt;HttpCodec.Content&lt;&#x2F;code&gt; nodes. When processing them we first add values of possible outputs:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; PossibleOutput&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tpe&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustType&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;status&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Option&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Status&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;isError&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Boolean&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schema&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Schema&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and once we have fully processed one branch of a &lt;code&gt;Fallback&lt;&#x2F;code&gt;, we finalize these possible outputs and make them real outputs. The way these different error cases are mapped into different case classes of a a single error type (&lt;code&gt;LimitsEndpointError&lt;&#x2F;code&gt;) also complicates things. When we reach a &lt;code&gt;HttpCodec.Content&lt;&#x2F;code&gt; referencing  &lt;code&gt;Schema[LimitsEndpointError.LimitExceeded&lt;&#x2F;code&gt;] for example, all we see is a &lt;code&gt;Schema.Record&lt;&#x2F;code&gt; - and not the parent enum! For this reason in the code generator we are explicitly defining the error ADT type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;fromEndpoint &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;RustEndpoint.withKnownErrorAdt[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;LimitsEndpointError&lt;&#x2F;span&gt;&lt;span&gt;].zio
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and we detect if all cases are subtypes of this error ADT and generate the client code according to that.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-rust-client&quot;&gt;The Rust client&lt;&#x2F;h3&gt;
&lt;p&gt;It is time to take a look at what the output of all this looks like. In this section we will examine some parts of the generated Rust code.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take a look at the &lt;strong&gt;Projects API&lt;&#x2F;strong&gt;. We have generated a &lt;code&gt;trait&lt;&#x2F;code&gt; for all the endpoints belonging to it:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Project {
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_default_project&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authorization&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;crate::model::Project, ProjectError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_projects&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;project_name&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authorization&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Vec&amp;lt;crate::model::Project&amp;gt;, ProjectError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;post_project&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;field0&lt;&#x2F;span&gt;&lt;span&gt;: crate::model::ProjectDataRequest, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authorization&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;crate::model::Project, ProjectError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_project&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;project_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authorization&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;crate::model::Project, ProjectError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;delete_project&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;project_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authorization&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;(), ProjectError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is quite close to our original goal! One significant difference is that some type information is lost: &lt;code&gt;project_id&lt;&#x2F;code&gt; was &lt;code&gt;ProjectId&lt;&#x2F;code&gt; in Scala, and &lt;code&gt;authorization&lt;&#x2F;code&gt; was &lt;code&gt;TokenSecret&lt;&#x2F;code&gt; etc. Unfortunately with the current version of ZIO Schema these newtypes (or Scala 3 opaque types) are represented as primitive types transformed by a function. As explained earlier, we can&#x27;t inspect the transformation function so all we can do is to use the underlying primitive type&#x27;s schema here. This can be solved by introducing the concept of newtypes into ZIO Schema.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;ProjectError&lt;&#x2F;code&gt; is a client specific generated &lt;code&gt;enum&lt;&#x2F;code&gt; which can represent a mix of internal errors (such as not being able to call the endpoint) as well as the endpoint-specific domain errors:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;ProjectError {
&lt;&#x2F;span&gt;&lt;span&gt;    RequestFailure(reqwest::Error),
&lt;&#x2F;span&gt;&lt;span&gt;    InvalidHeaderValue(reqwest::header::InvalidHeaderValue),
&lt;&#x2F;span&gt;&lt;span&gt;    UnexpectedStatus(reqwest::StatusCode),
&lt;&#x2F;span&gt;&lt;span&gt;    Status404 {
&lt;&#x2F;span&gt;&lt;span&gt;        message: String,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    Status403 {
&lt;&#x2F;span&gt;&lt;span&gt;        error: String,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    Status400 {
&lt;&#x2F;span&gt;&lt;span&gt;        errors: Vec&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    Status500 {
&lt;&#x2F;span&gt;&lt;span&gt;        error: String,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    Status401 {
&lt;&#x2F;span&gt;&lt;span&gt;        message: String,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So why are these per-status-code error types inlined here instead of generating the error ADT as a Rust &lt;code&gt;enum&lt;&#x2F;code&gt; and using that? The reason is a difference between Scala and Rust: we have a single error ADT in Scala and we can still use its &lt;em&gt;cases&lt;&#x2F;em&gt; directly in the endpoint definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;sealed trait&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; ProjectEndpointError
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; ProjectEndpointError {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; ArgValidation(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;errors&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;: Chunk[String]) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;ProjectEndpointError
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;HttpCodec.error[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;ProjectEndpointError&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;ArgValidation&lt;&#x2F;span&gt;&lt;span&gt;](Status.BadRequest),
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We &lt;em&gt;do&lt;&#x2F;em&gt; generate the corresponding &lt;code&gt;ProjectEndpointError&lt;&#x2F;code&gt; enum in Rust:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, serde::Serialize, serde::Deserialize)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;ProjectEndpointError {
&lt;&#x2F;span&gt;&lt;span&gt;    ArgValidation {
&lt;&#x2F;span&gt;&lt;span&gt;        errors: Vec&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;but we cannot use &lt;code&gt;ProjectEndpointError::ArgValidation&lt;&#x2F;code&gt; as a type in the above &lt;code&gt;ProjectError&lt;&#x2F;code&gt; enum. And we cannot safely do something like &lt;code&gt;Either[ClientError, ProjectEndpointError]&lt;&#x2F;code&gt; because in the endpoint DSL we just have a sequence of status code - error case pairs. There is no guarantee that one enum case is only used once in that mapping, or that every case is used at least once. For this reason the mapping from &lt;code&gt;ProjectError&lt;&#x2F;code&gt; to &lt;code&gt;ProjectEndpointError&lt;&#x2F;code&gt; is generated as a transformation function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;ProjectError {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;to_project_endpoint_error&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;crate::model::ProjectEndpointError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      ProjectError::Status400 { errors } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;::model::ProjectEndpointError::ArgValidation { errors: errors.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;() }), 
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For each client trait we also generate a &lt;strong&gt;live implementation&lt;&#x2F;strong&gt;, represented by a struct containing configuration for the client:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Clone, Debug)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ProjectLive {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;base_url&lt;&#x2F;span&gt;&lt;span&gt;: reqwest::Url,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;allow_insecure&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And the implementation of the client trait for these live structs are just using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;reqwest&#x2F;latest&#x2F;reqwest&#x2F;&quot;&gt;&lt;code&gt;reqwest&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; (a HTTP client library for Rust) to construct the request from the input parameters exactly the way the endpoint definition described:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_project&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;project_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;authorization&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Project, ProjectError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; url &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.base_url.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  url.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;set_path&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;v1&#x2F;projects&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{project_id}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; headers &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;reqwest::header::HeaderMap::new();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;      
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; builder &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;reqwest::Client::builder();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; client &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; builder.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; client
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(url)
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;headers&lt;&#x2F;span&gt;&lt;span&gt;(headers)
&lt;&#x2F;span&gt;&lt;span&gt;    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    .await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; result.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;status&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;as_u16&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;200 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; body &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; result.json::&amp;lt;crate::model::Project&amp;gt;().await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;      Ok(body)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;404 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; body &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; result.json::&amp;lt;ProjectEndpointErrorNotFoundPayload&amp;gt;().await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;      Err(ProjectError::Status404 { message: body.message })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;putting-it-all-together&quot;&gt;Putting it all together&lt;&#x2F;h2&gt;
&lt;p&gt;At this point we have seen how &lt;em&gt;ZIO Http&lt;&#x2F;em&gt; describes endpoints, how &lt;em&gt;ZIO Schema&lt;&#x2F;em&gt; encodes Scala types, how we can use &lt;em&gt;ZIO Parser&lt;&#x2F;em&gt; to have composable printers and how &lt;em&gt;ZIO Prelude&lt;&#x2F;em&gt; can help with working with state in a purely functional code. The only thing remaining is to wire everything together and define an easy to use function that, when executed, creates all the required &lt;em&gt;Rust files&lt;&#x2F;em&gt; ready to be compiled.&lt;&#x2F;p&gt;
&lt;p&gt;We can create a class for this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;final case class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt; ClientCrateGenerator&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;version&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;homepage&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;endpoints&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Chunk&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RustEndpoints&lt;&#x2F;span&gt;&lt;span&gt;]):
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here &lt;code&gt;endpoints&lt;&#x2F;code&gt; is a collection of a &lt;strong&gt;group of endpoints&lt;&#x2F;strong&gt;, as it was shown earlier. So first you can use &lt;code&gt;RustEndpoint.fromEither&lt;&#x2F;code&gt; and &lt;code&gt;++&lt;&#x2F;code&gt; to create a &lt;code&gt;RustEndpoints&lt;&#x2F;code&gt; value for each API you have, and then generate a client for all of those in one run with this class.&lt;&#x2F;p&gt;
&lt;p&gt;The first thing to do is collect &lt;em&gt;all&lt;&#x2F;em&gt; the referenced &lt;code&gt;Schema&lt;&#x2F;code&gt; from all the endpoints:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;private val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;allSchemas &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; endpoints.map(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;.endpoints.toSet.flatMap(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;.referredSchemas)).reduce(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; union &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we define a ZIO function (it is an effectful function, manipulating the filesystem!) to generate the files:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;scala&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-scala &quot;&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;generate&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;targetDirectory&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Path&lt;&#x2F;span&gt;&lt;span&gt;): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;ZIO&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Any&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;Throwable&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Unit&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for
&lt;&#x2F;span&gt;&lt;span&gt;    clientModel &amp;lt;- ZIO.fromEither(RustModel.fromSchemas(allSchemas.toSeq))
&lt;&#x2F;span&gt;&lt;span&gt;                      .mapError(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;err &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RuntimeException&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Failed to generate client model: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;$err&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    cargoFile &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; targetDirectory &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Cargo.toml&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    srcDir &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; targetDirectory &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;src&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    libFile &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; srcDir &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;lib.rs&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    modelFile &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; srcDir &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;model.rs&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    requiredCrates &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; clientModel.requiredCrates union endpoints.map(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;.requiredCrates).reduce(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; union &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; &amp;lt;- Files.createDirectories(targetDirectory)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; &amp;lt;- Files.createDirectories(srcDir)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; &amp;lt;- writeCargo(cargoFile, requiredCrates)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; &amp;lt;- writeLib(libFile)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; &amp;lt;- writeModel(modelFile, clientModel.definitions)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; &amp;lt;- ZIO.foreachDiscard(endpoints): endpoints &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;clientFile &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; srcDir &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;${&lt;&#x2F;span&gt;&lt;span&gt;endpoints.name.toSnakeCase&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;}.rs&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;           writeClient(clientFile, endpoints)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;yield &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The steps are straightforward:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Create a &lt;code&gt;RustModel&lt;&#x2F;code&gt; using all the collected &lt;code&gt;Schema[?]&lt;&#x2F;code&gt; values&lt;&#x2F;li&gt;
&lt;li&gt;Create all the required directories&lt;&#x2F;li&gt;
&lt;li&gt;Write a &lt;em&gt;cargo file&lt;&#x2F;em&gt; - having all the dependencies and other metadata required to compile the Rust project&lt;&#x2F;li&gt;
&lt;li&gt;Write a &lt;em&gt;lib file&lt;&#x2F;em&gt; - this is just a series of &lt;code&gt;pub mod xyz;&lt;&#x2F;code&gt; lines, defining the generated modules which are put in different fiels&lt;&#x2F;li&gt;
&lt;li&gt;Write all the generated Rust types into a &lt;code&gt;model.rs&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;For each endpoint group create a &lt;code&gt;xyz.rs&lt;&#x2F;code&gt; module containing the client trait and implementation&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For working with the file system - creating directories, writing data into files, we can use the [&lt;a href=&quot;https:&#x2F;&#x2F;zio.dev&#x2F;zio-nio&#x2F;&quot;&gt;ZIO NIO&lt;&#x2F;a&gt;] library providing ZIO wrapprers for all these functionalities.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;&#x2F;h3&gt;
&lt;p&gt;Finally, some links:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;code generator&lt;&#x2F;strong&gt; is open source and available at https:&#x2F;&#x2F;github.com&#x2F;vigoo&#x2F;zio-http-rust - the code and the repository itself is not documented at the moment, except by this blog post.&lt;&#x2F;li&gt;
&lt;li&gt;The generated &lt;strong&gt;Golem client for Rust&lt;&#x2F;strong&gt; is published as a crate to https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;golem-client&lt;&#x2F;li&gt;
&lt;li&gt;The new &lt;strong&gt;Golem CLI&lt;&#x2F;strong&gt;, using the generated client, is also open sourced and can be found at https:&#x2F;&#x2F;github.com&#x2F;golemcloud&#x2F;golem-cli&lt;&#x2F;li&gt;
&lt;li&gt;Finally you can learn more about &lt;strong&gt;Golem&lt;&#x2F;strong&gt; itself at https:&#x2F;&#x2F;www.golem.cloud&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
</feed>
