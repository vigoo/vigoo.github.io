<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>vigoo&#x27;s software development blog - haskell</title>
    <link rel="self" type="application/atom+xml" href="https://blog.vigoo.dev/tags/haskell/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.vigoo.dev"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2015-12-22T00:00:00+00:00</updated>
    <id>https://blog.vigoo.dev/tags/haskell/atom.xml</id>
    <entry xml:lang="en">
        <title>Gradle-Haskell-plugin with experimental Stack support</title>
        <published>2015-12-22T00:00:00+00:00</published>
        <updated>2015-12-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Daniel Vigovszky
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.vigoo.dev/posts/gradle-haskell-plugin-stack/"/>
        <id>https://blog.vigoo.dev/posts/gradle-haskell-plugin-stack/</id>
        
        <content type="html" xml:base="https://blog.vigoo.dev/posts/gradle-haskell-plugin-stack/">&lt;p&gt;I&#x27;ve released a &lt;strong&gt;new version (0.4)&lt;&#x2F;strong&gt; of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;prezi&#x2F;gradle-haskell-plugin&quot;&gt;gradle-haskell-plugin&lt;&#x2F;a&gt; today, with &lt;strong&gt;experimental stack support&lt;&#x2F;strong&gt;.
It is not enabled by default, but I used it exclusively for months and it seems to get quite stable. To use it you need &lt;a href=&quot;https:&#x2F;&#x2F;haskellstack.com&quot;&gt;stack&lt;&#x2F;a&gt;,
have it enabled with &lt;code&gt;-Puse-stack&lt;&#x2F;code&gt; and have to keep some rules in your &lt;code&gt;.cabal&lt;&#x2F;code&gt; file, as explained &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;prezi&#x2F;gradle-haskell-plugin#explanation-stack-mode&quot;&gt;in the README&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-does-it-work&quot;&gt;How does it work?&lt;&#x2F;h2&gt;
&lt;p&gt;The core idea did not change &lt;a href=&quot;https:&#x2F;&#x2F;blog.vigoo.dev&#x2F;posts&#x2F;gradle-haskell-plugin&#x2F;&quot;&gt;compared to the original, cabal based solution&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To support chaining the binary artifacts, I had to add a new option to &lt;em&gt;stack&lt;&#x2F;em&gt; called &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;commercialhaskell&#x2F;stack&#x2F;pull&#x2F;990&quot;&gt;extra package databases&lt;&#x2F;a&gt;. The databases listed in this section are passed &lt;em&gt;after the global&lt;&#x2F;em&gt; but &lt;strong&gt;before&lt;&#x2F;strong&gt; the snapshot and the local databases, which means that the snapshot database cannot be used (the packages in the binary artifacts are not &quot;seeing&quot; them). This sounds bad, but &lt;em&gt;gradle-haskell-plugin&lt;&#x2F;em&gt; does a workaround; it &lt;strong&gt;generates&lt;&#x2F;strong&gt; the &lt;code&gt;stack.yaml&lt;&#x2F;code&gt; automatically, and in a way that:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;it disables snapshots on stack level (uses a resolver like &lt;code&gt;ghc-7.10.2&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;lists all the dependencies explicitly in &lt;code&gt;extra-deps&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;but it still figures out the &lt;em&gt;versions&lt;&#x2F;em&gt; of the dependencies (to be listed in &lt;code&gt;extra-deps&lt;&#x2F;code&gt;) based on a given &lt;em&gt;stackage snapshot&lt;&#x2F;em&gt;!&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;With this approach we get the same behavior that was already proven in cabal mode, but with the advantage that the generated &lt;code&gt;stack.yaml&lt;&#x2F;code&gt; completely defines the project for any tool that knows stack. So after gradle extracted the dependencies and generated the &lt;code&gt;stack.yaml&lt;&#x2F;code&gt;, it is no longer needed to succesfully compile&#x2F;run&#x2F;test the project, which means that tools like IDE integration will work much better than with the more hacky cabal mode of the plugin.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Case Study - Haskell at Prezi</title>
        <published>2015-09-21T00:00:00+00:00</published>
        <updated>2015-09-21T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Daniel Vigovszky
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.vigoo.dev/posts/haskell-case-study/"/>
        <id>https://blog.vigoo.dev/posts/haskell-case-study/</id>
        
        <content type="html" xml:base="https://blog.vigoo.dev/posts/haskell-case-study/">&lt;p&gt;I wrote a &lt;em&gt;case study&lt;&#x2F;em&gt; for &lt;a href=&quot;http:&#x2F;&#x2F;www.fpcomplete.com&quot;&gt;FPComplete&lt;&#x2F;a&gt; on how we use Haskell at &lt;a href=&quot;https:&#x2F;&#x2F;prezi.com&quot;&gt;Prezi&lt;&#x2F;a&gt;. It is published &lt;a href=&quot;https:&#x2F;&#x2F;www.fpcomplete.com&#x2F;page&#x2F;case-study-prezi&quot;&gt;here&lt;&#x2F;a&gt;, but I&#x27;m just posting it here as well:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;prezi.com&quot;&gt;Prezi&lt;&#x2F;a&gt; is a cloud-based presentation and storytelling tool, based on a zoomable canvas. The company was founded in 2009, and today we have more than 50 million users, with more than 160 million prezis created.&lt;&#x2F;p&gt;
&lt;p&gt;The company is using several different platforms and technologies; one of these is &lt;em&gt;Haskell&lt;&#x2F;em&gt;, which we are using server side, for code generation and for testing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pdom&quot;&gt;PDOM&lt;&#x2F;h2&gt;
&lt;p&gt;Prezi&#x27;s document format is continuously evolving as we add features to the application. It is very important for us that this format is handled correctly on all our supported platforms, and both on client and server side. To achieve this, we created an eDSL in Haskell that defines the schema of a Prezi. From this schema we are able to generate several artifacts.&lt;&#x2F;p&gt;
&lt;p&gt;Most importantly we are generating a &lt;em&gt;Prezi Document Object Model (PDOM)&lt;&#x2F;em&gt; library for multiple platforms - Haxe (compiled to JS) code for the web, C++ code for the native platforms, and Haskell code for our tests, tools and the server side. These libraries are responsible for loading, updating, maintaining consistency and saving Prezis.&lt;&#x2F;p&gt;
&lt;p&gt;This API also implements &lt;em&gt;collaborative editing&lt;&#x2F;em&gt; functionality by transparently synchronising document changes between multiple clients. This technique is called &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Operational_transformation&quot;&gt;operational transformation (OT)&lt;&#x2F;a&gt;. We implemented the server side of this in Haskell; it supports clients from any of the supported platforms and it is connected to several other backend services.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;benefits&quot;&gt;Benefits&lt;&#x2F;h2&gt;
&lt;p&gt;Using &lt;em&gt;Haskell&lt;&#x2F;em&gt; for this project turned out to have huge benefits.&lt;&#x2F;p&gt;
&lt;p&gt;We are taking advantage of Haskell&#x27;s capabilities to create embedded domain specific languages, using it to define the document&#x27;s schema in our own eDSL which is used not only by Haskell developers but many others too.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell&#x27;s clean and terse code allows us to describe document invariants and rules in a very readable way and the type system guarantees that we handle all the necessary cases, providing a stable base Haskell implementation which we can compare the other language backends to.&lt;&#x2F;p&gt;
&lt;p&gt;It was also possible to define a set of merge laws for OT, which are verified whenever we introduce a new element to the document schema, guaranteeing that the collaboration functionality works correctly.&lt;&#x2F;p&gt;
&lt;p&gt;We use the &lt;em&gt;QuickCheck&lt;&#x2F;em&gt; testing library on all levels. We can generate arbitrary Prezi documents and test serialization on all the backends. We are even generating arbitrary JavaScript code which uses our generated API to test random collaborative network sessions. These tests turned out to be critical for our success as they caught many interesting problems before we deployed anything to production&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Haskell plugin for Gradle</title>
        <published>2015-04-22T00:00:00+00:00</published>
        <updated>2015-04-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Daniel Vigovszky
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.vigoo.dev/posts/gradle-haskell-plugin/"/>
        <id>https://blog.vigoo.dev/posts/gradle-haskell-plugin/</id>
        
        <content type="html" xml:base="https://blog.vigoo.dev/posts/gradle-haskell-plugin/">&lt;p&gt;My team at &lt;a href=&quot;https:&#x2F;&#x2F;prezi.com&quot;&gt;Prezi&lt;&#x2F;a&gt; uses &lt;strong&gt;Haskell&lt;&#x2F;strong&gt; for several projects, which usually depend on each other, often with build steps using other languages such as Scala, C++ or Haxe. As &lt;a href=&quot;https:&#x2F;&#x2F;gradle.org&#x2F;&quot;&gt;Gradle&lt;&#x2F;a&gt; is used heavily in the company, we decided to try to integrate our Haskell projects within Gradle.&lt;&#x2F;p&gt;
&lt;p&gt;The result is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;prezi&#x2F;gradle-haskell-plugin&quot;&gt;Gradle Haskell Plugin&lt;&#x2F;a&gt;, which we were using succesfully in the last 2 months in our daily work, and we have &lt;em&gt;open-sourced&lt;&#x2F;em&gt; recently.&lt;&#x2F;p&gt;
&lt;p&gt;What makes this solution interesting is that it not just simply wraps &lt;em&gt;cabal&lt;&#x2F;em&gt; within Gradle tasks, but implements a way to define &lt;strong&gt;dependencies&lt;&#x2F;strong&gt; between Haskell projects and to upload the binary Haskell artifacts to a &lt;em&gt;repository&lt;&#x2F;em&gt; such as &lt;a href=&quot;http:&#x2F;&#x2F;www.jfrog.com&#x2F;open-source&#x2F;&quot;&gt;artifactory&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This makes it easy to modularize our projects, publish them, and also works perfectly with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;prezi&#x2F;pride&quot;&gt;pride&lt;&#x2F;a&gt;, an other &lt;em&gt;open-source&lt;&#x2F;em&gt; Prezi project. This means that we can work on a subset of our Haskell projects while the other dependencies are built on Jenkins, and it also integrates well with our non-Haskell projects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-does-it-work&quot;&gt;How does it work?&lt;&#x2F;h2&gt;
&lt;p&gt;The main idea is that we let &lt;em&gt;cabal&lt;&#x2F;em&gt; manage the Haskell packages, and handle whole Haskell &lt;em&gt;sandboxes&lt;&#x2F;em&gt; on Gradle level. So if you have a single Haskell project, it will be built using &lt;em&gt;cabal&lt;&#x2F;em&gt; and the result sandbox (the built project together with all the dependent cabal packages which are not installed in the &lt;em&gt;global package database&lt;&#x2F;em&gt;) will be packed&#x2F;published as a Gradle &lt;em&gt;artifact&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is not very interesting so far, but when you introduce dependencies on Gradle level, the plugin does something which (as far as I know) is not really done by anyone else, which I call &lt;em&gt;sandbox chaining&lt;&#x2F;em&gt;. This basically means that to compile the haskell project, the plugin will pass all the dependent sandboxes&#x27; package database to cabal and GHC, so for the actual sandbox only the packages which are &lt;strong&gt;not&lt;&#x2F;strong&gt; in any of the dependent sandboxes will be installed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;example&quot;&gt;Example&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s see an example scenario with &lt;em&gt;4 gradle-haskell projects&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;prezi&#x2F;gradle-haskell-plugin&#x2F;master&#x2F;doc&#x2F;gradle-haskell-plugin-drawing1.png&quot; class=&quot;zimg&quot;&gt;&lt;img width=&quot;600&quot; src=&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;prezi&#x2F;gradle-haskell-plugin&#x2F;master&#x2F;doc&#x2F;gradle-haskell-plugin-drawing1.png&quot; alt=&quot;gradle-haskell-plugin&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The project called &lt;em&gt;Haskell project&lt;&#x2F;em&gt; depends on two other projects, which taking into accound the transitive dependencies means it depends on &lt;em&gt;three other haskell projects&lt;&#x2F;em&gt;. Each project has its own haskell source and &lt;em&gt;cabal file&lt;&#x2F;em&gt;. Building this suite consists of the following steps:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dependency 1&lt;&#x2F;strong&gt; is built using only the &lt;em&gt;global package database&lt;&#x2F;em&gt;, everything &lt;strong&gt;not&lt;&#x2F;strong&gt; in that database, together with the compiled project goes into its &lt;code&gt;build&#x2F;sandbox&lt;&#x2F;code&gt; directory, which is a combination of a &lt;em&gt;GHC package database&lt;&#x2F;em&gt; and the project&#x27;s build output. This is packed as &lt;strong&gt;dependency 1&lt;&#x2F;strong&gt;&#x27;s build artifact.&lt;&#x2F;li&gt;
&lt;li&gt;For &lt;strong&gt;dependency 2&lt;&#x2F;strong&gt;, Gradle first downloads the build artifact of &lt;em&gt;dependency 1&lt;&#x2F;em&gt; and extracts it to &lt;code&gt;build&#x2F;deps&#x2F;dependency1&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Then it runs &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;exFalso&#x2F;sandfix&quot;&gt;SandFix&lt;&#x2F;a&gt; on it&lt;&#x2F;li&gt;
&lt;li&gt;And compiles the second project, now passing &lt;strong&gt;both&lt;&#x2F;strong&gt; the &lt;em&gt;global package database&lt;&#x2F;em&gt; and &lt;strong&gt;dependency 1&lt;&#x2F;strong&gt;&#x27;s sandbox to cabal&#x2F;ghc. The result is that only the packages which are &lt;strong&gt;not&lt;&#x2F;strong&gt; in any of these two package databases will be installed in the project&#x27;s own sandbox, which becomes the build artifact of &lt;strong&gt;dependency 2&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;For &lt;strong&gt;dependency 3&lt;&#x2F;strong&gt;, Gradle extracts both the direct dependency and the transitive dependency&#x27;s sandbox, to &lt;code&gt;build&#x2F;deps&#x2F;dependency2&lt;&#x2F;code&gt; and &lt;code&gt;build&#x2F;deps&#x2F;dependency3&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Then it runs &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;exFalso&#x2F;sandfix&quot;&gt;SandFix&lt;&#x2F;a&gt; on both the dependencies&lt;&#x2F;li&gt;
&lt;li&gt;And finally passes three package databases to cabal&#x2F;ghc to compile the project. Only those cabal dependencies will be installed into this sandbox which are not in global, neither in any of the dependent sandboxes.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, for &lt;strong&gt;Haskell project&lt;&#x2F;strong&gt; it goes the same way, but here we have three sandboxes, all chained together to make sure only the built sandbox only contains what is not in the dependent sandboxes yet.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;For more information, check out &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;prezi&#x2F;gradle-haskell-plugin&quot;&gt;the documentation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
