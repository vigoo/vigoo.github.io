<html>
    <head>
        
        <meta charset="UTF-8">
        <meta name="robots" content="index, follow">
        <title>Zig and the WASM Component Model</title>
        
        <meta name="author" content="Daniel Vigovszky">
             
        
        <meta name="description" content="">
           
        
        <link rel="canonical" href="https:&#x2F;&#x2F;blog.vigoo.dev&#x2F;posts&#x2F;zig-wasm-component-model&#x2F;">
        
        
        
        <link rel="alternate" type="application/atom+xml" title="Atom" href="https://blog.vigoo.dev/atom.xml">
        

        <link rel="stylesheet" href="https://iosevka-webfonts.github.io/iosevka-term/iosevka-term.css" />
        <link rel="stylesheet" href="https://blog.vigoo.dev/style.css">
    </head>
    
</html>
<body>
    
    <header class="hdr">
        <h1><a href="/">vigoo&#x27;s software development blog</a></h1>
        <nav>
            <menu>
                <li><a href="/">Home</a></li>
                <li><a href="/tags">Tags</a></li>
                <li><a href="/archive">Archive</a></li>
                <li><a href="/about">About</a></li>
            </menu>
        </nav>
    </header>
    

    <main>
        
    <article class="post">
        <header>
            <h1>Zig and the WASM Component Model</h1>
            
            <p class="posted-on">Posted on May 09, 2024</p>
        </header>

        <p><a href="https://golem.cloud">Golem</a> always considered <a href="https://ziglang.org">Zig</a> a supported language, but until now the only documented way to use it was to compile a program with a single <code>main</code> function into a <em>core WebAssembly module</em> and then wrap that as a component that can be uploaded to Golem for execution. This is very limiting, as in order to take full advantage of Golem (and any other part of the evolving <em>WASM Component Model ecosystem</em>) a Zig program must have definitions for both <em>importing</em> and <em>exporting</em> functions and data types in order to be a usable component.</p>
<h2 id="binding-generators">Binding generators</h2>
<p>For many supported languages the workflow is to write a <strong>WIT</strong> file, which is the Component Model's <a href="https://component-model.bytecodealliance.org/design/wit.html">interface definition language</a> and then use a <em>binding generator</em>, such as <a href="https://github.com/bytecodealliance/wit-bindgen/">wit-bindgen</a> to create statically typed representation of the component's imports and exports in the targeted language.</p>
<p>The binding generator does not support Zig, but it does support C. So the best we can do with existing tooling is to use the C binding generator and Zig's excellent C interoperability together to be able to create WASM components with Zig.</p>
<h2 id="the-steps">The steps</h2>
<p>The primary steps are the following:</p>
<ul>
<li><strong>Define</strong> the component's interface using WIT</li>
<li><strong>Generate</strong> C bindings from this definition</li>
<li><strong>Implement</strong> the exported functions in Zig, potentially using other imported interfaces and data types available through the generated binding</li>
<li><strong>Compile</strong> the whole project into WASM</li>
<li>As Zig's standard library still uses <em>WASI Preview 1</em>, and outputs a single WASM module, we also have to <strong>compose</strong> our resulting module with an <em>adapter component</em> in order to get a WASM component depending on <em>WASI Preview 2</em>.</li>
</ul>
<p>The first step is manual work - although we may eventually get code-first approaches in some languages where the WIT interface is generated as part as the build flow, it is not the case for Zig at the moment.</p>
<p>For generating the bindings we use <code>wit-bindgen</code>, and once the implementation is done we compile the Zig source code, together with the generated C bindings into a WASM module using zig's build system (<code>zig build</code>).</p>
<p>Finally we can use <code>wasm-tools compose</code> to take this WASM module and an appropriate version of a Preview1 adapter such as <a href="https://github.com/golemcloud/golem-wit/blob/main/adapters/tier1/wasi_snapshot_preview1.wasm">the one we provide for Golem</a> to get the final component that's ready to be used with Golem.</p>
<h2 id="zig-s-build-system">Zig's build system</h2>
<p>Executing all these steps manually is not convenient but fortunately we can integrate all the steps within Zig's <em>build system</em>. Let's see how!</p>
<p>We need to write a custom <code>build.zig</code> in the following way. First, let's do some imports and start defining our build flow:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">const</span><span> std </span><span style="color:#a626a4;">= @import</span><span>(</span><span style="color:#50a14f;">&quot;std&quot;</span><span>);
</span><span style="color:#a626a4;">const</span><span> Builder </span><span style="color:#a626a4;">=</span><span> std.build.Builder;
</span><span style="color:#a626a4;">const</span><span> CrossTarget </span><span style="color:#a626a4;">=</span><span> std.zig.CrossTarget;
</span><span>
</span><span style="color:#a626a4;">pub fn </span><span style="color:#0184bc;">build</span><span>(</span><span style="color:#e45649;">b</span><span>: </span><span style="color:#a626a4;">*Builder</span><span>) </span><span style="color:#a626a4;">!void </span><span>{
</span></code></pre>
<p>The first non-manual thing on our list of steps is <strong>generating</strong> the C bindings. Let's define a build step that just runs <code>wit-bindgen</code> for us:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    </span><span style="color:#a626a4;">const</span><span> bindgen </span><span style="color:#a626a4;">=</span><span> b.</span><span style="color:#e45649;">addSystemCommand</span><span>(&amp;.{ </span><span style="color:#50a14f;">&quot;wit-bindgen&quot;</span><span>, </span><span style="color:#50a14f;">&quot;c&quot;</span><span>, </span><span style="color:#50a14f;">&quot;--autodrop-borrows&quot;</span><span>, </span><span style="color:#50a14f;">&quot;yes&quot;</span><span>, 
</span><span>    	</span><span style="color:#50a14f;">&quot;./wit&quot;</span><span>, </span><span style="color:#50a14f;">&quot;--out-dir&quot;</span><span>, </span><span style="color:#50a14f;">&quot;src/bindings&quot; </span><span>});
</span></code></pre>
<p>This is just a description of running the binding generator, not integrated within the build flow yet. The next step is <strong>compiling</strong> our Zig and C files into WASM.</p>
<p>First we define it as an <em>executable target</em>:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    </span><span style="color:#a626a4;">const</span><span> optimize </span><span style="color:#a626a4;">=</span><span> b.</span><span style="color:#e45649;">standardOptimizeOption</span><span>(.{
</span><span>        .preferred_optimize_mode </span><span style="color:#a626a4;">=</span><span style="color:#c18401;"> .ReleaseSmall</span><span>,
</span><span>    });
</span><span>    </span><span style="color:#a626a4;">const</span><span> wasm </span><span style="color:#a626a4;">=</span><span> b.</span><span style="color:#e45649;">addExecutable</span><span>(.{ 
</span><span>    	.name </span><span style="color:#a626a4;">= </span><span style="color:#50a14f;">&quot;main&quot;</span><span>,
</span><span>      .root_source_file </span><span style="color:#a626a4;">=</span><span> .{ .path </span><span style="color:#a626a4;">= </span><span style="color:#50a14f;">&quot;src/main.zig&quot; </span><span>}, 
</span><span>      .target </span><span style="color:#a626a4;">=</span><span> .{
</span><span>        .cpu_arch </span><span style="color:#a626a4;">=</span><span style="color:#c18401;"> .wasm32</span><span>,
</span><span>        .os_tag </span><span style="color:#a626a4;">=</span><span style="color:#c18401;"> .wasi</span><span>,
</span><span>    	}, 
</span><span>    	.optimize </span><span style="color:#a626a4;">=</span><span> optimize 
</span><span>    });
</span></code></pre>
<p>This already defines we want to use WASM and target WASI and points to our root source file. We are not done yet though, as if we run the binding generator step defined above, we will end up having a couple of files generated in our <code>src/bindings</code> directory:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Î» l src/bindings
</span><span>.rw-r--r-- 909 vigoo  9 May 09:34 zig3.c
</span><span>.rw-r--r-- 371 vigoo  9 May 09:34 zig3.h
</span><span>.rw-r--r-- 299 vigoo  9 May 09:34 zig3_component_type.o
</span></code></pre>
<p>The <code>.c</code>/<code>.h</code> pair contains the generated binding, while the object file holds the binary representation of the WIT interface it was generated from.</p>
<p>We need to add the C source and the object file into our build, and the header file to the include file paths. As the name of the generated files depend on the WIT file's contents, we need to list all files in this <code>bindings</code> directory and mutate our <code>wasm</code> build target according to what we find:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    </span><span style="color:#a626a4;">const</span><span> binding_root </span><span style="color:#a626a4;">=</span><span> b.</span><span style="color:#e45649;">pathFromRoot</span><span>(</span><span style="color:#50a14f;">&quot;src/bindings&quot;</span><span>);
</span><span>    </span><span style="color:#a626a4;">var</span><span> binding_root_dir </span><span style="color:#a626a4;">= try</span><span> std.fs.</span><span style="color:#e45649;">cwd</span><span>().</span><span style="color:#e45649;">openIterableDir</span><span>(binding_root, .{});
</span><span>    </span><span style="color:#a626a4;">defer</span><span> binding_root_dir.</span><span style="color:#e45649;">close</span><span>();
</span><span>    </span><span style="color:#a626a4;">var</span><span> it </span><span style="color:#a626a4;">= try</span><span> binding_root_dir.</span><span style="color:#e45649;">walk</span><span>(b.allocator);
</span><span>    </span><span style="color:#a626a4;">while </span><span>(</span><span style="color:#a626a4;">try</span><span> it.</span><span style="color:#e45649;">next</span><span>()) </span><span style="color:#a626a4;">|</span><span>entry</span><span style="color:#a626a4;">| </span><span>{
</span><span>        </span><span style="color:#a626a4;">switch </span><span>(entry.kind) {
</span><span style="color:#c18401;">            .file </span><span style="color:#a626a4;">=&gt; </span><span>{
</span><span>                </span><span style="color:#a626a4;">const</span><span> path </span><span style="color:#a626a4;">=</span><span> b.</span><span style="color:#e45649;">pathJoin</span><span>(&amp;.{ binding_root, entry.path });
</span><span>                </span><span style="color:#a626a4;">if </span><span>(std.mem.</span><span style="color:#e45649;">endsWith</span><span>(u8, entry.basename, </span><span style="color:#50a14f;">&quot;.c&quot;</span><span>)) {
</span><span>                    wasm.</span><span style="color:#e45649;">addCSourceFile</span><span>(.{ .file </span><span style="color:#a626a4;">=</span><span> .{ .path </span><span style="color:#a626a4;">=</span><span> path }, .flags </span><span style="color:#a626a4;">=</span><span> &amp;.{} });
</span><span>                } </span><span style="color:#a626a4;">else if </span><span>(std.mem.</span><span style="color:#e45649;">endsWith</span><span>(u8, entry.basename, </span><span style="color:#50a14f;">&quot;.o&quot;</span><span>)) {
</span><span>                    wasm.</span><span style="color:#e45649;">addObjectFile</span><span>(.{ .path </span><span style="color:#a626a4;">=</span><span> path });
</span><span>                }
</span><span>            },
</span><span>            </span><span style="color:#a626a4;">else =&gt; continue</span><span>,
</span><span>        }
</span><span>    }
</span></code></pre>
<p>This registers all the <code>.c</code> and <code>.o</code> files from the generated bindings, but we still need to add the whole directory as an include path:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    wasm.</span><span style="color:#e45649;">addIncludePath</span><span>(.{ .path </span><span style="color:#a626a4;">=</span><span> binding_root });
</span></code></pre>
<p>and enable linking with <code>libc</code>:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    wasm.</span><span style="color:#e45649;">linkLibC</span><span>();
</span></code></pre>
<p>Now that we defined two build steps - the generating the bindings and compiling to a WASM module - we define the third step which is <strong>composing</strong> the generated module and the preview1 adapter into a WASM component:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    </span><span style="color:#a626a4;">const</span><span> adapter </span><span style="color:#a626a4;">=</span><span> b.</span><span style="color:#e45649;">option</span><span>(
</span><span>    	[]</span><span style="color:#a626a4;">const</span><span> u8, 
</span><span>    	</span><span style="color:#50a14f;">&quot;adapter&quot;</span><span>, 
</span><span>    	</span><span style="color:#50a14f;">&quot;Path to the Golem Tier1 WASI adapter&quot;</span><span>) </span><span style="color:#a626a4;">orelse </span><span style="color:#50a14f;">&quot;adapters/tier1/wasi_snapshot_preview1.wasm&quot;</span><span>;
</span><span>    </span><span style="color:#a626a4;">const</span><span> out </span><span style="color:#a626a4;">= try</span><span> std.fmt.</span><span style="color:#e45649;">allocPrint</span><span>(b.allocator, </span><span style="color:#50a14f;">&quot;zig-out/bin/{s}&quot;</span><span>, .{wasm.out_filename});
</span><span>    </span><span style="color:#a626a4;">const</span><span> component </span><span style="color:#a626a4;">=</span><span> b.</span><span style="color:#e45649;">addSystemCommand</span><span>(&amp;.{ </span><span style="color:#50a14f;">&quot;wasm-tools&quot;</span><span>, </span><span style="color:#50a14f;">&quot;component&quot;</span><span>, </span><span style="color:#50a14f;">&quot;new&quot;</span><span>, out, 
</span><span>    	</span><span style="color:#50a14f;">&quot;-o&quot;</span><span>, </span><span style="color:#50a14f;">&quot;zig-out/bin/component.wasm&quot;</span><span>, </span><span style="color:#50a14f;">&quot;--adapt&quot;</span><span>, adapter });
</span></code></pre>
<p>Here we provide a way to override the path to the adapter WASM using <code>zig build -Dadapter=xxx</code> but default to <code>adapters/tier1/wasi_snapshot_preview1.wasm</code> in case it is not specified.</p>
<p>The final step is to set up dependencies between these build steps and wire them to the main build flow:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    wasm.step.</span><span style="color:#e45649;">dependOn</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>bindgen.step);
</span><span>    component.step.</span><span style="color:#e45649;">dependOn</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>wasm.step);
</span><span>    b.</span><span style="color:#e45649;">installArtifact</span><span>(wasm);
</span><span>    b.</span><span style="color:#e45649;">getInstallStep</span><span>().</span><span style="color:#e45649;">dependOn</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>component.step);
</span><span>  }
</span></code></pre>
<h2 id="trying-it-out">Trying it out</h2>
<p>Let's try this out by implementing a simple counter component. We start with the first step - defining our WIT file, putting it into <code>wit/counter.wit</code>:</p>
<pre data-lang="wit" style="background-color:#fafafa;color:#383a42;" class="language-wit "><code class="language-wit" data-lang="wit"><span style="color:#a626a4;">package </span><span>golem:example;
</span><span>
</span><span style="color:#a626a4;">interface </span><span>api {
</span><span>  </span><span style="color:#0184bc;">add</span><span>: </span><span style="color:#a626a4;">func</span><span>(</span><span style="color:#e45649;">value</span><span>: </span><span style="color:#a626a4;">u64</span><span>);
</span><span>  </span><span style="color:#0184bc;">get</span><span>: </span><span style="color:#a626a4;">func</span><span>() </span><span style="color:#a626a4;">-&gt; u64</span><span>;
</span><span>}
</span><span>
</span><span style="color:#a626a4;">world </span><span>counter {
</span><span>  </span><span style="color:#a626a4;">export </span><span>api;
</span><span>}
</span><span>
</span></code></pre>
<p>We also save the above defined build script as <code>build.zig</code> (full version <a href="https://gist.github.com/vigoo/19ed4b5d3e47ca2f5f1258d1ae8b28a4">available here</a>) and then write an initial  <code>src/main.zig</code> file:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">const</span><span> std </span><span style="color:#a626a4;">= @import</span><span>(</span><span style="color:#50a14f;">&quot;std&quot;</span><span>);
</span><span>
</span><span style="color:#a626a4;">pub fn </span><span style="color:#0184bc;">main</span><span>() </span><span style="color:#a626a4;">anyerror!void </span><span>{}
</span></code></pre>
<p>Let's place the <a href="https://github.com/golemcloud/golem-wit/raw/main/adapters/tier1/wasi_snapshot_preview1.wasm">adapter WASM</a> as well in the <code>adapters/tier1</code> directory, and then try to compile this:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Î» zig build --summary all                                                                                 ...
</span><span>zig build-exe main Debug wasm32-wasi: error: the following command failed with 2 compilation errors:
</span><span>...
</span><span>error: wasm-ld: /Users/vigoo/projects/demo/counter/zig-cache/o/a212123ad3dcf4839747c2bd77f7ef4e/counter.o:
</span><span>undefined symbol: exports_golem_example_api_add
</span><span>error: wasm-ld: /Users/vigoo/projects/demo/counter/zig-cache/o/a212123ad3dcf4839747c2bd77f7ef4e/counter.o:
</span><span>undefined symbol: exports_golem_example_api_get
</span></code></pre>
<p>It fails because we defined two exported functions: <code>api/add</code> and <code>api/get</code> in our WIT file but haven't implemented them yet. Let's do that:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">var </span><span style="color:#e45649;">state</span><span>: </span><span style="color:#a626a4;">u64 = </span><span style="color:#c18401;">0</span><span>;
</span><span>
</span><span style="color:#a626a4;">export fn </span><span style="color:#0184bc;">exports_golem_example_api_add</span><span>(</span><span style="color:#e45649;">value</span><span>: </span><span style="color:#a626a4;">u64</span><span>) </span><span style="color:#a626a4;">void </span><span>{
</span><span>    </span><span style="color:#a626a4;">const</span><span> stdout </span><span style="color:#a626a4;">=</span><span> std.io.</span><span style="color:#e45649;">getStdOut</span><span>().</span><span style="color:#e45649;">writer</span><span>();
</span><span>    stdout.</span><span style="color:#e45649;">print</span><span>(</span><span style="color:#50a14f;">&quot;Adding {} to state</span><span style="color:#0997b3;">\n</span><span style="color:#50a14f;">&quot;</span><span>, .{value}) </span><span style="color:#a626a4;">catch unreachable</span><span>;
</span><span>    state </span><span style="color:#a626a4;">+=</span><span> value;
</span><span>}
</span><span>
</span><span style="color:#a626a4;">export fn </span><span style="color:#0184bc;">exports_golem_example_api_get</span><span>() </span><span style="color:#a626a4;">u64 </span><span>{
</span><span>    </span><span style="color:#a626a4;">return</span><span> state;
</span><span>}
</span></code></pre>
<p>Then compile it:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Î» zig build --summary all
</span><span>Generating &quot;src/bindings/counter.c&quot;
</span><span>Generating &quot;src/bindings/counter.h&quot;
</span><span>Generating &quot;src/bindings/counter_component_type.o&quot;
</span><span>Build Summary: 5/5 steps succeeded
</span><span>install success
</span><span>ââ install main cached
</span><span>â  ââ zig build-exe main Debug wasm32-wasi cached 9ms MaxRSS:29M
</span><span>â     ââ run wit-bindgen success 3ms MaxRSS:3M
</span><span>ââ run wasm-tools success 11ms MaxRSS:8M
</span><span>   ââ zig build-exe main Debug wasm32-wasi (+1 more reused dependencies)
</span></code></pre>
<p>and we can verify our resulting <code>zig-out/component.wasm</code> using <code>wasm-tools</code>:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Î» wasm-tools print --skeleton zig-out/bin/component.wasm 
</span><span>(component
</span><span>  ...
</span><span>  (instance (;11;) (instantiate 0
</span><span>      (with &quot;import-func-add&quot; (func 16))
</span><span>      (with &quot;import-func-get&quot; (func 17))
</span><span>    )
</span><span>  )
</span><span>  (export (;12;) &quot;golem:example/api&quot; (instance 11))
</span><span>  (@producers
</span><span>    (processed-by &quot;wit-component&quot; &quot;0.20.1&quot;)
</span><span>  )
</span><span>)
</span></code></pre>
<h2 id="using-imports">Using imports</h2>
<p>After this simple example let's try <em>importing</em> some interface and using that from our Zig code. What we are going to do is every time our counter changes, we are going to also save that value to an external key-value store. This is usually not something you need to do when writing a Golem application, because your program will be durable anyway - you can just keep the counter in memory. But it is a simple enough example to demonstrate how to use imported interfaces from Zig.</p>
<p>First let's add some additional WIT files into <code>wit/deps</code> from the <a href="https://github.com/golemcloud/golem-wit">golem-wit repository</a> (Note that the WASI Key-Value interface is defined <a href="https://github.com/WebAssembly/wasi-keyvalue">here</a>, the <code>golem-wit</code> repo just stores the exact version of its definitions which is currently implemented by Golem ).</p>
<p>We need the following directory tree:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Î» tree wit
</span><span>wit
</span><span>âââ counter.wit
</span><span>âââ deps
</span><span>    âââ io
</span><span>    âÂ Â  âââ error.wit
</span><span>    âÂ Â  âââ poll.wit
</span><span>    âÂ Â  âââ streams.wit
</span><span>    âÂ Â  âââ world.wit
</span><span>    âââ keyvalue
</span><span>        âââ atomic.wit
</span><span>        âââ caching.wit
</span><span>        âââ error.wit
</span><span>        âââ eventual-batch.wit
</span><span>        âââ eventual.wit
</span><span>        âââ handle-watch.wit
</span><span>        âââ types.wit
</span><span>        âââ world.wit
</span><span>
</span><span>4 directories, 13 files
</span></code></pre>
<p>Then we can import the key-value interface to <code>counter.wit</code>:</p>
<pre data-lang="wit" style="background-color:#fafafa;color:#383a42;" class="language-wit "><code class="language-wit" data-lang="wit"><span style="color:#a626a4;">package </span><span>golem:example;
</span><span>
</span><span style="color:#a626a4;">interface </span><span>api {
</span><span>  </span><span style="color:#0184bc;">add</span><span>: </span><span style="color:#a626a4;">func</span><span>(</span><span style="color:#e45649;">value</span><span>: </span><span style="color:#a626a4;">u64</span><span>);
</span><span>  </span><span style="color:#0184bc;">get</span><span>: </span><span style="color:#a626a4;">func</span><span>() </span><span style="color:#a626a4;">-&gt; u64</span><span>;
</span><span>}
</span><span>
</span><span style="color:#a626a4;">world </span><span>counter {
</span><span>  </span><span style="color:#a626a4;">import </span><span>wasi:keyvalue/eventual@</span><span style="color:#c18401;">0.1.0</span><span>;
</span><span>
</span><span>  </span><span style="color:#a626a4;">export </span><span>api;
</span><span>}
</span></code></pre>
<p>By recompiling the project we can verify everything still works, and we will also get our new bindings generated in the C source.</p>
<p>Before implementing writing to the key-value store in Zig, let's just take a look at the WIT interface of <code>wasi:keyvalue/eventual@0.1.0</code> to understand what we will have to do:</p>
<pre data-lang="wit" style="background-color:#fafafa;color:#383a42;" class="language-wit "><code class="language-wit" data-lang="wit"><span style="color:#a626a4;">interface </span><span>eventual {
</span><span>  </span><span style="color:#a0a1a7;">// ...
</span><span>  </span><span style="color:#0184bc;">set</span><span>: </span><span style="color:#a626a4;">func</span><span>(
</span><span>    </span><span style="color:#e45649;">bucket</span><span>: </span><span style="color:#a626a4;">borrow</span><span>&lt;bucket&gt;, 
</span><span>    </span><span style="color:#e45649;">key</span><span>: key, 
</span><span>    </span><span style="color:#e45649;">outgoing-value</span><span>: </span><span style="color:#a626a4;">borrow</span><span>&lt;outgoing-value&gt;
</span><span>  ) </span><span style="color:#a626a4;">-&gt; result</span><span>&lt;</span><span style="color:#a626a4;">_</span><span>, error&gt;;
</span><span>}
</span></code></pre>
<p>We will need to pass a <code>bucket</code> and an <code>outgoing-value</code>, both being <em>WIT resources</em> so we first need to create them, then borrow references of them for the <code>set</code> call, and finally drop them.</p>
<p>The bucket resource can be constructed with a static function called <code>open-bucket</code>:</p>
<pre data-lang="wit" style="background-color:#fafafa;color:#383a42;" class="language-wit "><code class="language-wit" data-lang="wit"><span style="color:#a626a4;">resource </span><span style="color:#c18401;">bucket </span><span>{
</span><span>  </span><span style="color:#0184bc;">open-bucket</span><span>: </span><span style="color:#a626a4;">static func</span><span>(</span><span style="color:#e45649;">name</span><span>: </span><span style="color:#a626a4;">string</span><span>) </span><span style="color:#a626a4;">-&gt; result</span><span>&lt;bucket, error&gt;;
</span><span>}
</span></code></pre>
<p>Searching for this in the generated C bindings reveals the following:</p>
<pre data-lang="c" style="background-color:#fafafa;color:#383a42;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#a626a4;">extern bool </span><span style="color:#0184bc;">wasi_keyvalue_types_static_bucket_open_bucket</span><span>(
</span><span>  counter_string_t </span><span style="color:#a626a4;">*</span><span style="color:#e45649;">name</span><span>, 
</span><span>  wasi_keyvalue_types_own_bucket_t </span><span style="color:#a626a4;">*</span><span style="color:#e45649;">ret</span><span>, 
</span><span>  wasi_keyvalue_types_own_error_t </span><span style="color:#a626a4;">*</span><span>err
</span><span>);
</span></code></pre>
<p>We will have to drop the created bucket with</p>
<pre data-lang="c" style="background-color:#fafafa;color:#383a42;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#a626a4;">extern void </span><span style="color:#0184bc;">wasi_keyvalue_types_bucket_drop_own</span><span>(
</span><span>  wasi_keyvalue_types_own_bucket_t handle
</span><span>);
</span></code></pre>
<p>With all this information let's try to open a bucket in Zig by directly using the generated C bindings. First we need to import the C headers:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">const</span><span> c </span><span style="color:#a626a4;">= @cImport</span><span>({
</span><span>    </span><span style="color:#0184bc;">@cDefine</span><span>(</span><span style="color:#50a14f;">&quot;_NO_CRT_STDIO_INLINE&quot;</span><span>, </span><span style="color:#50a14f;">&quot;1&quot;</span><span>);
</span><span>    </span><span style="color:#a626a4;">@cInclude</span><span>(</span><span style="color:#50a14f;">&quot;counter.h&quot;</span><span>);
</span><span>});
</span></code></pre>
<p>We also define an initial error type for our function for using later:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">const </span><span>KVError </span><span style="color:#a626a4;">= error </span><span>{
</span><span>    FailedToOpenBucket,
</span><span>};
</span></code></pre>
<p>Then start implementing the store function by first storing the bucket's name in <code>counter_string_t</code>:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">fn </span><span style="color:#0184bc;">record_state</span><span>() </span><span style="color:#a626a4;">anyerror!void </span><span>{
</span><span>    </span><span style="color:#a626a4;">const</span><span> stdout </span><span style="color:#a626a4;">=</span><span> std.io.</span><span style="color:#e45649;">getStdOut</span><span>().</span><span style="color:#e45649;">writer</span><span>();
</span><span>
</span><span>    </span><span style="color:#a626a4;">var </span><span style="color:#e45649;">bucket_name</span><span>: </span><span style="color:#a626a4;">c.counter_string_t = </span><span style="color:#c18401;">undefined</span><span>;
</span><span>    c.</span><span style="color:#e45649;">counter_string_dup</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>bucket_name, </span><span style="color:#50a14f;">&quot;state&quot;</span><span>);
</span><span>    </span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">counter_string_free</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>bucket_name);
</span></code></pre>
<p>and then invoking the <code>wasi_keyvalue_types_static_bucket_open_bucket</code> function:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span>    </span><span style="color:#a626a4;">var </span><span style="color:#e45649;">bucket</span><span>: </span><span style="color:#a626a4;">c.wasi_keyvalue_types_own_bucket_t = </span><span style="color:#c18401;">undefined</span><span>;
</span><span>    </span><span style="color:#a626a4;">var </span><span style="color:#e45649;">bucket_err</span><span>: </span><span style="color:#a626a4;">c.wasi_keyvalue_wasi_keyvalue_error_own_error_t = </span><span style="color:#c18401;">undefined</span><span>;
</span><span>    </span><span style="color:#a626a4;">if </span><span>(c.</span><span style="color:#e45649;">wasi_keyvalue_types_static_bucket_open_bucket</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>bucket_name, </span><span style="color:#a626a4;">&amp;</span><span>bucket, </span><span style="color:#a626a4;">&amp;</span><span>bucket_err)) {
</span><span>        </span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_types_bucket_drop_own</span><span>(bucket);
</span><span>        
</span><span>        </span><span style="color:#a0a1a7;">// TODO
</span><span>    } </span><span style="color:#a626a4;">else </span><span>{
</span><span>        </span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_wasi_keyvalue_error_error_drop_own</span><span>(bucket_err);
</span><span>        </span><span style="color:#a626a4;">try</span><span> stdout.</span><span style="color:#e45649;">print</span><span>(</span><span style="color:#50a14f;">&quot;Failed to open bucket</span><span style="color:#0997b3;">\n</span><span style="color:#50a14f;">&quot;</span><span>, .{});
</span><span>
</span><span>        </span><span style="color:#a626a4;">return</span><span> KVError.FailedToOpenBucket;
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now that we have an open bucket we want to call the <code>set</code> function to update a key's value:</p>
<pre data-lang="c" style="background-color:#fafafa;color:#383a42;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#a626a4;">extern bool </span><span style="color:#0184bc;">wasi_keyvalue_eventual_set</span><span>(
</span><span>  wasi_keyvalue_eventual_borrow_bucket_t </span><span style="color:#e45649;">bucket</span><span>, 
</span><span>  wasi_keyvalue_eventual_key_t </span><span style="color:#a626a4;">*</span><span style="color:#e45649;">key</span><span>, 
</span><span>  wasi_keyvalue_eventual_borrow_outgoing_value_t </span><span style="color:#e45649;">outgoing_value</span><span>, 
</span><span>  wasi_keyvalue_eventual_own_error_t </span><span style="color:#a626a4;">*</span><span>err
</span><span>);
</span></code></pre>
<p>We already have our bucket, but we <em>own</em> it and we need to pass a <em>borrowed</em> bucket to this function. What's the difference? There is no difference in the actual value - both just store a <em>handle</em> to a resource that exists in the runtime engine, but we still have to borrow the owned value using the <code>wasi_keyvalue_types_borrow_bucket</code> function. The <code>wasi_keyvalue_eventual_key_t</code> type is just an alias for <code>counter_string_t</code> and <code>wasi_keyvalue_eventual_borrow_outgoing_value_t</code> is another resource we need to construct first. Let's put this together!</p>
<p>First we borrow the owned bucket:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">var</span><span> borrowed_bucket </span><span style="color:#a626a4;">=</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_types_borrow_bucket</span><span>(bucket);
</span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_types_bucket_drop_borrow</span><span>(borrowed_bucket);
</span></code></pre>
<p>Then we create an <em>outgoing value</em> that's going to be stored in the key-value store:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">var</span><span> outgoing_value </span><span style="color:#a626a4;">=</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_types_static_outgoing_value_new_outgoing_value</span><span>();
</span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_types_outgoing_value_drop_own</span><span>(outgoing_value);
</span><span style="color:#a626a4;">var</span><span> borrowed_outgoing_value </span><span style="color:#a626a4;">=</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_types_borrow_outgoing_value</span><span>(outgoing_value);
</span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_types_outgoing_value_drop_borrow</span><span>(borrowed_outgoing_value);
</span><span>        
</span><span style="color:#a626a4;">var </span><span style="color:#e45649;">body</span><span>: </span><span style="color:#a626a4;">c.counter_string_t = </span><span style="color:#c18401;">undefined</span><span>;
</span><span style="color:#a626a4;">var</span><span> value </span><span style="color:#a626a4;">= try</span><span> std.fmt.</span><span style="color:#e45649;">allocPrint</span><span>(gpa.</span><span style="color:#e45649;">allocator</span><span>(), </span><span style="color:#50a14f;">&quot;{d}&quot;</span><span>, .{state});
</span><span>c.</span><span style="color:#e45649;">counter_string_set</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>body, </span><span style="color:#0184bc;">@ptrCast</span><span>(value));
</span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">counter_string_free</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>body);
</span><span>
</span><span style="color:#a626a4;">var </span><span style="color:#e45649;">write_err</span><span>: </span><span style="color:#a626a4;">c.wasi_keyvalue_types_own_error_t = </span><span style="color:#c18401;">undefined</span><span>;
</span><span style="color:#a626a4;">if </span><span>(</span><span style="color:#a626a4;">!</span><span>c.</span><span style="color:#e45649;">wasi_keyvalue_types_method_outgoing_value_outgoing_value_write_body_sync</span><span>(
</span><span>    borrowed_outgoing_value, 
</span><span>    </span><span style="color:#0184bc;">@ptrCast</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>body),
</span><span>    </span><span style="color:#a626a4;">&amp;</span><span>bucket_err)) {
</span><span>        
</span><span>    </span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">wasi_keyvalue_wasi_keyvalue_error_error_drop_own</span><span>(write_err);
</span><span>    </span><span style="color:#a626a4;">try</span><span> stdout.</span><span style="color:#e45649;">print</span><span>(</span><span style="color:#50a14f;">&quot;Failed to set outgoing value</span><span style="color:#0997b3;">\n</span><span style="color:#50a14f;">&quot;</span><span>, .{});
</span><span>    </span><span style="color:#a626a4;">return</span><span> KVError.FailedToSetKey;
</span><span>}
</span></code></pre>
<p>Also we need to create a string for holding the <em>key</em>:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">var </span><span style="color:#e45649;">key</span><span>: </span><span style="color:#a626a4;">c.counter_string_t = </span><span style="color:#c18401;">undefined</span><span>;
</span><span>c.</span><span style="color:#e45649;">counter_string_dup</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>key, </span><span style="color:#50a14f;">&quot;latest&quot;</span><span>);
</span><span style="color:#a626a4;">defer</span><span> c.</span><span style="color:#e45649;">counter_string_free</span><span>(</span><span style="color:#a626a4;">&amp;</span><span>key);
</span></code></pre>
<p>And finally call the <code>set</code> function:</p>
<pre data-lang="zig" style="background-color:#fafafa;color:#383a42;" class="language-zig "><code class="language-zig" data-lang="zig"><span style="color:#a626a4;">var </span><span style="color:#e45649;">set_err</span><span>: </span><span style="color:#a626a4;">c.wasi_keyvalue_eventual_own_error_t = </span><span style="color:#c18401;">undefined</span><span>;
</span><span style="color:#a626a4;">if </span><span>(</span><span style="color:#a626a4;">!</span><span>c.</span><span style="color:#e45649;">wasi_keyvalue_eventual_set</span><span>(borrowed_bucket, </span><span style="color:#a626a4;">&amp;</span><span>key, borrowed_outgoing_value, </span><span style="color:#a626a4;">&amp;</span><span>set_err)) {
</span><span>    </span><span style="color:#a626a4;">try</span><span> stdout.</span><span style="color:#e45649;">print</span><span>(</span><span style="color:#50a14f;">&quot;Failed to set key</span><span style="color:#0997b3;">\n</span><span style="color:#50a14f;">&quot;</span><span>, .{});
</span><span>    </span><span style="color:#a626a4;">return</span><span> KVError.FailedToSetKey;
</span><span>}
</span></code></pre>
<p>With this implementation we can compile our new version of our WASM component which now also depends on <code>wasi:keyvalue</code> and stores the latest value in a remote storage every time it gets updated.</p>
<h2 id="what-s-next">What's next?</h2>
<p>With the above technique we have a way to impelment WASM components in Zig, but working with the generated C bindings is a bit inconvenient. It would be nice to have a more idiomatic Zig interface to the component model, and maybe it can be achieved just by using Zig's metaprogramming features without having to create a Zig specific binding generator in addition to the existing ones.</p>


    </article>

    </main>    

        
    
</body>