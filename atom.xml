<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>vigoo's software development blog</title>
    <link href="http://vigoo.github.io/atom.xml" rel="self" />
    <link href="http://vigoo.github.io" />
    <id>http://vigoo.github.io/atom.xml</id>
    <author>
        <name>Daniel Vigovszky</name>
        <email>daniel.vigovszky@gmail.com</email>
    </author>
    <updated>2020-09-23T00:00:00Z</updated>
    <entry>
    <title>Code generation in ZIO-AWS</title>
    <link href="http://vigoo.github.io/posts/2020-09-23-zioaws-code-generation.html" />
    <id>http://vigoo.github.io/posts/2020-09-23-zioaws-code-generation.html</id>
    <published>2020-09-23T00:00:00Z</published>
    <updated>2020-09-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 23, 2020
    
</div>

<p>I have recently published a set of libraries, <a href="https://github.com/vigoo/zio-aws"><strong>zio-aws</strong></a>, aiming to provide a better interface for working with <em>AWS services</em> from <a href="https://zio.dev/">ZIO</a> applications. For more information about how the ZIO <em>interface</em> works and how to get started with these libraries, read the repository’s README. In this post, I will focus on how these libraries are generated from the schema provided by the <a href="https://github.com/aws/aws-sdk-java-v2">AWS Java SDK v2</a>.</p>
<h2 id="generating-code">Generating code</h2>
<p>I wanted to cover <em>all</em> AWS services at once. This means client libraries for more than 200 services, so the only possible approach was to <em>generate</em> these libraries on top of a small hand-written core.</p>
<h3 id="schema">Schema</h3>
<p>The first thing we need for generating code is a source schema. This is the model that we use to create the source code from. It is usually constructed by some kind of DSL or more directly described by a JSON or YAML or similar data model. In the case of <strong>zio-aws</strong> this was already defined in the <a href="https://github.com/aws/aws-sdk-java-v2">AWS Java SDK v2</a> project. The way it works is:</p>
<ul>
<li>There is a <code>codegen</code> project, published in the <code>software.amazon.awssdk</code> group among the client libraries, that contains the Java classes used for generating the Java SDK itself. This contains the data model classes for parsing the actual schema as well.</li>
<li>In the AWS Java SDK v2 repository, the schema is located in the subdirectory called <a href="https://github.com/aws/aws-sdk-java-v2/tree/master/services"><code>services</code></a>. There is a directory for each AWS service and it contains among other things some relevant <em>JSON</em> schema files:
<ul>
<li><code>service-2.json</code> is the main schema of the service, describing the data structures and operations</li>
<li><code>paginators-1.json</code> describes the operations that the Java SDK creates a <em>paginator interface</em> for</li>
<li><code>customization.config</code> contains extra information, including changes to be applied on top of the service model</li>
</ul></li>
<li>Fortunately, these are also embedded in the generated <em>AWS Java SDK</em> libraries as resources, so getting <em>all client libraries</em> on the classpath gives us an easy way to get the corresponding schemas as well</li>
</ul>
<p>I decided to use the low-level data classes from the AWS <code>codegen</code> library to parse these files and using that build a higher-level model that can be then used as an input for the <em>code generator</em>.</p>
<p>This is encapsulated in a <em>ZIO layer</em> called <code>Loader</code>, which has two functions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> <span class="fu">findModels</span>(): ZIO[Blocking, Throwable, Set[ModelId]]</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">def</span> <span class="fu">loadCodegenModel</span>(id: ModelId): ZIO[Blocking, Throwable, C2jModels]</a></code></pre></div>
<p>The first one, <code>findModels</code> uses the <code>ClassLoader</code> to enumerate all <code>codegen-resources</code> folders on the <em>classpath</em> and just returns a set of <code>ModelId</code>s. <code>ModelId</code> is a pair of a model name (such as <code>s3</code>) and an optional submodule name (for example <code>dynamodb:dynamodbstreams</code>).</p>
<p>Then for each detected model we can load it with the <code>loadCodegenModel</code> function, <code>C2jModels</code> is a class from the AWS <code>codegen</code> library.</p>
<p>Figuring out how to interpret these data structures, and how to map them to the generated Java API was the hardest part, but it’s out of scope for this post. Our next topic here is how we generate code from our <em>model</em>.</p>
<h3 id="scalameta">Scalameta</h3>
<p>There are several possibilities to generate source code and I tried many of them during the past years. Let’s see some examples:</p>
<ul>
<li>Using a general-purpose text template engine. An example we used at <a href="https://prezi.com">Prezi</a> is the <a href="https://github.com/bkiers/Liqp">Java implementation of the Liquid templating engine</a>. Another example is the <a href="https://github.com/OpenAPITools/openapi-generator">OpenAPI generator project</a> that uses <a href="https://mustache.github.io/">Mustache</a> templates to generate server and client code from OpenAPI specifications.</li>
<li>Generating from code with some general-purpose pretty-printing library. With this approach, we are using the pretty-printer library’s composability features to create source code building blocks, and map the code generator model to these constructs. It is easier to express complex logic in this case, as we don’t have to encode it in a limited dynamic template model. On the other hand, reading the code generator’s source and imagining the output is not easy, and nothing enforces that the pretty-printer building blocks are actually creating valid source code.</li>
<li>If the target language has an AST with a pretty-printing feature, we can map the model to the AST directly and just pretty print at the end. With this, we get a much more efficient development cycle, as the generated code is at least guaranteed to be syntactically correct. But the AST can be far from how the target language’s textual representation looks like, which makes it difficult to read and write this code.</li>
<li>With a library that supports building ASTs with <em>quasiquotes</em>, we can build the AST fragments with a syntax that is very close to the generated target language. For <em>Scala</em>, a library that supports this and is used in a lot of tooling projects is <a href="https://scalameta.org/">Scalameta</a></li>
</ul>
<p>I wanted to try using <em>Scalameta</em> ever since I met Devon Stewart and he mentioned how he uses it in <a href="https://github.com/twilio/guardrail/">guardrail</a>. Finally, this was a perfect use case to do so!</p>
<p>To get an understanding of what kind of Scala language constructs can be built with <em>quasiquotes</em> with <em>Scalameta</em>, check <a href="https://scalameta.org/docs/trees/quasiquotes.html">the list of them in the official documentation</a>.</p>
<p>We get a good mix of both worlds with this. It is possible to express complex template logic in real code, creating higher-level constructs, taking advantage of the full power of Scala. On the other hand, the actual <em>quasiquoted</em> fragments are still close to the code generator’s target language (which is in this case also Scala).</p>
<p>Let’s see a short example of this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">private</span> <span class="kw">def</span> <span class="fu">generateMap</span>(m: Model): ZIO[GeneratorContext, GeneratorFailure, ModelWrapper] = {</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb2-3" title="3">    keyModel &lt;- <span class="fu">get</span>(m.<span class="fu">shape</span>.<span class="fu">getMapKeyType</span>.<span class="fu">getShape</span>)</a>
<a class="sourceLine" id="cb2-4" title="4">    valueModel &lt;- <span class="fu">get</span>(m.<span class="fu">shape</span>.<span class="fu">getMapValueType</span>.<span class="fu">getShape</span>)</a>
<a class="sourceLine" id="cb2-5" title="5">    keyT &lt;- TypeMapping.<span class="fu">toWrappedType</span>(keyModel)</a>
<a class="sourceLine" id="cb2-6" title="6">    valueT &lt;- TypeMapping.<span class="fu">toWrappedType</span>(valueModel)</a>
<a class="sourceLine" id="cb2-7" title="7">  } <span class="kw">yield</span> <span class="fu">ModelWrapper</span>(</a>
<a class="sourceLine" id="cb2-8" title="8">    code = List(q<span class="st">&quot;&quot;&quot;type ${m.asType} = Map[$keyT, $valueT]&quot;&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb2-9" title="9">  )</a>
<a class="sourceLine" id="cb2-10" title="10">}</a></code></pre></div>
<p>For each <em>AWS</em> service-specific <em>model type</em> we generate some kind of wrapper code into the ZIO service client library. This is done by processing the schema model to an intermediate format where for each such wrapper, we have a <code>ModelWrapper</code> value that already has the <em>Scalameta AST</em> for that particular wrapper. The above code fragment creates this for <em>map types</em>, which is a simple type alias for a Scala <code>Map</code>. It’s a <code>ZIO</code> function, taking advantage of passing around the context in the <em>environment</em> and safely handling generator failures, while the actual generated code part in the <code>q&quot;&quot;&quot;...&quot;&quot;&quot;</code> remained quite readable.</p>
<p>Then the whole <em>model package</em> can be expressed like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">for</span> {</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb3-3" title="3">  primitiveModels &lt;- ZIO.<span class="fu">foreach</span>(primitiveModels.<span class="fu">toList</span>.<span class="fu">sortBy</span>(_.<span class="fu">name</span>))(generateModel)</a>
<a class="sourceLine" id="cb3-4" title="4">  models &lt;- ZIO.<span class="fu">foreach</span>(complexModels.<span class="fu">toList</span>.<span class="fu">sortBy</span>(_.<span class="fu">name</span>))(generateModel)</a>
<a class="sourceLine" id="cb3-5" title="5">} <span class="kw">yield</span> q<span class="st">&quot;&quot;&quot;package $fullPkgName {</span></a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7">            <span class="kw">import</span> scala.<span class="fu">jdk</span>.<span class="fu">CollectionConverters</span>._</a>
<a class="sourceLine" id="cb3-8" title="8">            <span class="kw">import</span> java.<span class="fu">time</span>.<span class="fu">Instant</span></a>
<a class="sourceLine" id="cb3-9" title="9">            <span class="kw">import</span> zio.{Chunk, ZIO}</a>
<a class="sourceLine" id="cb3-10" title="10">            <span class="kw">import</span> software.<span class="fu">amazon</span>.<span class="fu">awssdk</span>.<span class="fu">core</span>.<span class="fu">SdkBytes</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">            ..$parentModuleImport</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">            <span class="kw">package</span> <span class="kw">object</span> model {</a>
<a class="sourceLine" id="cb3-15" title="15">              <span class="kw">object</span> primitives {</a>
<a class="sourceLine" id="cb3-16" title="16">                ..${primitiveModels.<span class="fu">flatMap</span>(_.<span class="fu">code</span>)}</a>
<a class="sourceLine" id="cb3-17" title="17">              }</a>
<a class="sourceLine" id="cb3-18" title="18"></a>
<a class="sourceLine" id="cb3-19" title="19">              ..${models.<span class="fu">flatMap</span>(_.<span class="fu">code</span>)}</a>
<a class="sourceLine" id="cb3-20" title="20">            }}<span class="st">&quot;&quot;&quot;</span></a></code></pre></div>
<p>This can be then <em>pretty printed</em> simply with<code>.toString</code> and saved to a <code>.scala</code> file.</p>
<h2 id="building-the-libraries">Building the libraries</h2>
<p>We have a way to collect the service models and generate source code from that, but we still have to use that generated code somehow. In <code>zio-aws</code> the goal was to generate a separate <em>client library</em> for each AWS service. At the time of writing, there were <strong>235</strong> such services. The generated libraries have to be built and published to <em>Sonatype</em>.</p>
<h3 id="first-version">First version</h3>
<p>In the first version I simply wired together the above described <code>loader</code> and <code>generator</code> module into a <code>ZIO</code> <em>command line</em> app, using <a href="https://vigoo.github.io/clipp/docs/">clipp</a> for command line parsing. It’s <code>main</code> was really just something like the following:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">val</span> app = <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">  svcs &lt;- config.<span class="fu">parameters</span>[Parameters].<span class="fu">map</span>(_.<span class="fu">serviceList</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">  ids &lt;- svcs <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="kw">case</span> Some(ids) =&gt; ZIO.<span class="fu">succeed</span>(ids.<span class="fu">toSet</span>)</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">case</span> None =&gt; loader.<span class="fu">findModels</span>().<span class="fu">mapError</span>(ReflectionError)</a>
<a class="sourceLine" id="cb4-6" title="6">  }</a>
<a class="sourceLine" id="cb4-7" title="7">  _ &lt;- ZIO.<span class="fu">foreachPar</span>(ids) { id =&gt;</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb4-9" title="9">      model &lt;- loader.<span class="fu">loadCodegenModel</span>(id).<span class="fu">mapError</span>(ReflectionError)</a>
<a class="sourceLine" id="cb4-10" title="10">      _ &lt;- generator.<span class="fu">generateServiceCode</span>(id, model).<span class="fu">mapError</span>(GeneratorError)</a>
<a class="sourceLine" id="cb4-11" title="11">    } <span class="kw">yield</span> ()</a>
<a class="sourceLine" id="cb4-12" title="12">  }</a>
<a class="sourceLine" id="cb4-13" title="13">  _ &lt;- generator.<span class="fu">generateBuildSbt</span>(ids).<span class="fu">mapError</span>(GeneratorError)</a>
<a class="sourceLine" id="cb4-14" title="14">  _ &lt;- generator.<span class="fu">copyCoreProject</span>().<span class="fu">mapError</span>(GeneratorError)</a>
<a class="sourceLine" id="cb4-15" title="15">} <span class="kw">yield</span> ExitCode.<span class="fu">success</span></a>
<a class="sourceLine" id="cb4-16" title="16"></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="kw">val</span> cfg = config.<span class="fu">fromArgsWithUsageInfo</span>(args, Parameters.<span class="fu">spec</span>).<span class="fu">mapError</span>(ParserError)</a>
<a class="sourceLine" id="cb4-18" title="18"><span class="kw">val</span> modules = loader.<span class="fu">live</span> ++ (cfg &gt;+&gt; generator.<span class="fu">live</span>)</a>
<a class="sourceLine" id="cb4-19" title="19">app.<span class="fu">provideCustomLayer</span>(modules)</a></code></pre></div>
<p>Then created a <em>multi-module</em> <code>sbt</code> project with the following modules:</p>
<ul>
<li><code>zio-aws-codegen</code> the CLI code generator we were talking about so far</li>
<li><code>zio-aws-core</code> holding the common part of all AWS service wrapper libraries. This contains things like how to translate AWS pagination into <code>ZStream</code> etc.</li>
<li><code>zio-aws-akka-http</code>, <code>zio-aws-http4s</code> and <code>zio-aws-netty</code> are the supported <em>HTTP layers</em>, all depend on <code>zio-aws-core</code></li>
</ul>
<p>I also created a first <em>example</em> project in a separate <code>sbt</code> project, that demonstrated the use of some of the generated AWS client libraries. With this primitive setup, building everything from scratch and running the example took the following steps:</p>
<ol type="1">
<li><code>sbt compile</code> the root project</li>
<li>manually running <code>zio-aws-codegen</code> to generate <em>all client libs at once</em> to a separate directory, with a corresponding <code>build.sbt</code> including all these projects in a single <code>sbt</code> project</li>
<li><code>sbt publishLocal</code> in the generated <code>sbt</code> project</li>
<li><code>sbt run</code> in the <em>examples</em> project</li>
</ol>
<p>For the second, manual step I created some <em>custom sbt tasks</em> called <code>generateAll</code>, <code>buildAll</code>, and <code>publishLocalAll</code>, that downloaded an <code>sbt-launch-*.jar</code> and used it to run the code generator and fork an <code>sbt</code> to build the generated project.</p>
<p>The <code>generateAll</code> task was quite simple:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1">generateAll := Def.<span class="fu">taskDyn</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="kw">val</span> root = baseDirectory.<span class="fu">value</span>.<span class="fu">getAbsolutePath</span></a>
<a class="sourceLine" id="cb5-3" title="3">  Def.<span class="fu">task</span> {</a>
<a class="sourceLine" id="cb5-4" title="4">    (codegen / Compile / run).<span class="fu">toTask</span>(s<span class="st">&quot; --target-root ${root}/generated --source-root ${root} --version $zioAwsVersion --zio-version $zioVersion --zio-rs-version $zioReactiveStreamsInteropVersion&quot;</span>).<span class="fu">value</span></a>
<a class="sourceLine" id="cb5-5" title="5">  }</a>
<a class="sourceLine" id="cb5-6" title="6">}.<span class="fu">value</span></a></code></pre></div>
<p>Launching a second <code>sbt</code> took more effort:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1">buildAll := Def.<span class="fu">taskDyn</span> {</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="kw">val</span> _ = generateAll.<span class="fu">value</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="kw">val</span> generatedRoot = baseDirectory.<span class="fu">value</span> / <span class="st">&quot;generated&quot;</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="kw">val</span> launcherVersion = sbtVersion.<span class="fu">value</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="kw">val</span> launcher = s<span class="st">&quot;sbt-launch-$launcherVersion.jar&quot;</span></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="kw">val</span> launcherFile = generatedRoot / launcher</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">  Def.<span class="fu">task</span>[Unit] {</a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="kw">if</span> (!launcherFile.<span class="fu">exists</span>) {</a>
<a class="sourceLine" id="cb6-10" title="10">      <span class="kw">val</span> u = <span class="fu">url</span>(s<span class="st">&quot;https://oss.sonatype.org/content/repositories/public/org/scala-sbt/sbt-launch/$launcherVersion/sbt-launch-$launcherVersion.jar&quot;</span>)</a>
<a class="sourceLine" id="cb6-11" title="11">      sbt.<span class="fu">io</span>.<span class="fu">Using</span>.<span class="fu">urlInputStream</span>(u) { inputStream =&gt;</a>
<a class="sourceLine" id="cb6-12" title="12">        IO.<span class="fu">transfer</span>(inputStream, launcherFile)</a>
<a class="sourceLine" id="cb6-13" title="13">      }</a>
<a class="sourceLine" id="cb6-14" title="14">    }</a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="kw">val</span> fork = <span class="kw">new</span> <span class="fu">ForkRun</span>(<span class="fu">ForkOptions</span>()</a>
<a class="sourceLine" id="cb6-16" title="16">      .<span class="fu">withWorkingDirectory</span>(generatedRoot))</a>
<a class="sourceLine" id="cb6-17" title="17">    fork.<span class="fu">run</span>(</a>
<a class="sourceLine" id="cb6-18" title="18">      <span class="st">&quot;xsbt.boot.Boot&quot;</span>,</a>
<a class="sourceLine" id="cb6-19" title="19">      classpath = launcherFile :: Nil,</a>
<a class="sourceLine" id="cb6-20" title="20">      options = <span class="st">&quot;compile&quot;</span> :: Nil,</a>
<a class="sourceLine" id="cb6-21" title="21">      log = streams.<span class="fu">value</span>.<span class="fu">log</span></a>
<a class="sourceLine" id="cb6-22" title="22">    )</a>
<a class="sourceLine" id="cb6-23" title="23">  }</a>
<a class="sourceLine" id="cb6-24" title="24">}.<span class="fu">value</span></a></code></pre></div>
<p>With these extra tasks, I released the first version of the library manually, but there was a lot of annoying difficulties:</p>
<ul>
<li>Having to switch between various <code>sbt</code> projects</li>
<li>The need to <code>publishLocal</code> the generated artifacts in order to build the examples, or any kind of integration tests that I planned to add</li>
<li>The only way to build only those client libraries that are needed for the examples/tests was to build and publish them manually, as this dependency was not tracked at all between the unrelated <code>sbt</code> projects</li>
<li>Because the generated <code>sbt</code> project could not refer to the outer <code>zio-aws-core</code> project, it has to be copied into the generated project in the code generator step</li>
<li>Building and publishing all the <strong>235</strong> projects at once required about <strong>16Gb</strong> memory and hours of compilation time. It was too big to run on any of the (freely available) CI systems.</li>
</ul>
<h3 id="proper-solution">Proper solution</h3>
<p>When I mentioned this, <em>Itamar Ravid</em> recommended trying to make it an <em>sbt code generator</em>. <code>sbt</code> has built-in support for generating source code, as described <a href="https://www.scala-sbt.org/1.0/docs/Howto-Generating-Files.html">on it’s documentation page</a>. This alone though would not be enough to cover our use case, as in <code>zio-aws</code> even the <em>set of projects</em> is dynamic and comes from the enumeration of schema models. Fortunately, there is support for that in too, through the <code>extraProjects</code> property of <code>sbt</code> <em>plugins</em>.</p>
<p>With these two tools, the new project layout became the following:</p>
<ul>
<li><code>zio-aws-codegen</code> is an sbt <strong>plugin</strong>, having it’s own <code>sbt</code> project in a subdirectory</li>
<li>the <code>zio-aws-core</code> and the HTTP libraries are all in the top-level project as before</li>
<li>examples and integration tests are also part of the top-level project</li>
<li>the <code>zio-aws-codegen</code> plugin is referenced using a <code>ProjectRef</code> from the outer project</li>
<li>the plugin adds all the <em>AWS service client wrapper libraries</em> to the top-level project</li>
<li>these projects generate their source on-demand</li>
</ul>
<p>In this setup, it is possible to build any subset of the generated libraries without the need to process and compile all of them, so it needs much less memory. It is also much simpler to run tests or build examples on top of them, as the test and example projects can directly depend on the generated libraries as <code>sbt</code> submodules. And even developing the <em>code generator</em> itself is convenient - although for editing it, it has to be opened as in a separate IDE session, but otherwise, <code>sbt reload</code> on the top level project automatically recompiles the plugin when needed.</p>
<p>Let’s see piece by piece how we can achieve this!</p>
<h4 id="project-as-a-source-dependency">Project as a source dependency</h4>
<p>The first thing I wanted to do is having the <code>zio-aws-codegen</code> project converted to an <code>sbt</code> plugin, but still having it in the same repository and be able to use it without having to install to a local repository. Although the whole code generator code could have been added to the top level <code>sbt</code> project’s <code>project</code> source, I wanted to keep it as a separate module to be able to publish it as a library or a CLI tool in the future if needed.</p>
<p>This can be achieved by putting it in a subdirectory of the top level project, with a separate <code>build.sbt</code> that contains the</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1">sbtPlugin := <span class="kw">true</span></a></code></pre></div>
<p>(beside the usual ones). Then it can be referenced in the top level project’s <code>project/plugins.sbt</code> in the following way:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">lazy</span> <span class="kw">val</span> codegen = project</a>
<a class="sourceLine" id="cb8-2" title="2">  .<span class="fu">in</span>(<span class="fu">file</span>(<span class="st">&quot;.&quot;</span>))</a>
<a class="sourceLine" id="cb8-3" title="3">  .<span class="fu">dependsOn</span>(<span class="fu">ProjectRef</span>(<span class="fu">file</span>(<span class="st">&quot;../zio-aws-codegen&quot;</span>), <span class="st">&quot;zio-aws-codegen&quot;</span>))</a></code></pre></div>
<p>and enabled in the <code>build.sbt</code> as</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">enablePlugins</span>(ZioAwsCodegenPlugin)</a></code></pre></div>
<h4 id="dynamically-generating-projects">Dynamically generating projects</h4>
<p>To generate the subprojects dynamically, we need the <code>Set[ModelId]</code> coming from the <code>loader</code> module. It is a <code>ZIO</code> module, so from the <code>sbt</code> plugin we have to use <code>Runtime.default.unsafeRun</code> to execute it.</p>
<p>As the code generator project is now an <code>sbt</code> plugin, all the <code>sbt</code> data structures are directly available, so we can just write a function that maps the <code>ModelId</code>s to <code>Project</code>s:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">protected</span> <span class="kw">def</span> <span class="fu">generateSbtSubprojects</span>(ids: Set[ModelId]): Seq[Project] = ???</a></code></pre></div>
<p>One interesting part here is that some of the subprojects are depending on each other. This happens with AWS service <em>submodules</em>, indicated by the second parameter of <code>ModelId</code>. An example is <code>dynamodbstreams</code> that depends on <code>dynamodb</code>. When creating the <code>Project</code> values, we have to be able to <code>dependOn</code> on some other already generated projects, and they have to be generated in the correct order to do so.</p>
<p>We could do a full topological sort, but it is not necessary, here we know that the maximum depth of dependencies is 1, so it is enough to put the submodules at the end of the sequence:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">val</span> map = ids</a>
<a class="sourceLine" id="cb11-2" title="2">  .<span class="fu">toSeq</span></a>
<a class="sourceLine" id="cb11-3" title="3">  .<span class="fu">sortWith</span> { <span class="kw">case</span> (a, b) =&gt;</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="kw">val</span> aIsDependent = a.<span class="fu">subModuleName</span> <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb11-5" title="5">      <span class="kw">case</span> Some(value) <span class="kw">if</span> value != a.<span class="fu">name</span> =&gt; <span class="kw">true</span></a>
<a class="sourceLine" id="cb11-6" title="6">      <span class="kw">case</span> _ =&gt; <span class="kw">false</span></a>
<a class="sourceLine" id="cb11-7" title="7">    }</a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="kw">val</span> bIsDependent = b.<span class="fu">subModuleName</span> <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb11-9" title="9">      <span class="kw">case</span> Some(value) <span class="kw">if</span> value != b.<span class="fu">name</span> =&gt; <span class="kw">true</span></a>
<a class="sourceLine" id="cb11-10" title="10">      <span class="kw">case</span> _ =&gt; <span class="kw">false</span></a>
<a class="sourceLine" id="cb11-11" title="11">    }</a>
<a class="sourceLine" id="cb11-12" title="12">    bIsDependent || (!aIsDependent &amp;&amp; a.<span class="fu">toString</span> &lt; b.<span class="fu">toString</span>)</a>
<a class="sourceLine" id="cb11-13" title="13">  }</a></code></pre></div>
<p>Then in order to be able get the dependencies, we do a <em>fold</em> on the ordered <code>ModelId</code>s:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1">  .<span class="fu">foldLeft</span>(Map.<span class="fu">empty</span>[ModelId, Project]) { (mapping, id) =&gt;</a>
<a class="sourceLine" id="cb12-2" title="2">      <span class="co">// ...</span></a>
<a class="sourceLine" id="cb12-3" title="3">      <span class="kw">val</span> deps = id.<span class="fu">subModule</span> <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb12-4" title="4">        <span class="kw">case</span> Some(value) <span class="kw">if</span> value != id.<span class="fu">name</span> =&gt;</a>
<a class="sourceLine" id="cb12-5" title="5">          Seq(<span class="fu">ClasspathDependency</span>(<span class="fu">LocalProject</span>(<span class="st">&quot;zio-aws-core&quot;</span>), None),</a>
<a class="sourceLine" id="cb12-6" title="6">              <span class="fu">ClasspathDependency</span>(<span class="fu">mapping</span>(<span class="fu">ModelId</span>(id.<span class="fu">name</span>, Some(id.<span class="fu">name</span>))), None))</a>
<a class="sourceLine" id="cb12-7" title="7">        <span class="kw">case</span> _ =&gt;</a>
<a class="sourceLine" id="cb12-8" title="8">          Seq(<span class="fu">ClasspathDependency</span>(<span class="fu">LocalProject</span>(<span class="st">&quot;zio-aws-core&quot;</span>), None))</a>
<a class="sourceLine" id="cb12-9" title="9">      }      </a>
<a class="sourceLine" id="cb12-10" title="10">      <span class="kw">val</span> project = <span class="fu">Project</span>(fullName, <span class="fu">file</span>(<span class="st">&quot;generated&quot;</span>) / name)</a>
<a class="sourceLine" id="cb12-11" title="11">        .<span class="fu">settings</span>(</a>
<a class="sourceLine" id="cb12-12" title="12">          libraryDependencies += <span class="st">&quot;software.amazon.awssdk&quot;</span> % id.<span class="fu">name</span> % awsLibraryVersion.<span class="fu">value</span>,</a>
<a class="sourceLine" id="cb12-13" title="13">          <span class="co">// ...</span></a>
<a class="sourceLine" id="cb12-14" title="14">        .<span class="fu">dependsOn</span>(deps: _*)</a>
<a class="sourceLine" id="cb12-15" title="15"></a>
<a class="sourceLine" id="cb12-16" title="16">      mapping.<span class="fu">updated</span>(id, project)</a>
<a class="sourceLine" id="cb12-17" title="17">  }</a></code></pre></div>
<p>To make it easier to work with the generated projects, we also create a project named <code>all</code> that aggregates all the ones generated above.</p>
<h4 id="applying-settings-to-the-generated-projects">Applying settings to the generated projects</h4>
<p>The code generator only sets the basic settings for the generated projects: name, path and dependencies. We need a lot more, setting organization and version, all the publishing options, controlling the Scala version, etc.</p>
<p>I decided to keep these settings outside of the code generator plugin, in the top-level <code>sbt</code> project. By creating an <code>AutoPlugin</code> end enabling it for all projects, we can inject all the common settings for both the hand-written and the generated projects:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">object</span> Common <span class="kw">extends</span> AutoPlugin {</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="kw">object</span> autoImport {</a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="kw">val</span> scala212Version = <span class="st">&quot;2.12.12&quot;</span></a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="kw">val</span> scala213Version = <span class="st">&quot;2.13.3&quot;</span></a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-7" title="7">  }</a>
<a class="sourceLine" id="cb13-8" title="8">  <span class="kw">import</span> autoImport._</a>
<a class="sourceLine" id="cb13-9" title="9">    </a>
<a class="sourceLine" id="cb13-10" title="10">  <span class="kw">override</span> <span class="kw">val</span> trigger = allRequirements</a>
<a class="sourceLine" id="cb13-11" title="11">  <span class="kw">override</span> <span class="kw">val</span> <span class="kw">requires</span> = Sonatype</a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13">  <span class="kw">override</span> <span class="kw">lazy</span> <span class="kw">val</span> projectSettings =</a>
<a class="sourceLine" id="cb13-14" title="14">    Seq(</a>
<a class="sourceLine" id="cb13-15" title="15">      scalaVersion := scala213Version,</a>
<a class="sourceLine" id="cb13-16" title="16">      crossScalaVersions := List(scala212Version, scala213Version),</a>
<a class="sourceLine" id="cb13-17" title="17">      <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-18" title="18">    )</a>
<a class="sourceLine" id="cb13-19" title="19">}</a></code></pre></div>
<h4 id="source-generator-task">Source generator task</h4>
<p>At this point, we could also add the already existing <em>source code generation</em> to the initialization of the plugin, and just generate all the subproject’s all source files every time the <code>sbt</code> project is loaded. With this number of generated projects though, it would have been a very big startup overhead and would not allow us to split the build (at least not the code generation part) on CI, to solve the memory and build time issues.</p>
<p>As <code>sbt</code> has built-in support for defining <em>source generator tasks</em>, we can do much better!</p>
<p>Instead of generating the source codes in one step, we define a <code>generateSources</code> task and add it to each <em>generated subproject</em> as a <em>source generator</em>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1">Compile / sourceGenerators += generateSources.<span class="fu">taskValue</span>,</a>
<a class="sourceLine" id="cb14-2" title="2">awsLibraryId := id.<span class="fu">toString</span></a></code></pre></div>
<p>The <code>awsLibraryId</code> is a custom property that we the <code>generateSources</code> task can use to determine which schema to use for the code generation.</p>
<p>The first part of this task is to gather the information from the project it got applied on, including the custom <code>awsLibraryId</code> property:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">lazy</span> <span class="kw">val</span> generateSources =</a>
<a class="sourceLine" id="cb15-2" title="2">  Def.<span class="fu">task</span> {</a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">val</span> log = streams.<span class="fu">value</span>.<span class="fu">log</span></a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="kw">val</span> idStr = awsLibraryId.<span class="fu">value</span></a>
<a class="sourceLine" id="cb15-6" title="6">    <span class="kw">val</span> id = ModelId.<span class="fu">parse</span>(idStr) <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb15-7" title="7">      <span class="kw">case</span> <span class="fu">Left</span>(failure) =&gt; sys.<span class="fu">error</span>(failure)</a>
<a class="sourceLine" id="cb15-8" title="8">      <span class="kw">case</span> <span class="fu">Right</span>(value) =&gt; value</a>
<a class="sourceLine" id="cb15-9" title="9">    }</a>
<a class="sourceLine" id="cb15-10" title="10"></a>
<a class="sourceLine" id="cb15-11" title="11">    <span class="kw">val</span> targetRoot = (sourceManaged in Compile).<span class="fu">value</span></a>
<a class="sourceLine" id="cb15-12" title="12">    <span class="kw">val</span> travisSrc = travisSource.<span class="fu">value</span></a>
<a class="sourceLine" id="cb15-13" title="13">    <span class="kw">val</span> travisDst = travisTarget.<span class="fu">value</span></a>
<a class="sourceLine" id="cb15-14" title="14">    <span class="kw">val</span> parallelJobs = travisParallelJobs.<span class="fu">value</span></a></code></pre></div>
<p>From these, we create a <code>Parameters</code> data structure to pass to the <code>generator</code> module. This is what we used to construct with <code>clipp</code> from CLI arguments:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" title="1">    <span class="kw">val</span> params = <span class="fu">Parameters</span>(</a>
<a class="sourceLine" id="cb16-2" title="2">      targetRoot = Path.<span class="fu">fromJava</span>(targetRoot.<span class="fu">toPath</span>),</a>
<a class="sourceLine" id="cb16-3" title="3">      travisSource = Path.<span class="fu">fromJava</span>(travisSrc.<span class="fu">toPath</span>),</a>
<a class="sourceLine" id="cb16-4" title="4">      travisTarget = Path.<span class="fu">fromJava</span>(travisDst.<span class="fu">toPath</span>),</a>
<a class="sourceLine" id="cb16-5" title="5">      parallelTravisJobs = parallelJobs</a>
<a class="sourceLine" id="cb16-6" title="6">    )</a></code></pre></div>
<p>And finally, construct the <code>ZIO</code> environment, load a <strong>single</strong> schema model, and generate the library’s source code:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" title="1">    zio.<span class="fu">Runtime</span>.<span class="fu">default</span>.<span class="fu">unsafeRun</span> {</a>
<a class="sourceLine" id="cb17-2" title="2">      <span class="kw">val</span> cfg = ZLayer.<span class="fu">succeed</span>(params)</a>
<a class="sourceLine" id="cb17-3" title="3">      <span class="kw">val</span> env = loader.<span class="fu">live</span> ++ (cfg &gt;+&gt; generator.<span class="fu">live</span>)</a>
<a class="sourceLine" id="cb17-4" title="4">      <span class="kw">val</span> task =</a>
<a class="sourceLine" id="cb17-5" title="5">        <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb17-6" title="6">          _ &lt;- ZIO.<span class="fu">effect</span>(log.<span class="fu">info</span>(s<span class="st">&quot;Generating sources for $id&quot;</span>))</a>
<a class="sourceLine" id="cb17-7" title="7">          model &lt;- loader.<span class="fu">loadCodegenModel</span>(id)</a>
<a class="sourceLine" id="cb17-8" title="8">          files &lt;- generator.<span class="fu">generateServiceCode</span>(id, model)</a>
<a class="sourceLine" id="cb17-9" title="9">        } <span class="kw">yield</span> files.<span class="fu">toSeq</span></a>
<a class="sourceLine" id="cb17-10" title="10">      task.<span class="fu">provideCustomLayer</span>(env).<span class="fu">catchAll</span> { generatorError =&gt;</a>
<a class="sourceLine" id="cb17-11" title="11">        ZIO.<span class="fu">effect</span>(log.<span class="fu">error</span>(s<span class="st">&quot;Code generator failure: ${generatorError}&quot;</span>)).<span class="fu">as</span>(Seq.<span class="fu">empty</span>)</a>
<a class="sourceLine" id="cb17-12" title="12">      }</a>
<a class="sourceLine" id="cb17-13" title="13">    }</a>
<a class="sourceLine" id="cb17-14" title="14">  }</a></code></pre></div>
<p>The <code>generateServiceCode</code> function returns a <code>Set[File]</code> value containing all the generated source files. This is the result of the <em>source generator task</em>, and <code>sbt</code> uses this information to add the generated files to the compilation.</p>
<h4 id="referencing-the-generated-projects">Referencing the generated projects</h4>
<p>When defining downstream projects in the <code>build.sbt</code>, such as integration tests and other examples, we have to refer to the generated projects somehow. There is no value of type <code>Project</code> in scope to do so, but we can do it easily by name using <code>LocalProject</code>. The following example shows how the <code>example1</code> subproject does this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">lazy</span> <span class="kw">val</span> example1 = <span class="fu">Project</span>(<span class="st">&quot;example1&quot;</span>, <span class="fu">file</span>(<span class="st">&quot;examples&quot;</span>) / <span class="st">&quot;example1&quot;</span>)</a>
<a class="sourceLine" id="cb18-2" title="2">  .<span class="fu">dependsOn</span>(</a>
<a class="sourceLine" id="cb18-3" title="3">    core,</a>
<a class="sourceLine" id="cb18-4" title="4">    http4s,</a>
<a class="sourceLine" id="cb18-5" title="5">    netty,</a>
<a class="sourceLine" id="cb18-6" title="6">    <span class="fu">LocalProject</span>(<span class="st">&quot;zio-aws-elasticbeanstalk&quot;</span>),</a>
<a class="sourceLine" id="cb18-7" title="7">    <span class="fu">LocalProject</span>(<span class="st">&quot;zio-aws-ec2&quot;</span>)</a>
<a class="sourceLine" id="cb18-8" title="8">  )</a></code></pre></div>
<h4 id="parallel-build-on-travis-ci">Parallel build on Travis CI</h4>
<p>The last thing that I wanted to solve is building the full <code>zio-aws</code> suite on a CI. I am using <a href="https://travis-ci.org/">Travis CI</a> for my private projects, so that’s what I built it for. The idea is to split the set of <em>service client libraries</em> to chunks and create <a href="https://docs.travis-ci.com/user/build-matrix/">build matrix</a> to run those in parallel. The tricky part is that the set of generated service libraries is dynamic, collected by the code generator.</p>
<p>To solve this, I started to generate the <code>.travis.yml</code> build descriptor as well. The <em>hand-written</em> part has been moved to <code>.travis.base.yml</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb19-1" title="1"><span class="fu">language:</span><span class="at"> scala</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="fu">services:</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="kw">-</span> docker</a>
<a class="sourceLine" id="cb19-4" title="4"><span class="fu">scala:</span></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="kw">-</span> <span class="fl">2.12.12</span></a>
<a class="sourceLine" id="cb19-6" title="6">  <span class="kw">-</span> <span class="fl">2.13.3</span></a>
<a class="sourceLine" id="cb19-7" title="7"></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="fu">cache:</span></a>
<a class="sourceLine" id="cb19-9" title="9">  <span class="fu">directories:</span></a>
<a class="sourceLine" id="cb19-10" title="10">    <span class="kw">-</span> $HOME/.cache/coursier</a>
<a class="sourceLine" id="cb19-11" title="11">    <span class="kw">-</span> $HOME/.ivy2/cache</a>
<a class="sourceLine" id="cb19-12" title="12">    <span class="kw">-</span> $HOME/.sbt</a>
<a class="sourceLine" id="cb19-13" title="13"></a>
<a class="sourceLine" id="cb19-14" title="14"><span class="fu">env:</span></a>
<a class="sourceLine" id="cb19-15" title="15">  <span class="kw">-</span> COMMANDS=<span class="st">&quot;clean zio-aws-core/test zio-aws-akka-http/test zio-aws-http4s/test zio-aws-netty/test&quot;</span></a>
<a class="sourceLine" id="cb19-16" title="16">  <span class="kw">-</span> COMMANDS=<span class="st">&quot;clean examples/compile&quot;</span></a>
<a class="sourceLine" id="cb19-17" title="17">  <span class="kw">-</span> COMMANDS=<span class="st">&quot;clean integtests/test&quot;</span></a>
<a class="sourceLine" id="cb19-18" title="18"></a>
<a class="sourceLine" id="cb19-19" title="19"><span class="fu">before_install:</span></a>
<a class="sourceLine" id="cb19-20" title="20">  <span class="kw">-</span> if <span class="kw">[</span> <span class="st">&quot;$COMMANDS&quot;</span> = <span class="st">&quot;clean integtests/test&quot;</span> <span class="kw">]</span>; then docker pull localstack/localstack; fi</a>
<a class="sourceLine" id="cb19-21" title="21">  <span class="kw">-</span> if <span class="kw">[</span> <span class="st">&quot;$COMMANDS&quot;</span> = <span class="st">&quot;clean integtests/test&quot;</span> <span class="kw">]</span>; then docker run -d -p 4566:4566 --env SERVICES=s3,dynamodb --env START_WEB=0 localstack/localstack; fi</a>
<a class="sourceLine" id="cb19-22" title="22"></a>
<a class="sourceLine" id="cb19-23" title="23"><span class="fu">script:</span></a>
<a class="sourceLine" id="cb19-24" title="24">  <span class="kw">-</span> sbt ++$TRAVIS_SCALA_VERSION -jvm-opts travis/jvmopts $COMMANDS</a></code></pre></div>
<p>I use the <code>COMMANDS</code> environment variable to define the parallel sets of <code>sbt</code> commands here. There are three predefined sets: building <code>zio-aws-core</code> and the HTTP implementations, building the <em>example projects</em> and running the <em>integration test</em>. The last two involve generating actual service client code and building them - but only the few that are necessary, so it is not an issue to do that redundantly.</p>
<p>The real <code>.travis.yml</code> file is then generated by running a task <em>manually</em>, <code>sbt generateTravisYaml</code>. It is implemented in the <code>zio-aws-codegen</code> plugin and it loads the <code>.travis.base.yml</code> file and extends the <code>env</code> section with a set of <code>COMMANDS</code> variants, each compiling a subset of the generated subprojects.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Travis CI can now build <code>zio-aws</code> and run its integration tests. A build runs for hours, but it is stable, and consists of 22 parallel jobs to build all the libraries for both Scala 2.12 and 2.13. At the same time, developing the code generator and the other subprojects and tests became really convenient.</p>
]]></summary>
</entry>
<entry>
    <title>prox part 4 - simplified redesign</title>
    <link href="http://vigoo.github.io/posts/2020-08-03-prox-4-simplify.html" />
    <id>http://vigoo.github.io/posts/2020-08-03-prox-4-simplify.html</id>
    <published>2020-08-03T00:00:00Z</published>
    <updated>2020-08-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on August  3, 2020
    
</div>

<h2 id="blog-post-series">Blog post series</h2>
<ul>
<li><a href="2019-02-10-prox-1-types.html">Part 1 - type level programming</a></li>
<li><a href="2019-03-07-prox-2-io-akkastreams.html">Part 2 - akka streams with cats effect</a></li>
<li><a href="2019-08-13-prox-3-zio.html">Part 3 - effect abstraction and ZIO</a></li>
<li><a href="2020-08-03-prox-4-simplify.html">Part 4 - simplified redesign</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>In <a href="2019-02-10-prox-1-types.html">Part 1</a> I described how the advanced type level programming techniques can be used to describe the execution of system processes. It was both a good playground to experiment with these and the result has been proven useful as we started to use it in more and more production systems and test environments at <a href="https://prezi.com">Prezi</a>.</p>
<p>On the other hand as I mentioned at the end of the first post, there is a tradeoff. These techniques made the original version of <em>prox</em> very hard to maintain and improve, and the error messages library users got by small mistakes were really hard to understand.</p>
<p>Last December (in 2019) I redesigned the library to be simpler and easier to use by making some compromises. Let’s discover how!</p>
<h2 id="a-single-process">A single process</h2>
<p>We start completely from scratch and try to design the library with the same functionality but with simplicity in mind. The code snippets shown here are not necessarily the final, current state of the traits and objects of the library, but some intermediate steps so we see the thought process.</p>
<p>First let’s focus on defining a <strong>single process</strong>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">trait</span> Process {</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">val</span> command: String</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">val</span> arguments: List[String]</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="kw">val</span> workingDirectory: Option[Path]</a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="kw">val</span> environmentVariables: Map[String, String]</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="kw">val</span> removedEnvironmentVariables: Set[String]    </a>
<a class="sourceLine" id="cb1-7" title="7">}</a></code></pre></div>
<p>Without deciding already how it will be implemented, we know we need these information to be able to launch the process alone. And how to execute it? Let’s separate it completely:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">trait</span> ProcessResult {</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">val</span> exitCode: ExitCode</a>
<a class="sourceLine" id="cb2-3" title="3">}</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">trait</span> ProcessRunner {</a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="kw">def</span> <span class="fu">start</span>(process: Process): Resource[IO, Fiber[IO, ProcessResult]]</a>
<a class="sourceLine" id="cb2-7" title="7">}</a></code></pre></div>
<p>I decided that better integration with the IO library (<a href="https://typelevel.org/cats-effect/">cats-effect</a> in this case) is also a goal of the redesign, so for starter modelled the <em>running process</em> as a cancellable fiber resulting in <code>ProcessResult</code>, where cancellation means <strong>terminating</strong> the process. At this stage of the redesign I worked directly with <code>IO</code> instead of the <em>IO typeclasses</em> and later replaced it like I described in <a href="2019-08-13-prox-3-zio.html">the previous post</a>.</p>
<p>Let’s see how a simple runner implementation would look like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> java.<span class="fu">lang</span>.{Process =&gt; JvmProcess}</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">class</span> <span class="fu">JVMProcessRunner</span>(<span class="kw">implicit</span> contextShift: ContextShift[IO]) <span class="kw">extends</span> ProcessRunner {</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="kw">import</span> JVMProcessRunner._</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">start</span>(process: Process): Resource[IO, Fiber[IO, ProcessResult]] = {</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">val</span> builder = <span class="fu">withEnvironmentVariables</span>(process,</a>
<a class="sourceLine" id="cb3-8" title="8">      <span class="fu">withWorkingDirectory</span>(process,</a>
<a class="sourceLine" id="cb3-9" title="9">        <span class="kw">new</span> ProcessBuilder((process.<span class="fu">command</span> :: process.<span class="fu">arguments</span>).<span class="fu">asJava</span>)))</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="kw">val</span> start = IO.<span class="fu">delay</span>(<span class="kw">new</span> <span class="fu">JVMRunningProcess</span>(builder.<span class="fu">start</span>())).<span class="fu">bracketCase</span> { runningProcess =&gt;</a>
<a class="sourceLine" id="cb3-12" title="12">      runningProcess.<span class="fu">waitForExit</span>()</a>
<a class="sourceLine" id="cb3-13" title="13">    } {</a>
<a class="sourceLine" id="cb3-14" title="14">      <span class="kw">case</span> (_, Completed) =&gt;</a>
<a class="sourceLine" id="cb3-15" title="15">        IO.<span class="fu">unit</span></a>
<a class="sourceLine" id="cb3-16" title="16">      <span class="kw">case</span> (_, Error(reason)) =&gt;</a>
<a class="sourceLine" id="cb3-17" title="17">        IO.<span class="fu">raiseError</span>(reason)</a>
<a class="sourceLine" id="cb3-18" title="18">      <span class="kw">case</span> (runningProcess, Canceled) =&gt;</a>
<a class="sourceLine" id="cb3-19" title="19">        runningProcess.<span class="fu">terminate</span>() &gt;&gt; IO.<span class="fu">unit</span></a>
<a class="sourceLine" id="cb3-20" title="20">    }.<span class="fu">start</span></a>
<a class="sourceLine" id="cb3-21" title="21"></a>
<a class="sourceLine" id="cb3-22" title="22">    Resource.<span class="fu">make</span>(start)(_.<span class="fu">cancel</span>)</a>
<a class="sourceLine" id="cb3-23" title="23">  }</a>
<a class="sourceLine" id="cb3-24" title="24">}</a></code></pre></div>
<p>Here <code>withEnvironmentVariables</code> and <code>withWorkingDirectories</code> are just helper functions around the JVM <em>process builder</em>. The more important part is the <em>cancelation</em> and that we expose it as a <em>resource</em>.</p>
<p>First we wrap the started JVM process in a <code>JVMRunningProcess</code> class which really just wraps some of it’s operations in IO operations:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">SimpleProcessResult</span>(<span class="kw">override</span> <span class="kw">val</span> exitCode: ExitCode)</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">extends</span> ProcessResult</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">class</span> <span class="fu">JVMRunningProcess</span>(<span class="kw">val</span> nativeProcess: JvmProcess) <span class="kw">extends</span> RunningProcess {</a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="kw">override</span> <span class="kw">def</span> isAlive: IO[Boolean] = IO.<span class="fu">delay</span>(nativeProcess.<span class="fu">isAlive</span>)</a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">kill</span>(): IO[ProcessResult] = IO.<span class="fu">delay</span>(nativeProcess.<span class="fu">destroyForcibly</span>()) &gt;&gt; <span class="fu">waitForExit</span>()</a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">terminate</span>(): IO[ProcessResult] = IO.<span class="fu">delay</span>(nativeProcess.<span class="fu">destroy</span>()) &gt;&gt; <span class="fu">waitForExit</span>()</a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">waitForExit</span>(): IO[ProcessResult] =</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb4-10" title="10">      exitCode &lt;- IO.<span class="fu">delay</span>(nativeProcess.<span class="fu">waitFor</span>())</a>
<a class="sourceLine" id="cb4-11" title="11">    } <span class="kw">yield</span> <span class="fu">SimpleProcessResult</span>(<span class="fu">ExitCode</span>(exitCode))</a>
<a class="sourceLine" id="cb4-12" title="12">}</a></code></pre></div>
<p>Then we wrap the <em>starting of the process</em> with <code>bracketCase</code>, specifying the two cases:</p>
<ul>
<li>On normal execution, we <code>waitForExit</code> for the process to stop and create the <code>ProcessResult</code> as the result of the bracketed IO operation.</li>
<li>In the release case, if JVM thrown an exception it is raised to the IO level</li>
<li>And if it got <em>canceled</em>, we <code>terminate</code> the process</li>
</ul>
<p>This way the IO cancelation interface gets a simple way to wait for or terminate an executed process. By calling <code>.start</code> on this bracketed IO operation we move it to a concurrent <em>fiber</em>.</p>
<p>Finally we wrap it in a <code>Resource</code>, so if the user code starting the process got canceled, it <em>releases the resource</em> too that ends up <em>terminating</em> the process, leaving no process leaks. This is something that was missing from the earlier versions of the library.</p>
<p>To make starting processes more convenient we can create an <strong>extension method</strong> on the <code>Process</code> trait:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">implicit</span> <span class="kw">class</span> <span class="fu">ProcessOps</span>(<span class="kw">private</span> <span class="kw">val</span> process: Process) <span class="kw">extends</span> AnyVal {</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="kw">def</span> <span class="fu">start</span>(<span class="kw">implicit</span> runner: ProcessRunner): Resource[IO, Fiber[IO, ProcessResult]] =</a>
<a class="sourceLine" id="cb5-3" title="3">    runner.<span class="fu">start</span>(process)</a>
<a class="sourceLine" id="cb5-4" title="4">}</a></code></pre></div>
<h2 id="redirection">Redirection</h2>
<p>The next step was to implement input/output/error <em>redirection</em>. In the original <em>prox</em> library we had two important features, both implemented with type level techniques:</p>
<ul>
<li>Allow redirection only once per channel</li>
<li>The redirection source or target was a type class with <em>dependent result types</em></li>
</ul>
<p>To keep the type signatures simpler I decided to work around these by sacrificing some genericity and terseness. Let’s start by defining an interface for <strong>redirecting process output</strong>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">trait</span> RedirectableOutput[+P[_] &lt;: Process[_]] {</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="kw">def</span> connectOutput[R &lt;: OutputRedirection, O](target: R)(<span class="kw">implicit</span> outputRedirectionType: OutputRedirectionType.<span class="fu">Aux</span>[R, O]): P[O]</a>
<a class="sourceLine" id="cb6-3" title="3">  </a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb6-5" title="5">}</a></code></pre></div>
<p>This is not <em>very</em> much different than the output redirection operator in the previous <em>prox</em> versions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">def</span> &gt;[F[_], To, NewOut, NewOutResult, Result &lt;: ProcessNode[_, _, _, Redirected, _]]</a>
<a class="sourceLine" id="cb7-2" title="2">    (to: To)</a>
<a class="sourceLine" id="cb7-3" title="3">    (<span class="kw">implicit</span></a>
<a class="sourceLine" id="cb7-4" title="4">     contextOf: ContextOf.<span class="fu">Aux</span>[PN, F],</a>
<a class="sourceLine" id="cb7-5" title="5">     target: CanBeProcessOutputTarget.<span class="fu">Aux</span>[F, To, NewOut, NewOutResult],</a>
<a class="sourceLine" id="cb7-6" title="6">     redirectOutput: RedirectOutput.<span class="fu">Aux</span>[F, PN, To, NewOut, NewOutResult, Result])</a></code></pre></div>
<p>One of the primary differences is that we don’t allow arbitrary targets just by requiring a <code>CanBeProcessOutput</code> type class. Instead we can only connect the output to a value of <code>OutputRedirection</code> which is an ADT:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">sealed</span> <span class="kw">trait</span> OutputRedirection</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">case</span> <span class="kw">object</span> StdOut <span class="kw">extends</span> OutputRedirection</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">OutputFile</span>(path: Path, append: Boolean) <span class="kw">extends</span> OutputRedirection</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">case</span> <span class="kw">class</span> OutputStream[O, +OR](pipe: Pipe[IO, Byte, O], runner: Stream[IO, O] =&gt; IO[OR], chunkSize: Int = <span class="dv">8192</span>) <span class="kw">extends</span> OutputRedirection</a></code></pre></div>
<p>We still need a type level calculation to extract the result type of the <code>OutputStream</code> case (which is the <code>OR</code> type parameter). This extracted by the following trait with the help of the <code>Aux</code> pattern:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">trait</span> OutputRedirectionType[R] {</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="kw">type</span> Out</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="kw">def</span> <span class="fu">runner</span>(of: R)(nativeProcess: JvmProcess, blocker: Blocker, contextShift: ContextShift[IO]): IO[Out]</a>
<a class="sourceLine" id="cb9-4" title="4">}</a></code></pre></div>
<p>The important difference from earlier versions of the library is that this remains completely an implementation detail. <code>OutputRedirectionType</code> is implemented for all three cases of the <code>OutputRedirection</code> type and <code>connectOutput</code> is not even used in the default use cases, only when implementing redirection for something custom.</p>
<p>Instead the <code>RedirectableOutput</code> trait itself defines a set of operators and named function versions for redirecting to different targets. With this we loose a general-purpose, type class managed way to redirect to <em>anything</em> but improve a lot on the usability of the library. All these functions are easily discoverable from the IDE and there would not be any weird implicit resolution errors.</p>
<p>Let’s see some examples of these functions:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">trait</span> RedirectableOutput[+P[_] &lt;: Process[_]] {</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="kw">def</span> &gt;(sink: Pipe[IO, Byte, Unit]): P[Unit] = <span class="fu">toSink</span>(sink)</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="kw">def</span> <span class="fu">toSink</span>(sink: Pipe[F, Byte, Unit]): P[Unit] = </a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="fu">connectOutput</span>(OutputStream(sink, (s: Stream[F, Unit]) =&gt; s.<span class="fu">compile</span>.<span class="fu">drain</span>))</a>
<a class="sourceLine" id="cb10-6" title="6">    </a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="kw">def</span> &gt;#[O: Monoid](pipe: Pipe[F, Byte, O]): P[O] = <span class="fu">toFoldMonoid</span>(pipe)</a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="kw">def</span> toFoldMonoid[O: Monoid](pipe: Pipe[F, Byte, O]): P[O] =</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="fu">connectOutput</span>(OutputStream(pipe, (s: Stream[F, O]) =&gt; s.<span class="fu">compile</span>.<span class="fu">foldMonoid</span>))</a>
<a class="sourceLine" id="cb10-10" title="10">    </a>
<a class="sourceLine" id="cb10-11" title="11">  <span class="kw">def</span> &gt;&gt;(path: Path): P[Unit] = <span class="fu">appendToFile</span>(path)</a>
<a class="sourceLine" id="cb10-12" title="12">  <span class="kw">def</span> <span class="fu">appendToFile</span>(path: Path): P[Unit] =</a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="fu">connectOutput</span>(OutputFile[F](path, append = <span class="kw">true</span>))    </a>
<a class="sourceLine" id="cb10-14" title="14">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb10-15" title="15">}</a></code></pre></div>
<p>All of them are just using the <code>connectOutput</code> function so implementations of the <code>RedirectableOutput</code> trait need to define that single function to get this capability.</p>
<p>Note that <code>connectOutput</code> has a return type of <code>P[O]</code> instead of being just <code>Process</code>. This is important for multiple reasons.</p>
<p>First, in order to actually <em>execute</em> the output streams, we need to store it somehow in the <code>Process</code> data type itself. For this reason we add a type parameter to the <code>Process</code> trait representing the <em>output type</em> and store the <em>output stream runner function</em> itself in it:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">trait</span> Process[O] {</a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="kw">val</span> outputRedirection: OutputRedirection</a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="kw">val</span> runOutputStream: (JvmProcess, Blocker, ContextShift[IO]) =&gt; IO[O]</a>
<a class="sourceLine" id="cb11-5" title="5">}</a></code></pre></div>
<p>Note that <code>runOutputStream</code> is actually the <code>OutputRedirectiontype.runner</code> function, got from the “hidden” type level operation and stored in the process data structure. With this, the <em>process runner</em> can be extended to pass the started JVM process to this function that sets up the redirection, and then store the result of type <code>O</code> in <code>ProcessResult[O]</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">override</span> <span class="kw">def</span> start[O](process: Process[O], blocker: Blocker): Resource[IO, Fiber[IO, ProcessResult[O]]] = {</a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="co">// ... process builder</span></a>
<a class="sourceLine" id="cb12-3" title="3">    </a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="kw">val</span> outputRedirect = process.<span class="fu">outputRedirection</span> <span class="kw">match</span> {</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="kw">case</span> StdOut =&gt; ProcessBuilder.<span class="fu">Redirect</span>.<span class="fu">INHERIT</span></a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="kw">case</span> <span class="fu">OutputFile</span>(path) =&gt; ProcessBuilder.<span class="fu">Redirect</span>.<span class="fu">to</span>(path.<span class="fu">toFile</span>)</a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="kw">case</span> OutputStream(_, _, _) =&gt; ProcessBuilder.<span class="fu">Redirect</span>.<span class="fu">PIPE</span></a>
<a class="sourceLine" id="cb12-8" title="8">  }</a>
<a class="sourceLine" id="cb12-9" title="9">  builder.<span class="fu">redirectOutput</span>(outputRedirect)</a>
<a class="sourceLine" id="cb12-10" title="10"></a>
<a class="sourceLine" id="cb12-11" title="11">  <span class="kw">val</span> startProcess = <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb12-12" title="12">    nativeProcess &lt;- IO.<span class="fu">delay</span>(builder.<span class="fu">start</span>())</a>
<a class="sourceLine" id="cb12-13" title="13">    runningOutput &lt;- process.<span class="fu">runOutputStream</span>(nativeProcess, blocker, contextShift).<span class="fu">start</span></a>
<a class="sourceLine" id="cb12-14" title="14">  } <span class="kw">yield</span> <span class="kw">new</span> <span class="fu">JVMRunningProcess</span>(nativeProcess, runningOutput)  </a>
<a class="sourceLine" id="cb12-15" title="15">  </a>
<a class="sourceLine" id="cb12-16" title="16">  <span class="co">// ... bracketCase, start, Resource.make</span></a>
<a class="sourceLine" id="cb12-17" title="17">}</a></code></pre></div>
<p>It is also important that this <code>RedirectableOutput</code> trait is not something all process has: it is a <strong>capability</strong>, and only processes with unbound output should implement it. This is the new encoding of fixing the three channels of a process. Instead of having three type parameters with <em>phantom types</em>, now we have a combination of capability traits mixed with the <code>Process</code> trait, constraining what kind of redirections we can do. As this is not something unbounded and have relatively small number of cases, I chose to implement the combinations by hand, designing it in a way to minimize the redundancy in these implementation classes. This means, in total <strong>8</strong> classes representing the combinations of bound input, output and error.</p>
<p>I will demonstrate this with a single example. The <code>Process</code> constructor now returns a type with everything unbound, represented by having all the redirection capability traits:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">object</span> Process {</a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="kw">def</span> <span class="fu">apply</span>(command: String, arguments: List[String] = List.<span class="fu">empty</span>): ProcessImpl =</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="fu">ProcessImpl</span>(</a>
<a class="sourceLine" id="cb13-4" title="4">      command,</a>
<a class="sourceLine" id="cb13-5" title="5">      arguments,</a>
<a class="sourceLine" id="cb13-6" title="6">      workingDirectory = None,</a>
<a class="sourceLine" id="cb13-7" title="7">      environmentVariables = Map.<span class="fu">empty</span>,</a>
<a class="sourceLine" id="cb13-8" title="8">      removedEnvironmentVariables = Set.<span class="fu">empty</span>,</a>
<a class="sourceLine" id="cb13-9" title="9">      </a>
<a class="sourceLine" id="cb13-10" title="10">      outputRedirection = StdOut,</a>
<a class="sourceLine" id="cb13-11" title="11">      runOutputStream = (_, _, _) =&gt; IO.<span class="fu">unit</span>,</a>
<a class="sourceLine" id="cb13-12" title="12">      errorRedirection = StdOut,</a>
<a class="sourceLine" id="cb13-13" title="13">      runErrorStream = (_, _, _) =&gt; IO.<span class="fu">unit</span>,</a>
<a class="sourceLine" id="cb13-14" title="14">      inputRedirection = StdIn</a>
<a class="sourceLine" id="cb13-15" title="15">    )</a>
<a class="sourceLine" id="cb13-16" title="16">    </a>
<a class="sourceLine" id="cb13-17" title="17">  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">ProcessImpl</span>(<span class="kw">override</span> <span class="kw">val</span> command: String,</a>
<a class="sourceLine" id="cb13-18" title="18">                         <span class="kw">override</span> <span class="kw">val</span> arguments: List[String],</a>
<a class="sourceLine" id="cb13-19" title="19">                         <span class="kw">override</span> <span class="kw">val</span> workingDirectory: Option[Path],</a>
<a class="sourceLine" id="cb13-20" title="20">                         <span class="kw">override</span> <span class="kw">val</span> environmentVariables: Map[String, String],</a>
<a class="sourceLine" id="cb13-21" title="21">                         <span class="kw">override</span> <span class="kw">val</span> removedEnvironmentVariables: Set[String],</a>
<a class="sourceLine" id="cb13-22" title="22">                         <span class="kw">override</span> <span class="kw">val</span> outputRedirection: OutputRedirection[F],</a>
<a class="sourceLine" id="cb13-23" title="23">                         <span class="kw">override</span> <span class="kw">val</span> runOutputStream: (java.<span class="fu">io</span>.<span class="fu">InputStream</span>, Blocker, ContextShift[F]) =&gt; F[Unit],</a>
<a class="sourceLine" id="cb13-24" title="24">                         <span class="kw">override</span> <span class="kw">val</span> errorRedirection: OutputRedirection[F],</a>
<a class="sourceLine" id="cb13-25" title="25">                         <span class="kw">override</span> <span class="kw">val</span> runErrorStream: (java.<span class="fu">io</span>.<span class="fu">InputStream</span>, Blocker, ContextShift[F]) =&gt; F[Unit],</a>
<a class="sourceLine" id="cb13-26" title="26">                         <span class="kw">override</span> <span class="kw">val</span> inputRedirection: InputRedirection[F])</a>
<a class="sourceLine" id="cb13-27" title="27">    <span class="kw">extends</span> Process[Unit, Unit]</a>
<a class="sourceLine" id="cb13-28" title="28">      <span class="kw">with</span> RedirectableOutput[ProcessImplO[*]]</a>
<a class="sourceLine" id="cb13-29" title="29">      <span class="kw">with</span> RedirectableError[ProcessImplE[*]]</a>
<a class="sourceLine" id="cb13-30" title="30">      <span class="kw">with</span> RedirectableInput[ProcessImplI]] {</a>
<a class="sourceLine" id="cb13-31" title="31">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-32" title="32">    </a>
<a class="sourceLine" id="cb13-33" title="33">    <span class="kw">def</span> connectOutput[R &lt;: OutputRedirection, RO](target: R)(<span class="kw">implicit</span> outputRedirectionType: OutputRedirectionType.<span class="fu">Aux</span>[R, RO]): ProcessImplO[RO] =</a>
<a class="sourceLine" id="cb13-34" title="34">      <span class="fu">ProcessImplO</span>(</a>
<a class="sourceLine" id="cb13-35" title="35">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-36" title="36">        target,</a>
<a class="sourceLine" id="cb13-37" title="37">        outputRedirectionType.<span class="fu">runner</span>(target),</a>
<a class="sourceLine" id="cb13-38" title="38">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-39" title="39">      )</a>
<a class="sourceLine" id="cb13-40" title="40">  }</a>
<a class="sourceLine" id="cb13-41" title="41">    </a>
<a class="sourceLine" id="cb13-42" title="42">  <span class="kw">case</span> <span class="kw">class</span> ProcessImplO[O](<span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-43" title="43">                             <span class="kw">override</span> <span class="kw">val</span> runOutputStream: (java.<span class="fu">io</span>.<span class="fu">InputStream</span>, Blocker, ContextShift[F]) =&gt; F[O],</a>
<a class="sourceLine" id="cb13-44" title="44">                             <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-45" title="45">                            )</a>
<a class="sourceLine" id="cb13-46" title="46">    <span class="kw">extends</span> Process[O, Unit]</a>
<a class="sourceLine" id="cb13-47" title="47">      <span class="kw">with</span> RedirectableError[ProcessImplOE[O, *]]</a>
<a class="sourceLine" id="cb13-48" title="48">      <span class="kw">with</span> RedirectableInput[ProcessImplIO[O]] {    </a>
<a class="sourceLine" id="cb13-49" title="49">      <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-50" title="50">    }</a>
<a class="sourceLine" id="cb13-51" title="51">}</a></code></pre></div>
<p>Each implementation class only has the necessary subset of type parameters <code>O</code> and <code>E</code> (<code>E</code> is the error output type), and the <code>I</code> <code>O</code> and <code>E</code> postfixes in the class names represent which channels are <em>bound</em>. Each redirection leads to a different implementation class with less and less redirection <em>capabilities</em>. <code>ProcessImplIOE</code> is the fully bound process.</p>
<p>This makes all the redirection operators completely type inferable and very pleasant to use for building up concrete process definitions. And we don’t loose the ability to create generic function either. We can do it by requiring redirection capabilities:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">def</span> withInput[O, E, P &lt;: Process[O, E]](s: String)(process: Process[O, E] <span class="kw">with</span> RedirectableInput[P]): P = {</a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="kw">val</span> input = Stream(<span class="st">&quot;This is a test string&quot;</span>).<span class="fu">through</span>(text.<span class="fu">utf8Encode</span>)</a>
<a class="sourceLine" id="cb14-3" title="3">  process &lt; input</a>
<a class="sourceLine" id="cb14-4" title="4">}</a></code></pre></div>
<p>Here we know we want to have a <code>Process</code> with the <code>RedirectableInput</code> capability. We also know that by binding the input we get a something without that trait, so we know the result is a process <code>P</code> but know nothing else about its further capabilities. This is where this solution gets a bit inconvenient, if we want to chain these wrapper functions. To help with it, the library contains <em>type aliases</em> for the whole redirection capability chain that can be used in these functions. For example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" title="1"><span class="co">/**</span> Process with unbound input<span class="co">,</span> output and error streams <span class="co">*/</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">type</span> UnboundProcess = Process[Unit, Unit]</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="kw">with</span> RedirectableInput[UnboundOEProcess]</a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="kw">with</span> RedirectableOutput[UnboundIEProcess[*]]</a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="kw">with</span> RedirectableError[UnboundIOProcess[*]]</a></code></pre></div>
<h2 id="process-piping">Process piping</h2>
<p>The other major feature beside redirection that <em>prox</em> had is <strong>piping processes together</strong>, meaning the first process’ output gets redirected to the second process’ input. Now that we have redesigned processes and redirection capabilities, we can try to implement this on top of them.</p>
<p>The idea is that when we construct a <em>process group</em> from a list of <code>Process</code> instances with the necessary redirection capabilities, this construction could set up the redirection and store the modified processes instead, then running them together. And it can reuse the <code>RedirectableOutput</code> and <code>RedirectableInput</code> capabilities to bind the first/last process!</p>
<p>Let’s again start by defining what we need for the <em>process group</em>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">trait</span> ProcessGroup[O, E] <span class="kw">extends</span> ProcessLike {</a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="kw">val</span> firstProcess: Process[Stream[IO, Byte], E]</a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="kw">val</span> innerProcesses: List[Process.<span class="fu">UnboundIProcess</span>[Stream[IO, Byte], E]]</a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="kw">val</span> lastProcess: Process.<span class="fu">UnboundIProcess</span>[O, E]</a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6">  <span class="kw">val</span> originalProcesses: List[Process[Unit, Unit]]</a>
<a class="sourceLine" id="cb16-7" title="7">}</a></code></pre></div>
<p><code>ProcessLike</code> is a common base trait for <code>Process</code> and <code>ProcessGroup</code>. By introducing it, we can change the <code>RedirectableOutput</code> trait’s self type bounds so it works for both processes and process groups.</p>
<p>A valid process group always have at least <strong>2</strong> processes and they get pre-configured during the construction of the group so when they get started, their channels can be joined. This means the group members can be split into three groups:</p>
<ul>
<li>The <strong>first process</strong> has it’s output redirected to a stream, but <em>running</em> the stream just returns the stream itself; this way it can be connected to the next process’s input</li>
<li>The <strong>inner processes</strong> are all having their output redirected in the same way, and it is also a <em>requirement</em> that these must have their <em>input channel</em> unbound. This is needed for the operation described above, when we plug the previous process’ output into the input</li>
<li>The <strong>last process</strong> can have its output freely redirected by the user, but it’s <em>input</em> must be unbound so the previous process can be plugged in</li>
</ul>
<p>We also store the <em>original</em> process values for reasons explained later.</p>
<p>So as we can see the piping has two stages:</p>
<ol type="1">
<li>First we prepare the processes by setting up their output to return an un-executed stream</li>
<li>And we need a process group specific start function into the <code>ProcessRunner</code> that plugs everything together</li>
</ol>
<p>The first step is performed by the <em>pipe operator</em> (<code>|</code>), which is defined on <code>Process</code> via an extension method to construct group of two processes, and on <code>ProcessGroupImpl</code> to add more. For simplicity the piping operator is currently not defined on the bound process group types. So it has to be first constructed, and then the redirection set up.</p>
<p>Let’s see the one that adds one more process to a group:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">def</span> <span class="fu">pipeInto</span>(other: Process.<span class="fu">UnboundProcess</span>,</a>
<a class="sourceLine" id="cb17-2" title="2">             channel: Pipe[IO, Byte, Byte]): ProcessGroupImpl = {</a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="kw">val</span> pl1 = lastProcess.<span class="fu">connectOutput</span>(OutputStream(channel, (stream: Stream[IO, Byte]) =&gt; IO.<span class="fu">pure</span>(stream)))</a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="fu">copy</span>(</a>
<a class="sourceLine" id="cb17-6" title="6">    innerProcesses = pl1 :: innerProcesses,</a>
<a class="sourceLine" id="cb17-7" title="7">    lastProcess = other,</a>
<a class="sourceLine" id="cb17-8" title="8">    originalProcesses = other :: originalProcesses</a>
<a class="sourceLine" id="cb17-9" title="9">  )</a>
<a class="sourceLine" id="cb17-10" title="10">}</a>
<a class="sourceLine" id="cb17-11" title="11"></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="kw">def</span> |(other: Process.<span class="fu">UnboundProcess</span>): ProcessGroupImpl = <span class="fu">pipeInto</span>(other, identity)</a></code></pre></div>
<p>Other than moving processes around in the <code>innerProcesses</code> and <code>lastProcess</code>, we also set up the <strong>previous last process</strong>’s output in the way I described:</p>
<ul>
<li>It gets redirected to a pipe which is by default <code>identity</code></li>
<li>And it’s <em>runner</em> instead of actually running the stream, just returns the stream definition</li>
</ul>
<p>This way we can write a process group specific start function into the <em>process runner</em>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">override</span> <span class="kw">def</span> startProcessGroup[O, E](processGroup: ProcessGroup[O, E], blocker: Blocker): IO[RunningProcessGroup[O, E]] =</a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb18-3" title="3">    first &lt;- <span class="fu">startProcess</span>(processGroup.<span class="fu">firstProcess</span>, blocker)</a>
<a class="sourceLine" id="cb18-4" title="4">    firstOutput &lt;- first.<span class="fu">runningOutput</span>.<span class="fu">join</span></a>
<a class="sourceLine" id="cb18-5" title="5">    innerResult &lt;- <span class="kw">if</span> (processGroup.<span class="fu">innerProcesses</span>.<span class="fu">isEmpty</span>) {</a>
<a class="sourceLine" id="cb18-6" title="6">      IO.<span class="fu">pure</span>((List.<span class="fu">empty</span>, firstOutput))</a>
<a class="sourceLine" id="cb18-7" title="7">    } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb18-8" title="8">      <span class="kw">val</span> inner = processGroup.<span class="fu">innerProcesses</span>.<span class="fu">reverse</span></a>
<a class="sourceLine" id="cb18-9" title="9">      <span class="fu">connectAndStartProcesses</span>(inner.<span class="fu">head</span>, firstOutput, inner.<span class="fu">tail</span>, blocker, List.<span class="fu">empty</span>)</a>
<a class="sourceLine" id="cb18-10" title="10">    }</a>
<a class="sourceLine" id="cb18-11" title="11">    (inner, lastInput) = innerResult</a>
<a class="sourceLine" id="cb18-12" title="12">    last &lt;- <span class="fu">startProcess</span>(processGroup.<span class="fu">lastProcess</span>.<span class="fu">connectInput</span>(InputStream(lastInput, flushChunks = <span class="kw">false</span>)), blocker)</a>
<a class="sourceLine" id="cb18-13" title="13">    runningProcesses = processGroup.<span class="fu">originalProcesses</span>.<span class="fu">reverse</span>.<span class="fu">zip</span>((first :: inner) :+ last).<span class="fu">toMap</span></a>
<a class="sourceLine" id="cb18-14" title="14">  } <span class="kw">yield</span> <span class="kw">new</span> JVMRunningProcessGroup[O, E](runningProcesses, last.<span class="fu">runningOutput</span>)</a></code></pre></div>
<p>where <code>connectAndStartProcesses</code> is a recursive function that does the same as we do with the first process:</p>
<ul>
<li>start it with the <code>startProcess</code> function (this is the same function we discussed in the first section, that starts <code>Process</code> values)</li>
<li>then “join” the output fiber; this completes immediately as it is not really running the output stream just returning it</li>
<li>we connect the <em>input</em> of the next process to the previous process’ output</li>
</ul>
<p>One thing we did not talk about yet is getting the <strong>results</strong> of a process group. This is where the old implementation again used some type level techniques and returned a <code>RunningProcess</code> value with specific per-process output and error types for each member of the group, as a <code>HList</code> (or converted to a <em>tuple</em>).</p>
<p>By making the library a bit more dynamic we can drop this part too. What is that we really want to do with a running process group?</p>
<ul>
<li><strong>Terminating</strong> the whole group together. Terminating just one part is something we does not support currently although it would not be hard to add.</li>
<li><strong>Waiting</strong> for all processes to stop</li>
<li>Examining the <strong>exit code</strong> for each member of the group</li>
<li>Redirecting the <strong>error</strong> channel of each process to something and getting them in the result</li>
<li>Redirecting the <strong>input</strong> of the group’s first process</li>
<li>Redirecting the <strong>output</strong> of the group’s last process, and getting it in the result</li>
</ul>
<p>The most difficult and primary reason for the <code>HList</code> in the old version is the error redirection, as it can be done <em>per process</em>. With some restrictions we can make a reasonable implementation though.</p>
<p>First, we require that the processes participating in forming a <em>process group</em> does not have their <em>error channel</em> bound yet. Then we create a <code>RedirectableErrors</code> capability that is very similar to the existing <code>RedirectableError</code> trait, but provides an advanced interface through it’s <code>customizedPerProcess</code> field:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">trait</span> RedirectableErrors[+P[_] &lt;: ProcessGroup[_, _]] {</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="kw">lazy</span> <span class="kw">val</span> customizedPerProcess: RedirectableErrors.<span class="fu">CustomizedPerProcess</span>[P] = <span class="co">// ...</span></a>
<a class="sourceLine" id="cb19-3" title="3">}</a></code></pre></div>
<p>where the <code>CustomizedPerProcess</code> interface contains the same redirection functions but accept a function of a <code>Process</code> as parameter.</p>
<p>For example:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">def</span> <span class="fu">errorsToSink</span>(sink: Pipe[IO, Byte, Unit]): P[Unit]</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="co">// vs</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="kw">def</span> <span class="fu">errorsToSink</span>(sinkFn: Process[_, _] =&gt; Pipe[IO, Byte, Unit]): P[Unit] =</a></code></pre></div>
<p>The limitation is that for all process we need to have the same <strong>error result type</strong> but it still gets a lot of freedom via the advanced interface: we can tag the output with the process and split their processing further in the stream.</p>
<p>With this choice, we can finally define the result type of the process group too:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">trait</span> ProcessGroupResult[+O, +E] {</a>
<a class="sourceLine" id="cb21-2" title="2">  <span class="kw">val</span> exitCodes: Map[Process[Unit, Unit], ExitCode]</a>
<a class="sourceLine" id="cb21-3" title="3">  <span class="kw">val</span> output: O</a>
<a class="sourceLine" id="cb21-4" title="4">  <span class="kw">val</span> errors: Map[Process[Unit, Unit], E]</a>
<a class="sourceLine" id="cb21-5" title="5">}</a></code></pre></div>
<p>The error results and the exit codes are in a map indexed by the <strong>original process</strong>. This is the value passed to the piping operator, the one that the user constructing the group has. That’s why in the <code>ProcessGroup</code> trait we also had to store the original process values.</p>
<p>As the output of all the inner processes are piped to the next process, we only have to care about the last process’ output.</p>
<h2 id="conclusion">Conclusion</h2>
<p>With a full redesign and making some compromises, we get a library that has a much more readable and easier to maintain code, and an API that is discoverable by the IDE and does not produce any weird error messages on misuse.</p>
<p>Note that in all the code snippets above I removed the <em>effect abstraction</em> and just used <code>IO</code> to make them simpler. The real code of course can be used with any IO library such as ZIO, just like the previous versions.</p>
]]></summary>
</entry>
<entry>
    <title>prox part 3 - effect abstraction and ZIO</title>
    <link href="http://vigoo.github.io/posts/2019-08-13-prox-3-zio.html" />
    <id>http://vigoo.github.io/posts/2019-08-13-prox-3-zio.html</id>
    <published>2019-08-13T00:00:00Z</published>
    <updated>2019-08-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on August 13, 2019
    
</div>

<h2 id="blog-post-series">Blog post series</h2>
<ul>
<li><a href="2019-02-10-prox-1-types.html">Part 1 - type level programming</a></li>
<li><a href="2019-03-07-prox-2-io-akkastreams.html">Part 2 - akka streams with cats effect</a></li>
<li><a href="2019-08-13-prox-3-zio.html">Part 3 - effect abstraction and ZIO</a></li>
<li><a href="2020-08-03-prox-4-simplify.html">Part 4 - simplified redesign</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>The <a href="2019-02-10-prox-1-types.html">first post</a> introduced the <em>prox library</em> and demonstrated the advanced type level programming techniques it uses. Then in the <a href="2019-03-07-prox-2-io-akkastreams.html">second part</a> of this series we experimented with replacing the <em>streaming library</em> from <a href="https://fs2.io/">fs2</a> to <a href="https://doc.akka.io/docs/akka/2.5/stream/">Akka Streams</a>.</p>
<p>In both cases the library used <a href="https://typelevel.org/cats-effect/">cats-effect</a> for describing side effects. But it did not really take advantage of <em>cats-effect</em>’s effect abstraction: it explicitly defined everything to be a computation in <a href="https://typelevel.org/cats-effect/datatypes/io.html"><code>IO</code></a>, cats-effect’s implementation of describing effectful computations.</p>
<p>But we can do better! By not relying on <code>IO</code> but the various type classes the <em>cats-effect</em> library provides we can make <em>prox</em> work with any kind of effect library out of the box. One such example is <a href="https://github.com/zio/zio">ZIO</a>.</p>
<h2 id="effect-abstraction">Effect abstraction</h2>
<p>Let’s see an example of how <code>IO</code> used to be used in the library! The following function is in the <code>Start</code> type class, and it starts a process or piped process group:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> <span class="fu">apply</span>(process: PN, dontStartOutput: Boolean = <span class="kw">false</span>, blocker: Blocker)</a>
<a class="sourceLine" id="cb1-2" title="2">         (<span class="kw">implicit</span> contextShift: ContextShift[IO]): IO[RunningProcesses]</a></code></pre></div>
<p>We can observe two things here:</p>
<ul>
<li>The function returns an effectful computation in <code>IO</code></li>
<li>An implicit <em>context shifter</em> is needed by the implementations which are calling some streaming functions needing it.</li>
</ul>
<p>To make it independent of the effect library implementation we have to get rid of <code>IO</code> and use a generic type instead, let’s call it <code>F</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> <span class="fu">apply</span>(process: PN, </a>
<a class="sourceLine" id="cb2-2" title="2">          dontStartOutput: Boolean = <span class="kw">false</span>, </a>
<a class="sourceLine" id="cb2-3" title="3">          blocker: Blocker)</a>
<a class="sourceLine" id="cb2-4" title="4">         (<span class="kw">implicit</span></a>
<a class="sourceLine" id="cb2-5" title="5">          concurrent: Concurrent[F],</a>
<a class="sourceLine" id="cb2-6" title="6">          contextShift: ContextShift[F]): F[RunningProcesses]</a></code></pre></div>
<p>Beside using <code>F</code> instead of <code>IO</code> everywhere we also have a new requirement, our context type (<code>F</code>) have to have an implementation of the <a href="https://typelevel.org/cats-effect/typeclasses/concurrent.html"><code>Concurrent</code></a> type class.</p>
<p><em>Cats-effect</em> defines a hierarchy of type classes to deal with effectful computations. At the time of writing it looks like this: <img src="https://typelevel.org/cats-effect/img/cats-effect-typeclasses.svg"/></p>
<p>Read the <a href="https://typelevel.org/cats-effect/typeclasses/">official documentation</a> for more information.</p>
<p>Prox is based on the <code>ProcessNode</code> type which has two implementations, a single <code>Process</code> or a set of processes piped together to a <code>PipedProcess</code>. Because these types store their I/O redirection within themselves, they also have to be enriched with a context type parameter.</p>
<p>For example <code>Process</code> will look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> Process[F[_], Out, Err, OutResult, ErrResult, IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState]</a>
<a class="sourceLine" id="cb3-2" title="2">(<span class="kw">val</span> command: String,</a>
<a class="sourceLine" id="cb3-3" title="3"> <span class="kw">val</span> arguments: List[String],</a>
<a class="sourceLine" id="cb3-4" title="4"> <span class="kw">val</span> workingDirectory: Option[Path],</a>
<a class="sourceLine" id="cb3-5" title="5"> <span class="kw">val</span> inputSource: ProcessInputSource[F],</a>
<a class="sourceLine" id="cb3-6" title="6"> <span class="kw">val</span> outputTarget: ProcessOutputTarget[F, Out, OutResult],</a>
<a class="sourceLine" id="cb3-7" title="7"> <span class="kw">val</span> errorTarget: ProcessErrorTarget[F, Err, ErrResult],</a>
<a class="sourceLine" id="cb3-8" title="8"> <span class="kw">val</span> environmentVariables: Map[String, String],</a>
<a class="sourceLine" id="cb3-9" title="9"> <span class="kw">val</span> removedEnvironmentVariables: Set[String])</a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="kw">extends</span> ProcessNode[Out, Err, IRS, ORS, ERS] {</a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb3-12" title="12">}</a></code></pre></div>
<p>The context parameter (<code>F</code>) is needed because the <em>input source</em> and <em>output target</em> are all representing effectful code such as writing to the standard output, reading from a file, or passing data through concurrent streams.</p>
<p>Let’s see some examples of how the abstract types of <em>cats-effect</em> can be used to describe the computation, when we cannot rely on <code>IO</code> itself!</p>
<p>The most basic operation is to <em>delay the execution</em> of some code that does not use the effect abstractions. This is how we wrap the Java process API, for example.</p>
<p>While with the original implementation of <em>prox</em> it was done by using the <code>IO</code> constructor:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1">IO {</a>
<a class="sourceLine" id="cb4-2" title="2">    systemProcess.<span class="fu">isAlive</span></a>
<a class="sourceLine" id="cb4-3" title="3">}</a></code></pre></div>
<p>with an arbitrary <code>F</code> we only need to require that it has an implementation of the <code>Sync</code> type class:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">private</span> <span class="kw">class</span> WrappedProcess[F[_] : Sync,  <span class="co">// ...</span></a></code></pre></div>
<p>and then use the <code>delay</code> function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1">Sync[F].<span class="fu">delay</span> {</a>
<a class="sourceLine" id="cb6-2" title="2">    systemProcess.<span class="fu">isAlive</span></a>
<a class="sourceLine" id="cb6-3" title="3">}</a></code></pre></div>
<p>Similarily the <code>Concurrent</code> type class can be used to start a concurrent computation on a <em>fiber</em>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1">Concurrent[F].<span class="fu">start</span>(stream.<span class="fu">compile</span>.<span class="fu">toVector</span>)</a></code></pre></div>
<h2 id="type-level">Type level</h2>
<p>This would be it - except that we need one more thing because of the type level techniques described in the <a href="2019-02-10-prox-1-types.html">first post</a>.</p>
<p>To understand the problem, let’s see how the <em>output redirection</em> operator works. It is implemented as an <em>extension method</em> on the <code>ProcessNode</code> type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">implicit</span> <span class="kw">class</span> ProcessNodeOutputRedirect[PN &lt;: ProcessNode[_, _, _, NotRedirected, _]](processNode: PN) {</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">def</span> &gt;[F[_], To, NewOut, NewOutResult, Result &lt;: ProcessNode[_, _, _, Redirected, _]]</a>
<a class="sourceLine" id="cb8-3" title="3">    (to: To)</a>
<a class="sourceLine" id="cb8-4" title="4">    (<span class="kw">implicit</span></a>
<a class="sourceLine" id="cb8-5" title="5">     target: CanBeProcessOutputTarget.<span class="fu">Aux</span>[F, To, NewOut, NewOutResult],</a>
<a class="sourceLine" id="cb8-6" title="6">     redirectOutput: RedirectOutput.<span class="fu">Aux</span>[F, PN, To, NewOut, NewOutResult, Result]): Result = {</a>
<a class="sourceLine" id="cb8-7" title="7">      <span class="fu">redirectOutput</span>(processNode, to)</a>
<a class="sourceLine" id="cb8-8" title="8">    }</a>
<a class="sourceLine" id="cb8-9" title="9">}</a></code></pre></div>
<p>This extension method basically just finds the appropriate type class implementations and then call it to alter the process node to register the output redirection:</p>
<ul>
<li>we are redirecting the output of <code>processNode</code> (of type <code>PN</code>) to <code>to</code> (of type <code>To</code>)</li>
<li><code>target</code> is the <code>CanBeProcessOutputTarget</code> implementation, containing the actual code to set up the redirection</li>
<li><code>redirectOutput</code> is the process node type specific implementation of the <code>RedirectOutput</code> interface, knowing how to set up the redirection of a <code>Process</code> or a <code>PipedProcess</code></li>
</ul>
<p>This code would compile, but we won’t be able to use it. For example for the following code:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" title="1">running &lt;- (Process[IO](<span class="st">&quot;echo&quot;</span>, List(<span class="st">&quot;Hello world!&quot;</span>)) &gt; tempFile.<span class="fu">toPath</span>).<span class="fu">start</span>(blocker)</a></code></pre></div>
<p>It fails with not being able to resolve the implicits correctly. The exact error of course depends much on the context but one example for the above line could be:</p>
<pre><code>[error] prox/src/test/scala/io/github/vigoo/prox/ProcessSpecs.scala:95:63: diverging implicit expansion for type cats.effect.Concurrent[F]
[error] starting with method catsIorTConcurrent in object Concurrent
[error]         running &lt;- (Process[IO](&quot;echo&quot;, List(&quot;Hello world!&quot;)) &gt; tempFile.toPath).start(blocker)</code></pre>
<p>This does not really help understanding the real problem though. As we have seen earlier, in this library the <code>Process</code> types have to be parameterized with the context as well, because they store their redirection logic within themselves. That’s why we specify it explicitly in the example to be <code>IO</code>: <code>Process[IO](...)</code>. What we would expect is that by tying <code>F[_]</code> to <code>IO</code> at the beginning, all the subsequent operations such as the <code>&gt;</code> redirection would respect this and the context gets inferred to be <code>IO</code> everywhere in the expression.</p>
<p>The compiler cannot do this. If we check the definition of <code>&gt;</code> again, you can see that there is no connection expressed between the type <code>PN</code> (the actual process node type) and <code>F</code> which is used as a type parameter for the implicit parameters.</p>
<p>The fix is to link the two, and we have a technique exactly for this that I described earlier: the <em>aux pattern</em>.</p>
<p>First let’s write some code that, in compile time, can “extract” the context type from a process node type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">trait</span> ContextOf[PN] {</a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="kw">type</span> Context[_]</a>
<a class="sourceLine" id="cb11-3" title="3">}</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">object</span> ContextOf {</a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="kw">type</span> Aux[PN, F[_]] = ContextOf[PN] {</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="kw">type</span> Context[_] = F[_]</a>
<a class="sourceLine" id="cb11-8" title="8">  }</a>
<a class="sourceLine" id="cb11-9" title="9"></a>
<a class="sourceLine" id="cb11-10" title="10">  <span class="kw">def</span> apply[PN &lt;: ProcessNode[_, _, _, _, _], F[_]](<span class="kw">implicit</span> contextOf: ContextOf.<span class="fu">Aux</span>[PN, F]): Aux[PN, F] = contextOf</a>
<a class="sourceLine" id="cb11-11" title="11"></a>
<a class="sourceLine" id="cb11-12" title="12">  <span class="kw">implicit</span> <span class="kw">def</span> contextOfProcess[F[_], Out, Err, OutResult, ErrResult, IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState]:</a>
<a class="sourceLine" id="cb11-13" title="13">  Aux[Process[F, Out, Err, OutResult, ErrResult, IRS, ORS, ERS], F] =</a>
<a class="sourceLine" id="cb11-14" title="14">    <span class="kw">new</span> ContextOf[Process[F, Out, Err, OutResult, ErrResult, IRS, ORS, ERS]] {</a>
<a class="sourceLine" id="cb11-15" title="15">      <span class="kw">override</span> <span class="kw">type</span> Context[_] = F[_]</a>
<a class="sourceLine" id="cb11-16" title="16">    }</a>
<a class="sourceLine" id="cb11-17" title="17"></a>
<a class="sourceLine" id="cb11-18" title="18">  <span class="kw">implicit</span> <span class="kw">def</span> contextOfPipedProcess[</a>
<a class="sourceLine" id="cb11-19" title="19">  F[_],</a>
<a class="sourceLine" id="cb11-20" title="20">  Out, Err,</a>
<a class="sourceLine" id="cb11-21" title="21">  PN1 &lt;: ProcessNode[_, _, _, _, _],</a>
<a class="sourceLine" id="cb11-22" title="22">  PN2 &lt;: ProcessNode[_, _, _, _, _],</a>
<a class="sourceLine" id="cb11-23" title="23">  IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState]:</a>
<a class="sourceLine" id="cb11-24" title="24">  Aux[PipedProcess[F, Out, Err, Byte, PN1, PN2, IRS, ORS, ERS], F] =</a>
<a class="sourceLine" id="cb11-25" title="25">    <span class="kw">new</span> ContextOf[PipedProcess[F, Out, Err, Byte, PN1, PN2, IRS, ORS, ERS]] {</a>
<a class="sourceLine" id="cb11-26" title="26">      <span class="kw">override</span> <span class="kw">type</span> Context[_] = F[_]</a>
<a class="sourceLine" id="cb11-27" title="27">    }</a>
<a class="sourceLine" id="cb11-28" title="28">}</a></code></pre></div>
<p>Both <code>Process</code> and <code>PipedProcess</code> have the context as their first type parameter. By creating the <code>ContextOf</code> type class and the corresponding <code>Aux</code> type we can extend the <code>&gt;</code> operator to <em>require</em> such a connection (a way to get a <code>F[_]</code> context out of a type <code>PN</code>) in compile time, and with the aux pattern it unifies the type parameters and the context type gets <em>chained</em> through all the subsequent calls as we desired:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">def</span> &gt;[F[_], To, NewOut, NewOutResult, Result &lt;: ProcessNode[_, _, _, Redirected, _]]</a>
<a class="sourceLine" id="cb12-2" title="2">    (to: To)</a>
<a class="sourceLine" id="cb12-3" title="3">    (<span class="kw">implicit</span></a>
<a class="sourceLine" id="cb12-4" title="4">     contextOf: ContextOf.<span class="fu">Aux</span>[PN, F],</a>
<a class="sourceLine" id="cb12-5" title="5">     target: CanBeProcessOutputTarget.<span class="fu">Aux</span>[F, To, NewOut, NewOutResult],</a>
<a class="sourceLine" id="cb12-6" title="6">     redirectOutput: RedirectOutput.<span class="fu">Aux</span>[F, PN, To, NewOut, NewOutResult, Result]): Result = {</a>
<a class="sourceLine" id="cb12-7" title="7">      <span class="fu">redirectOutput</span>(processNode, to)</a>
<a class="sourceLine" id="cb12-8" title="8">    }</a></code></pre></div>
<h2 id="zio">ZIO</h2>
<p>Now that everything is in place, we can try out whether <em>prox</em> is really working with other effect libraries such as <a href="https://github.com/zio/zio">ZIO</a>.</p>
<p><em>ZIO</em> has a compatibility layer for <em>cats-effect</em>. It’s the implementation of the type classes cats-effect provides. It is in an extra library called <a href="https://github.com/zio/interop-cats">zio-interop-cats</a>.</p>
<p>For running processes with <em>prox</em> we can use the following variants of the <code>ZIO</code> type:</p>
<ul>
<li><code>RIO[-R, +A]</code> which is an alias for <code>ZIO[R, scala.Throwable, A]</code></li>
<li>or <code>Task[A]</code> which is an alias for <code>ZIO[scala.Any, scala.Throwable, A]</code> if we don’t take advantage of the environment parameter <code>R</code>.</li>
</ul>
<p>This in fact assuming the correct context only means switching <code>IO</code> to <code>RIO</code> or <code>Task</code> in the type parameter for <code>Process</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">import</span> zio.<span class="fu">interop</span>.<span class="fu">catz</span>._</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3">Blocker[RIO[Console, ?]].<span class="fu">use</span> { blocker =&gt;</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb13-5" title="5">      <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-6" title="6">      _ &lt;- console.<span class="fu">putStrLn</span>(<span class="st">&quot;Starting external process...&quot;</span>)</a>
<a class="sourceLine" id="cb13-7" title="7">      _ &lt;- (Process[Task](<span class="st">&quot;echo&quot;</span>, List(<span class="st">&quot;Hello world!&quot;</span>)) &gt; tempFile.<span class="fu">toPath</span>).<span class="fu">start</span>(blocker)</a>
<a class="sourceLine" id="cb13-8" title="8">      <span class="co">// ...</span></a>
<a class="sourceLine" id="cb13-9" title="9">  } <span class="kw">yield</span> ()</a>
<a class="sourceLine" id="cb13-10" title="10">}</a></code></pre></div>
<p>A nice way to have everything set up for this is to use the interop library’s <a href="https://zio.dev/docs/interop/interop_catseffect#cats-app"><code>CatsApp</code></a> trait as an entrypoint for the application.</p>
<p>This brings all the necessary implicits in scope and requires you to implement the following function as the entry point of the application:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">def</span> <span class="fu">run</span>(args: List[String]): ZIO[Environment, Nothing, Int]</a></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>prox part 2 - akka streams with cats effect</title>
    <link href="http://vigoo.github.io/posts/2019-03-07-prox-2-io-akkastreams.html" />
    <id>http://vigoo.github.io/posts/2019-03-07-prox-2-io-akkastreams.html</id>
    <published>2019-03-07T00:00:00Z</published>
    <updated>2019-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March  7, 2019
    
</div>

<h2 id="blog-post-series">Blog post series</h2>
<ul>
<li><a href="2019-02-10-prox-1-types.html">Part 1 - type level programming</a></li>
<li><a href="2019-03-07-prox-2-io-akkastreams.html">Part 2 - akka streams with cats effect</a></li>
<li><a href="2019-08-13-prox-3-zio.html">Part 3 - effect abstraction and ZIO</a></li>
<li><a href="2020-08-03-prox-4-simplify.html">Part 4 - simplified redesign</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>In the previous post we have seen how <a href="https://github.com/vigoo/prox">prox</a> applies advanced type level programming techniques to express executing external system processes. The input and output of these processes can be connected to <strong>streams</strong>. The current version of <a href="https://github.com/vigoo/prox">prox</a> uses the <a href="https://fs2.io/">fs2</a> library to describe these streams, and <a href="https://typelevel.org/cats-effect/">cats-effect</a> as an <strong>IO</strong> abstraction, allowing it to separate the specification of a process pipeline from its actual execution.</p>
<p>In this post we will keep <a href="https://typelevel.org/cats-effect/">cats-effect</a> but replace <a href="https://fs2.io/">fs2</a> with the stream library of the Akka toolkit, <a href="https://doc.akka.io/docs/akka/2.5/stream/">Akka Streams</a>. This will be a hybrid solution, as Akka Streams is not using any kind of IO abstraction, unlike <a href="https://fs2.io/">fs2</a> which is implemented on top of <a href="https://typelevel.org/cats-effect/">cats-effect</a>. We will experiment with implementing <a href="https://github.com/vigoo/prox">prox</a> purely with the <em>Akka</em> libraries in a future post.</p>
<h2 id="replacing-fs2-with-akka-streams">Replacing fs2 with Akka Streams</h2>
<p>We start by removing the <a href="https://fs2.io/">fs2</a> dependency and adding <em>Akka Streams</em>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1">- <span class="st">&quot;co.fs2&quot;</span> %% <span class="st">&quot;fs2-core&quot;</span> % <span class="st">&quot;1.0.3&quot;</span>,</a>
<a class="sourceLine" id="cb1-2" title="2">- <span class="st">&quot;co.fs2&quot;</span> %% <span class="st">&quot;fs2-io&quot;</span> % <span class="st">&quot;1.0.3&quot;</span>,</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">+ <span class="st">&quot;com.typesafe.akka&quot;</span> %% <span class="st">&quot;akka-stream&quot;</span> % <span class="st">&quot;2.5.20&quot;</span>,</a></code></pre></div>
<p>Then we have to change all the <em>fs2</em> types used in the codebase to the matching <em>Akka Streams</em> types. The following table describe these pairs:</p>
<table>
<thead>
<tr class="header">
<th>fs2</th>
<th>Akka Streams</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Stream[IO, O]</code></td>
<td><code>Source[O, Any]</code></td>
</tr>
<tr class="even">
<td><code>Pipe[IO, I, O]</code></td>
<td><code>Flow[I, O, Any]</code></td>
</tr>
<tr class="odd">
<td><code>Sink[IO, O]</code></td>
<td><code>Sink[O, Future[Done]</code></td>
</tr>
</tbody>
</table>
<p>Another small difference that requires changing a lot of our functions is the <em>implicit context</em> these streaming solutions require.</p>
<p>With the original implementation it used to be:</p>
<ul>
<li>an implicit <code>ContextShift[IO]</code> instance</li>
<li>and an explicitly passed <em>blocking execution context</em> of type <code>ExecutionContext</code></li>
</ul>
<p>We can treat the blocking execution context as part of the implicit context for <em>prox</em> too, and could refactor the library to pass both of them wrapped together within a context object.</p>
<p>Let’s see what we need for the <em>Akka Streams</em> based implementation!</p>
<ul>
<li>an implicit <code>ContextShift[IO]</code> is <em>still needed</em> because we are still using <code>cats-effect</code> as our IO abstraction</li>
<li>The blocking execution context however was only used for passing it to <em>fs2</em>, so we can remove that</li>
<li>And for <em>Akka Streams</em> we will need an execution context of type <code>ExecutionContext</code> and also a <code>Materializer</code>. The materializer is used by <em>Akka Streams</em> to execute blueprints of streams. The usual implementation is <code>ActorMaterializer</code> which does that by spawning actors implementing the stream graph.</li>
</ul>
<p>So for example the <code>start</code> extension method, is modified like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1">- <span class="kw">def</span> start[RP](blockingExecutionContext: ExecutionContext)</a>
<a class="sourceLine" id="cb2-2" title="2">               (<span class="kw">implicit</span> start: Start.<span class="fu">Aux</span>[PN, RP, _], </a>
<a class="sourceLine" id="cb2-3" title="3">                contextShift: ContextShift[IO]): IO[RP]</a>
<a class="sourceLine" id="cb2-4" title="4">+ <span class="kw">def</span> start[RP]()</a>
<a class="sourceLine" id="cb2-5" title="5">               (<span class="kw">implicit</span> start: Start.<span class="fu">Aux</span>[PN, RP, _],</a>
<a class="sourceLine" id="cb2-6" title="6">                contextShift: ContextShift[IO],</a>
<a class="sourceLine" id="cb2-7" title="7">                materializer: Materializer,</a>
<a class="sourceLine" id="cb2-8" title="8">                executionContext: ExecutionContext): IO[RP]</a></code></pre></div>
<p>It turns out that there is one more minor difference that needs changes in the internal type signatures.</p>
<p>In <em>Akka Streams</em> byte streams are represented by not streams of element type <code>Byte</code>. like in <em>fs2</em>, but streams of <em>chunks</em> called <code>ByteString</code>s. So everywhere we used <code>Byte</code> as element type, such as on the process boundaries, we now simply have to use <code>ByteStrings</code>, for example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1">- <span class="kw">def</span> <span class="fu">apply</span>(from: PN1, to: PN2, via: Pipe[IO, Byte, Byte]): ResultProcess </a>
<a class="sourceLine" id="cb3-2" title="2">+ <span class="kw">def</span> <span class="fu">apply</span>(from: PN1, to: PN2, via: Flow[ByteString, ByteString, Any]): ResultProcess </a></code></pre></div>
<p>Another thing to notice is that <em>fs2</em> had a type parameter for passing the <code>IO</code> monad to run on. As I wrote earlier, <em>Akka Streams</em> does not depend on such abstractions, so this parameter is missing. On the other hand, it has a third type parameter which is set in the above example to <code>Any</code>. This parameter is called <code>Mat</code> and represents the type of the value the flow will materialize to. At this point we don’t care about it so we set it to <code>Any</code>.</p>
<p>Let’s take a look of the <code>connect</code> function of the <code>ProcessIO</code> trait. With <em>fs2</em> the <code>InputStreamingSource</code> is implemented like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> <span class="fu">InputStreamingSource</span>(source: Source[ByteString, Any]) <span class="kw">extends</span> ProcessInputSource {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">override</span> <span class="kw">def</span> toRedirect: Redirect = Redirect.<span class="fu">PIPE</span></a>
<a class="sourceLine" id="cb4-3" title="3">    </a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">connect</span>(systemProcess: lang.<span class="fu">Process</span>, blockingExecutionContext: ExecutionContext)</a>
<a class="sourceLine" id="cb4-5" title="5">                        (<span class="kw">implicit</span> contextShift: ContextShift[IO]): Stream[IO, Byte] = {</a>
<a class="sourceLine" id="cb4-6" title="6">        source.<span class="fu">observe</span>(</a>
<a class="sourceLine" id="cb4-7" title="7">            io.<span class="fu">writeOutputStream</span>[IO](</a>
<a class="sourceLine" id="cb4-8" title="8">                IO { systemProcess.<span class="fu">getOutputStream</span> },</a>
<a class="sourceLine" id="cb4-9" title="9">                closeAfterUse = <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb4-10" title="10">                blockingExecutionContext = blockingExecutionContext))</a>
<a class="sourceLine" id="cb4-11" title="11">    }</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">run</span>(stream: Stream[IO, Byte])(<span class="kw">implicit</span> contextShift: ContextShift[IO]): IO[Fiber[IO, Unit]] =</a>
<a class="sourceLine" id="cb4-14" title="14">        Concurrent[IO].<span class="fu">start</span>(stream.<span class="fu">compile</span>.<span class="fu">drain</span>) </a>
<a class="sourceLine" id="cb4-15" title="15">}</a></code></pre></div>
<p>We have a <code>source</code> stream and during the setup of the process graph, when the system process has been already created, we have to set up the redirection of this source stream to this process. This is separated to a <code>connect</code> and a <code>run</code> step:</p>
<ul>
<li>The <code>connect</code> step creates an <em>fs2 stream</em> that observers the source stream and sends each byte to the system process’s standard input. This just <strong>defines</strong> this stream, and returns it as a pure functional value.</li>
<li>The <code>run</code> step on the other hand has the result type <code>IO[Fiber[IO, Unit]]</code>. It <strong>defines</strong> the effect of starting a new thread and running the stream on it.</li>
</ul>
<p>In the case of <em>fs2</em> we can be sure that the <code>source.observe</code> function is pure just by checking it’s type signature:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">def</span> <span class="fu">observe</span>(p: Pipe[F, O, Unit])(<span class="kw">implicit</span> F: Concurrent[F]): Stream[F, O]</a></code></pre></div>
<p>All side-effecting functions in <em>fs2</em> are defined as <code>IO</code> functions, so we simply know that this one is not among them, and that’s why the <code>connect</code> was a pure, non-<code>IO</code> function in the original implementation. With <em>Akka Streams</em> we don’t have any information about this encoded in the type system. We use the <code>source.alsoTo</code> function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">def</span> <span class="fu">alsoTo</span>(that: Graph[SinkShape[Out], _]): Repr[Out]</a></code></pre></div>
<p>which is actually also pure (only creating a blueprint of the graph to be executed), so we can safely replace the implementation to this in the <em>Akka Streams</em> version:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="fu">InputStreamingSource</span>(source: Source[ByteString, Any]) <span class="kw">extends</span> ProcessInputSource {</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">override</span> <span class="kw">def</span> toRedirect: Redirect = Redirect.<span class="fu">PIPE</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">connect</span>(systemProcess: lang.<span class="fu">Process</span>)(<span class="kw">implicit</span> contextShift: ContextShift[IO]): Source[ByteString, Any] =</a>
<a class="sourceLine" id="cb7-5" title="5">        source.<span class="fu">alsoTo</span>(<span class="fu">fromOutputStream</span>(() =&gt; systemProcess.<span class="fu">getOutputStream</span>, autoFlush = <span class="kw">true</span>))</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">run</span>(stream: Source[ByteString, Any])</a>
<a class="sourceLine" id="cb7-8" title="8">                    (<span class="kw">implicit</span> contextShift: ContextShift[IO],</a>
<a class="sourceLine" id="cb7-9" title="9">                     materializer: Materializer,</a>
<a class="sourceLine" id="cb7-10" title="10">                     executionContext: ExecutionContext): IO[Fiber[IO, Unit]] = {</a>
<a class="sourceLine" id="cb7-11" title="11">        Concurrent[IO].<span class="fu">start</span>(IO.<span class="fu">async</span> { finish =&gt;</a>
<a class="sourceLine" id="cb7-12" title="12">            stream.<span class="fu">runWith</span>(Sink.<span class="fu">ignore</span>).<span class="fu">onComplete</span> {</a>
<a class="sourceLine" id="cb7-13" title="13">                <span class="kw">case</span> <span class="fu">Success</span>(Done) =&gt; <span class="fu">finish</span>(<span class="fu">Right</span>(()))</a>
<a class="sourceLine" id="cb7-14" title="14">                <span class="kw">case</span> <span class="fu">Failure</span>(reason) =&gt; <span class="fu">finish</span>(<span class="fu">Left</span>(reason))</a>
<a class="sourceLine" id="cb7-15" title="15">            }</a>
<a class="sourceLine" id="cb7-16" title="16">        })</a>
<a class="sourceLine" id="cb7-17" title="17">    }</a>
<a class="sourceLine" id="cb7-18" title="18">}</a></code></pre></div>
<p>The implementation of <code>run</code> above is a nice example of how we can integrate asynchronous operations not implemented with <code>cats-effect</code> to an <code>IO</code> based program. With <code>IO.async</code> we define how to start the asynchronous operation (in this case running the <em>Akka stream</em>) and we get a callback function, <code>finish</code> to be called when the asynchronous operation ends. The stream here <em>materializes</em> to a <code>Future[T]</code> value, so we can use it’s <code>onComplete</code> function to notify the IO system about the finished stream. The <code>IO</code> value returned by <code>IO.async</code> represents the whole asynchronous operation, it returns it’s final result when the callback is called, and “blocks” the program flow until it is done. This does not mean actually blocking a thread; but the next IO function will be executed only when it finished running (as it’s type is <code>IO[A]</code>). That is not what we need here, so we use <code>Concurrent[IO].start</code> to put this <code>IO</code> action on a separate <em>fiber</em>. This way all streams involved in the process graph will be executing in parallel.</p>
<h3 id="calculating-the-result">Calculating the result</h3>
<p><a href="https://github.com/vigoo/prox">prox</a> supports multiple ways to calculate a result of running a process graph:</p>
<ul>
<li>If the target is a <code>Sink</code>, the result type is <code>Unit</code></li>
<li>If the pipe’s output is <code>Out</code> and there is a <code>Monoid</code> instance for <code>Out</code>, the stream is folded into an <code>Out</code> value</li>
<li>Otherwise if the pipe’s output is <code>Out</code>, the result type will be <code>Vector[Out]</code></li>
</ul>
<p>These cases can be enforced by the <code>Drain</code>, <code>ToVector</code> and <code>Fold</code> wrapper classes.</p>
<p>Let’s see how we can implement them with <em>Akka Streams</em> compared to <em>fs2</em>.</p>
<h4 id="drain-sink">Drain sink</h4>
<p>The sink version was implemented like this with <em>fs2</em>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" title="1">Concurrent[IO].<span class="fu">start</span>(stream.<span class="fu">compile</span>.<span class="fu">drain</span>)</a></code></pre></div>
<ul>
<li><code>.compile</code> gets an interface that can be used to convert the stream to a <code>IO[A]</code> value in multiple ways.</li>
<li><code>.drain</code> is one of them. It runs the stream but ignores its elements, having a result type of <code>IO[Unit]</code>.</li>
<li>We want to run this concurrently with the other streams so we move it to a <em>fiber</em></li>
</ul>
<p>With <em>Akka Streams</em> there is one big difference. In <em>fs2</em> the sink is represented as a <code>Pipe[F, E, Unit]</code>, so we could treat it in the same way as other stream segments. In this case the <code>Sink</code> is not a <code>Flow</code>, so we do a trick to keep the interface as close to the original one as possible:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">create</span>((sink: Sink[ByteString, Future[R]]) =&gt; <span class="kw">new</span> <span class="fu">OutputStreamingTarget</span>(Flow.<span class="fu">fromFunction</span>(identity)) </a>
<a class="sourceLine" id="cb9-2" title="2">                                                <span class="kw">with</span> ProcessOutputTarget[ByteString, R] {</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">run</span>(stream: Source[ByteString, Any])</a>
<a class="sourceLine" id="cb9-4" title="4">                    (<span class="kw">implicit</span> contextShift: ContextShift[IO],</a>
<a class="sourceLine" id="cb9-5" title="5">                    materializer: Materializer,</a>
<a class="sourceLine" id="cb9-6" title="6">                    executionContext: ExecutionContext): IO[Fiber[IO, R]] =</a>
<a class="sourceLine" id="cb9-7" title="7">    Concurrent[IO].<span class="fu">start</span>(IO.<span class="fu">async</span> { complete =&gt;</a>
<a class="sourceLine" id="cb9-8" title="8">        stream.<span class="fu">runWith</span>(sink).<span class="fu">onComplete</span> {</a>
<a class="sourceLine" id="cb9-9" title="9">            <span class="kw">case</span> <span class="fu">Success</span>(value) =&gt; <span class="fu">complete</span>(<span class="fu">Right</span>(value))</a>
<a class="sourceLine" id="cb9-10" title="10">            <span class="kw">case</span> <span class="fu">Failure</span>(reason) =&gt; <span class="fu">complete</span>(<span class="fu">Left</span>(reason))</a>
<a class="sourceLine" id="cb9-11" title="11">        }</a>
<a class="sourceLine" id="cb9-12" title="12">    })</a>
<a class="sourceLine" id="cb9-13" title="13">}</a></code></pre></div>
<p>The trick is that we create the <code>OutputStreamingTarget</code> with an identity flow, and only use the <code>Sink</code> when we actually run the stream, passing it to the <code>runWith</code> function. This materializes the stream into a <code>Future[Done]</code> value, that we can tie back to our <code>IO</code> system with <code>IO.async</code> as I already described it.</p>
<h4 id="combine-with-monoid">Combine with Monoid</h4>
<p>When the element type is a <em>monoid</em> we can fold it into a single value. <em>Fs2</em> directly supports this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" title="1">Concurrent[IO].<span class="fu">start</span>(stream.<span class="fu">compile</span>.<span class="fu">foldMonoid</span>)</a></code></pre></div>
<p><em>Akka Streams</em> does not use cats type classes, but it also has a way to <em>fold</em> the stream, so we can easily implement it using the <em>monoid instance</em>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1">Concurrent[IO].<span class="fu">start</span>(IO.<span class="fu">async</span> { complete =&gt;</a>
<a class="sourceLine" id="cb11-2" title="2">    stream.<span class="fu">runFold</span>(monoid.<span class="fu">empty</span>)(monoid.<span class="fu">combine</span>).<span class="fu">onComplete</span> {</a>
<a class="sourceLine" id="cb11-3" title="3">        <span class="kw">case</span> <span class="fu">Success</span>(value) =&gt; <span class="fu">complete</span>(<span class="fu">Right</span>(value))</a>
<a class="sourceLine" id="cb11-4" title="4">        <span class="kw">case</span> <span class="fu">Failure</span>(reason) =&gt; <span class="fu">complete</span>(<span class="fu">Left</span>(reason))</a>
<a class="sourceLine" id="cb11-5" title="5">    }</a>
<a class="sourceLine" id="cb11-6" title="6">})</a></code></pre></div>
<h4 id="vector-of-elements">Vector of elements</h4>
<p>Finally let’s see the version that keeps all the stream elements in a vector as a result:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1">Concurrent[IO].<span class="fu">start</span>(stream.<span class="fu">compile</span>.<span class="fu">toVector</span>)</a></code></pre></div>
<p>With <em>Akka Streams</em> we can do it by running the stream into a <em>sink</em> created for this, <code>Sink.seq</code>. It materializes into a <code>Future[Seq[T]]</code> value that holds all the elements of the executed stream:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1">Concurrent[IO].<span class="fu">start</span>(IO.<span class="fu">async</span> { complete =&gt;</a>
<a class="sourceLine" id="cb13-2" title="2">    stream.<span class="fu">runWith</span>(Sink.<span class="fu">seq</span>).<span class="fu">onComplete</span> {</a>
<a class="sourceLine" id="cb13-3" title="3">        <span class="kw">case</span> <span class="fu">Success</span>(value) =&gt; <span class="fu">complete</span>(<span class="fu">Right</span>(value.<span class="fu">toVector</span>))</a>
<a class="sourceLine" id="cb13-4" title="4">        <span class="kw">case</span> <span class="fu">Failure</span>(reason) =&gt; <span class="fu">complete</span>(<span class="fu">Left</span>(reason))</a>
<a class="sourceLine" id="cb13-5" title="5">    }</a>
<a class="sourceLine" id="cb13-6" title="6">})</a></code></pre></div>
<h3 id="testing">Testing</h3>
<p>At this point the only remaining thing is to modify the tests too. One of the more complex examples is the <code>customProcessPiping</code> test case. With <em>fs2</em> it takes advantage of some <em>text processing</em> pipe elements coming with the library:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">val</span> customPipe: Pipe[IO, Byte, Byte] =</a>
<a class="sourceLine" id="cb14-2" title="2">    (s: Stream[IO, Byte]) =&gt; s</a>
<a class="sourceLine" id="cb14-3" title="3">    .<span class="fu">through</span>(text.<span class="fu">utf8Decode</span>)</a>
<a class="sourceLine" id="cb14-4" title="4">    .<span class="fu">through</span>(text.<span class="fu">lines</span>)</a>
<a class="sourceLine" id="cb14-5" title="5">    .<span class="fu">map</span>(_.<span class="fu">split</span>(<span class="ch">&#39; &#39;</span>).<span class="fu">toVector</span>)</a>
<a class="sourceLine" id="cb14-6" title="6">    .<span class="fu">map</span>(v =&gt; v.<span class="fu">map</span>(_ + <span class="st">&quot; !!!&quot;</span>).<span class="fu">mkString</span>(<span class="st">&quot; &quot;</span>))</a>
<a class="sourceLine" id="cb14-7" title="7">    .<span class="fu">intersperse</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb14-8" title="8">    .<span class="fu">through</span>(text.<span class="fu">utf8Encode</span>)</a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="kw">val</span> proc = Process(<span class="st">&quot;echo&quot;</span>, List(<span class="st">&quot;This is a test string&quot;</span>))</a>
<a class="sourceLine" id="cb14-11" title="11">            .<span class="fu">via</span>(customPipe)</a>
<a class="sourceLine" id="cb14-12" title="12">            .<span class="fu">to</span>(Process(<span class="st">&quot;wc&quot;</span>, List(<span class="st">&quot;-w&quot;</span>)) &gt; text.<span class="fu">utf8Decode</span>[IO])</a></code></pre></div>
<p>There are similar tools in <em>Akka Streams</em> to express this in the <code>Framing</code> module:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" title="1"> <span class="kw">val</span> customPipe = Framing.<span class="fu">delimiter</span>(</a>
<a class="sourceLine" id="cb15-2" title="2">      delimiter = <span class="fu">ByteString</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>),</a>
<a class="sourceLine" id="cb15-3" title="3">      maximumFrameLength = <span class="dv">10000</span>,</a>
<a class="sourceLine" id="cb15-4" title="4">      allowTruncation = <span class="kw">true</span></a>
<a class="sourceLine" id="cb15-5" title="5">    ).<span class="fu">map</span>(_.<span class="fu">utf8String</span>)</a>
<a class="sourceLine" id="cb15-6" title="6">     .<span class="fu">map</span>(_.<span class="fu">split</span>(<span class="ch">&#39; &#39;</span>).<span class="fu">toVector</span>)</a>
<a class="sourceLine" id="cb15-7" title="7">     .<span class="fu">map</span>(v =&gt; v.<span class="fu">map</span>(_ + <span class="st">&quot; !!!&quot;</span>).<span class="fu">mkString</span>(<span class="st">&quot; &quot;</span>))</a>
<a class="sourceLine" id="cb15-8" title="8">     .<span class="fu">intersperse</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</a>
<a class="sourceLine" id="cb15-9" title="9">     .<span class="fu">map</span>(ByteString.<span class="fu">apply</span>)</a>
<a class="sourceLine" id="cb15-10" title="10"></a>
<a class="sourceLine" id="cb15-11" title="11"><span class="kw">val</span> proc = Process(<span class="st">&quot;echo&quot;</span>, List(<span class="st">&quot;This is a test string&quot;</span>))</a>
<a class="sourceLine" id="cb15-12" title="12">            .<span class="fu">via</span>(customPipe)</a>
<a class="sourceLine" id="cb15-13" title="13">            .<span class="fu">to</span>(Process(<span class="st">&quot;wc&quot;</span>, List(<span class="st">&quot;-w&quot;</span>)) &gt; utf8Decode)</a></code></pre></div>
<p>where <code>utf8Decode</code> is a helper sink defined as:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">val</span> utf8Decode: Sink[ByteString, Future[String]] =</a>
<a class="sourceLine" id="cb16-2" title="2">    Flow[ByteString]</a>
<a class="sourceLine" id="cb16-3" title="3">        .<span class="fu">reduce</span>(_ ++ _)</a>
<a class="sourceLine" id="cb16-4" title="4">        .<span class="fu">map</span>(_.<span class="fu">utf8String</span>)</a>
<a class="sourceLine" id="cb16-5" title="5">        .<span class="fu">toMat</span>(Sink.<span class="fu">head</span>)(Keep.<span class="fu">right</span>)</a></code></pre></div>
<p>First it concatenates the <code>ByteString</code> chunks, then simply calls <code>.utf8String</code> on the result.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>We have seen that it is relatively easy to replace the stream library in <a href="https://github.com/vigoo/prox">prox</a> without changing it’s interface much, if we keep <a href="https://typelevel.org/cats-effect/">cats-effect</a> for expressing the effectful computations. The complete working example is available on the <a href="https://github.com/vigoo/prox/compare/akka-streams"><code>akka-streams</code> branch</a>.</p>
]]></summary>
</entry>
<entry>
    <title>prox part 1 - type level programming</title>
    <link href="http://vigoo.github.io/posts/2019-02-10-prox-1-types.html" />
    <id>http://vigoo.github.io/posts/2019-02-10-prox-1-types.html</id>
    <published>2019-02-10T00:00:00Z</published>
    <updated>2019-02-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on February 10, 2019
    
</div>

<h2 id="blog-post-series">Blog post series</h2>
<ul>
<li><a href="2019-02-10-prox-1-types.html">Part 1 - type level programming</a></li>
<li><a href="2019-03-07-prox-2-io-akkastreams.html">Part 2 - akka streams with cats effect</a></li>
<li><a href="2019-08-13-prox-3-zio.html">Part 3 - effect abstraction and ZIO</a></li>
<li><a href="2020-08-03-prox-4-simplify.html">Part 4 - simplified redesign</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>I started writing <a href="https://github.com/vigoo/prox">prox</a> at the end of 2017 for two reasons. First, I never liked any of the existing solutions for running external processes and capture their input/output streams. And I just returned from the <a href="https://scala.io/">scala.io conference</a> full of inspiration; I wanted to try out some techniques and libraries and this seemed to be a nice small project to do so.</p>
<p>Since then, <a href="https://github.com/vigoo/prox">prox</a> has been proved to be useful, we are using it at <a href="https://prezi.com/">Prezi</a> in all our Scala projects where we have to deal with external processes. The last stable version was created last October, after <a href="https://typelevel.org/cats-effect/">cats-effect 1.0</a> and <a href="https://fs2.io/">fs2 1.0</a> was released.</p>
<p>This is the first part of a series of blog posts dedicated to this library. In the first one I’m going to talk about <a href="https://github.com/milessabin/shapeless">shapeless</a> and <em>type level programming</em> techniques are used to create a strongly typed interface for starting system processes. In future posts I will explore replacing its dependencies such as using <a href="https://doc.akka.io/docs/akka/2.5/stream/">akka-streams</a> instead of <a href="https://fs2.io/">fs2</a> or <a href="https://scalaz.github.io/scalaz-zio/">ZIO</a> instead of <a href="https://typelevel.org/cats-effect/">cats-effect</a>. These different versions will be a good opportunity to do some performance comparison, and to close the series with creating a new version of the library which is easier to use in the alternative environments.</p>
<h2 id="limiting-redirection">Limiting redirection</h2>
<p>When I started writing the library I wanted to explore how I can express some strict constraints on the type level:</p>
<ul>
<li>A process can have its input, output and error streams redirected, but only once</li>
<li>Processes without redirected output can be piped to processes without a redirected input</li>
</ul>
<p>In prox <em>0.2.1</em> a single system process is described by the following type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> Process[Out, Err, OutResult, ErrResult, </a>
<a class="sourceLine" id="cb1-2" title="2">              IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState](</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">val</span> command: String,</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="kw">val</span> arguments: List[String],</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="kw">val</span> workingDirectory: Option[Path],</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">val</span> inputSource: ProcessInputSource,</a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="kw">val</span> outputTarget: ProcessOutputTarget[Out, OutResult],</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">val</span> errorTarget: ProcessErrorTarget[Err, ErrResult],</a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">val</span> environmentVariables: Map[String, String])</a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="kw">extends</span> ProcessNode[Out, Err, IRS, ORS, ERS] {</a>
<a class="sourceLine" id="cb1-11" title="11">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb1-12" title="12">}</a></code></pre></div>
<p>but let’s focus first on the requirement to be able to redirect one of the streams <em>maximum once</em>. This is encoded by the <code>IRS</code>, <code>ORS</code> and <code>ERS</code> type parameters, which are all have to be subtypes of <code>RedirectionState</code>. <code>RedirectionState</code> is a <strong>phantom type</strong>; there are no values ever created of this type, it is only used in type signatures to encode whether one of the three streams are already redirected or not:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/**</span> Phantom type representing the redirection state of a process <span class="co">*/</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">sealed</span> <span class="kw">trait</span> RedirectionState</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">/**</span> Indicates that the given channel is not redirected yet <span class="co">*/</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">trait</span> NotRedirected <span class="kw">extends</span> RedirectionState</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">/**</span> Indicates that the given channel has already been redirected <span class="co">*/</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">trait</span> Redirected <span class="kw">extends</span> RedirectionState</a></code></pre></div>
<p>So for example with a simplified model of a <em>process</em>, <code>Process[IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState]</code>, using the output redirection operator <code>&gt;</code> would change the types in the following way:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">val</span> p1: Process[NotRedirected, NotRedirected, NotRedirected] = ???</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">val</span> p2: Process[NotRedirected, Redirected, NotRedirected] = p1 &gt; (home / <span class="st">&quot;tmp&quot;</span> / <span class="st">&quot;out.txt&quot;</span>)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">val</span> p3 = p2 &gt; (home / <span class="st">&quot;tmp&quot;</span> / <span class="st">&quot;another.txt&quot;</span>) <span class="co">// THIS MUST NOT COMPILE</span></a></code></pre></div>
<p>How can we restrict the redirect function to only work on <code>Process[_, NotRedirected, _]</code>? We can define it as an <strong>extension method</strong> with an implicit class (once again this is a simplified version focusing only on the <em>redirection state</em> handling):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1">  <span class="kw">implicit</span> <span class="kw">class</span> ProcessNodeOutputRedirect[</a>
<a class="sourceLine" id="cb4-2" title="2">      IRS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb4-3" title="3">      ERS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb4-4" title="4">      PN &lt;: Process[IRS, NotRedirected, ERS]](process: PN) {</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">def</span> &gt;[To](to: To)(<span class="kw">implicit</span> target: CanBeProcessOutputTarget[To]): Process[IRS, Redirected, ERS] = ???</a>
<a class="sourceLine" id="cb4-7" title="7">  }</a></code></pre></div>
<p>By forcing the <code>ORS</code> type parameter to be <code>NotRedirected</code> and setting it to <code>Redirected</code> in the result type we can guarantee that this function can only be called on a process that does not have their output redirected yet. The <em>target</em> of the redirection is extensible through the <code>CanBeProcessOutputTarget</code> type class, as we will see later.</p>
<h2 id="dependent-types">Dependent types</h2>
<p>Reality is much more complicated, because of <em>process piping</em> and because the process types encode the redirection result types too. Let’s get back to our <code>&gt;</code> function and see how we could modify it so it works with piped processes too. Anyway, how is process piping encoded in this library?</p>
<p>Two processes connected through a pipe are represented by the <code>PipedProcess</code> class. Both <code>Procses</code> and <code>PipedProcess</code> implements the following trait:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">sealed</span> <span class="kw">trait</span> ProcessNode[Out, Err, IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState]</a></code></pre></div>
<p>We’ve already seen <code>Process</code>. <code>PipedProcess</code> is a bit more complicated:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">class</span> PipedProcess[Out, Err, PN1Out, </a>
<a class="sourceLine" id="cb6-2" title="2">                   PN1 &lt;: ProcessNode[_, _, _, _, _], </a>
<a class="sourceLine" id="cb6-3" title="3">                   PN2 &lt;: ProcessNode[_, _, _, _, _], </a>
<a class="sourceLine" id="cb6-4" title="4">                   IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState]</a>
<a class="sourceLine" id="cb6-5" title="5">    (<span class="kw">val</span> from: PN1, <span class="kw">val</span> createTo: PipeConstruction[PN1Out] =&gt; PN2)</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">extends</span> ProcessNode[Out, Err, IRS, ORS, ERS] {</a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb6-8" title="8">}</a></code></pre></div>
<p>To make <code>&gt;</code> work on both, we can start by modifying its definition to work on <em>any</em> <code>ProcessNode</code> not just <code>Process</code> (omitting the output type params for now):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">implicit</span> <span class="kw">class</span> ProcessNodeOutputRedirect[</a>
<a class="sourceLine" id="cb7-2" title="2">    IRS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb7-3" title="3">    ERS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb7-4" title="4">    PN &lt;: ProcessNode[IRS, NotRedirected, ERS]](process: PN) {</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="kw">def</span> &gt;[To](to: To)(<span class="kw">implicit</span> target: CanBeProcessOutputTarget[To]): ProcessNode[IRS, Redirected, ERS] = ???</a>
<a class="sourceLine" id="cb7-7" title="7">}</a></code></pre></div>
<p>This has a serious problem though. The output type is <code>ProcessNode</code> and not the “real” process type, which means that we lose type information and all the other dependent typed operations will not work. We have to make the result type <strong>depend</strong> on the input!</p>
<p>We may try to use the <code>RedirectionOutput</code> type class like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">implicit</span> <span class="kw">class</span> ProcessNodeOutputRedirect[</a>
<a class="sourceLine" id="cb8-2" title="2">    IRS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb8-3" title="3">    ERS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb8-4" title="4">    PN &lt;: ProcessNode[IRS, NotRedirected, ERS]](process: PN) {</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="kw">def</span> &gt;[To](to: To)</a>
<a class="sourceLine" id="cb8-7" title="7">           (<span class="kw">implicit</span> target: CanBeProcessOutputTarget[To],</a>
<a class="sourceLine" id="cb8-8" title="8">            redirectOutput: RedirectOutput[PN, To]): redirectOutput.<span class="fu">Result</span> = <span class="fu">redirectOutput</span>(to)</a>
<a class="sourceLine" id="cb8-9" title="9">}</a></code></pre></div>
<p>Here the result (<code>redirectOutput.Result</code>) is a <em>path dependent type</em>. This may work in some simple cases but have two serious issues:</p>
<ul>
<li>It is not possible to use <code>redirectOutput.Result</code> in the <em>parameter block</em> of the function, so if another type class needed it as a type parameter we could not pass it.</li>
<li>Further implicit resolutions and type level operations will quickly break as the compiler will not be able to unify the various path dependent types</li>
</ul>
<p>The <strong>Aux pattern</strong>, used heavily in the <a href="https://github.com/milessabin/shapeless">shapeless</a> library provides a nice pattern for fixing both problems. We start by defining a <em>type class</em> for describing the operation, in this case <em>redirecting the output channel of a process</em>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">trait</span> RedirectOutput[PN &lt;: ProcessNode[_, NotRedirected, _], To] {</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">type</span> Result &lt;: ProcessNode[_, Redirected, _]</a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="kw">def</span> <span class="fu">apply</span>(process: PN, to: To)(<span class="kw">implicit</span> target: CanBeProcessOutputTarget[To]): Result</a>
<a class="sourceLine" id="cb9-5" title="5">}</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">object</span> RedirectOutput {</a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="kw">type</span> Aux[PN &lt;: ProcessNode[_, NotRedirected, _], To, Result0] = </a>
<a class="sourceLine" id="cb9-9" title="9">        RedirectOutput[PN, To] { <span class="kw">type</span> Result = Result0 }</a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11">    <span class="co">// ... type class instances</span></a>
<a class="sourceLine" id="cb9-12" title="12">}</a></code></pre></div>
<p>The type class itself is straightforward. We have to implement it for both <code>Process</code> and <code>PipedProcess</code> and set the <code>Result</code> type accordingly, then implement <code>apply</code> that sets up the actual redirection. But what the <code>Aux</code> type is for?</p>
<p>It solves the problems with the <em>path dependent</em> version if we use it like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">implicit</span> <span class="kw">class</span> ProcessNodeOutputRedirect[</a>
<a class="sourceLine" id="cb10-2" title="2">    IRS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb10-3" title="3">    ERS &lt;: RedirectionState, </a>
<a class="sourceLine" id="cb10-4" title="4">    PN &lt;: ProcessNode[IRS, NotRedirected, ERS]](process: PN) {</a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="kw">def</span> &gt;[To, Result &lt;: ProcessNode[_, Redirected, _]](to: To)</a>
<a class="sourceLine" id="cb10-7" title="7">           (<span class="kw">implicit</span> target: CanBeProcessOutputTarget[To],</a>
<a class="sourceLine" id="cb10-8" title="8">            redirectOutput: RedirectOutput.<span class="fu">Aux</span>[PN, To, Result]): Result = <span class="fu">redirectOutput</span>(to)</a>
<a class="sourceLine" id="cb10-9" title="9">}</a></code></pre></div>
<p>By lifting the <code>Result</code> from the type class instance to a type parameter the compiler can now “extract” the calculated type from <code>redirectOutput.Result</code> to the <code>&gt;</code> function’s <code>Result</code> type parameter and use it directly, both for other further type requirements or as we do here, in the result type.</p>
<p>This is the basic pattern used for <em>all</em> the operations in prox. You can check <a href="http://gigiigig.github.io/posts/2015/09/13/aux-pattern.html">Luigi’s short introduction to the <code>Aux</code> pattern</a> for a more detailed explanation.</p>
<h2 id="starting-the-processes">Starting the processes</h2>
<p>So far we just combined purely functional data structures in a complicated way. The result value may encode the launching of several system processes that are connected via pipes to each other and possibly other streams as we will see.</p>
<p>When we eventually decide to <em>start</em> these processes, we need a way to observe their status, wait for them to stop, get their exit code, and to access the data sent to the output streams if they were redirected. And we need this <em>per process</em>, while launching the whole process graph in a <em>single step</em>.</p>
<p>First let’s model a single <em>running process</em>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">trait</span> RunningProcess[Out, OutResult, ErrResult] {</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="kw">def</span> isAlive: IO[Boolean]</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">def</span> <span class="fu">waitForExit</span>(): IO[ProcessResult[OutResult, ErrResult]]</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="kw">def</span> <span class="fu">terminate</span>(): IO[ProcessResult[OutResult, ErrResult]]</a>
<a class="sourceLine" id="cb11-5" title="5">}</a></code></pre></div>
<p>and <code>ProcessResult</code> that represents an already <em>terminated process</em>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">case</span> <span class="kw">class</span> ProcessResult[OutResult, ErrResult](</a>
<a class="sourceLine" id="cb12-2" title="2">    exitCode: Int, </a>
<a class="sourceLine" id="cb12-3" title="3">    fullOutput: OutResult, </a>
<a class="sourceLine" id="cb12-4" title="4">    fullError: ErrResult</a>
<a class="sourceLine" id="cb12-5" title="5">)</a></code></pre></div>
<p>Now we need to define a <code>start</code> extension method on <code>ProcessNode</code> that returns somehow one well typed <code>RunningProcess</code> for <em>each</em> system process that it starts.</p>
<p>Let’s forget for a second about having multiple processes piped together and just consider the single process case. For that, we would need somehing like this (the <code>Out</code> parameter is needed only for piping so I omitted it):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">def</span> start: IO[RunningProcess[OutResult, ErrResult]]</a></code></pre></div>
<p>Now we can see why <code>Process</code> has those additional type paramters. It is not enough to encode whether the output and error channels were redirected or not, we also have to encode the expected <em>result type</em> of redirecting these. By storing these types in type parameters of <code>Process</code> we can easily imagine that by using the pattern described in the previous section, the <em>result type</em> can <strong>depend</strong> on what we redirected the process to.</p>
<p>Let’s see some examples of what this means!</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>Target</th>
<th>Result type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A file system path</td>
<td>The result type is <code>Unit</code>, the redirection happens on OS level</td>
</tr>
<tr class="even">
<td>Sink</td>
<td>The result type is <code>Unit</code>, only the sink’s side effect matters</td>
</tr>
<tr class="odd">
<td>Pipe with monoid elem type</td>
<td>The stream is folded by the monoid, the result type is <code>T</code></td>
</tr>
<tr class="even">
<td>Pipe with non-monoid elem type</td>
<td>The stream captures the elements in a vector, the result type is <code>Vector[T]</code></td>
</tr>
<tr class="odd">
<td>Custom fold function</td>
<td>The result type is the function’s result type</td>
</tr>
</tbody>
</table>
<p>The <code>CanBeProcessOutputTarget</code> type class we’ve seen earlier defines both the stream element type and the result type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">trait</span> CanBeProcessOutputTarget[To] {</a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="co">/**</span> Output stream element type <span class="co">*/</span></a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="kw">type</span> Out</a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="co">/**</span> Result type of running the output stream <span class="co">*/</span></a>
<a class="sourceLine" id="cb14-5" title="5">  <span class="kw">type</span> OutResult</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">  <span class="kw">def</span> <span class="fu">apply</span>(to: To): ProcessOutputTarget[Out, OutResult]</a>
<a class="sourceLine" id="cb14-8" title="8">}</a></code></pre></div>
<p><code>ProcessOutputTarget</code> contains the actual IO code to build the redirection of the streams, I won’t get into details in this post. Note that there are similar type classes for <em>error</em> and <em>input</em> redirection too.</p>
<p>For two processes piped together we have to provide <em>two</em> <code>RunningProcess</code> instances with the proper result type parameters. So we can see that it is not enough that the <em>redirection</em> stores the result type in the process type, the <em>start</em> method must be dependent typed too.</p>
<p>One way to encode this in the type system would be something like this (simplified):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">val</span> p1 = Process()</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">val</span> p2 = Process()</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="kw">val</span> p3 = Process()</a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="kw">val</span> rp1: IO[RunningProcess] = p1.<span class="fu">start</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="kw">val</span> rp2: IO[(RunningProcess, RunningProcess)] = (p1 | p2).<span class="fu">start</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="kw">val</span> rp3: IO[(RunningProcess, RunningProcess, RunningProcess)] = (p1 | p2 | p3).<span class="fu">start</span></a></code></pre></div>
<p>We encode piped processes with tuples of <code>RunningProcess</code> and single process with a single <code>RunningProcess</code>. To implement this we can make use of the <a href="https://github.com/milessabin/shapeless">shapeless</a> library’s <code>HList</code> implementation.</p>
<p>HLists are heterogeneous lists; basically similar to a tuple, but with all the “usual” list-like functions implemented as dependent typed functions. It’s type describes the types of all its elements, and you can split it to head/tail, append two, etc. And we can do it both on the <em>type level</em> (computing the result type of appending two <code>HList</code>’s, for example) and on the <em>value leve</em> (appending the two values creating a third <code>HList</code> value).</p>
<p>We can implement the <code>start</code> method more easily by building a <code>HList</code>, while still keep the desired interface as <a href="https://github.com/milessabin/shapeless">shapeless</a> implements a conversion from <code>HList</code> to tuples.</p>
<p>We can define two separate <em>start functions</em>, one producing <code>HList</code> and another the tuples (IO releated parameters omitted):</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">def</span> start[RP](<span class="kw">implicit</span> start: Start.<span class="fu">Aux</span>[PN, RP, _]]): IO[RP] = ???</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">def</span> startHL[RPL &lt;: HList](<span class="kw">implicit</span> start: Start.<span class="fu">Aux</span>[PN, _, RP[IO]): IO[RPL] = ???</a></code></pre></div>
<p>The <code>Start</code> type class calculates both the tupled and the <code>HList</code> version’s result type. The implementation’s responsibility is to start the actual system processes and wire the streams together.</p>
<p>The interesting part is how we use <em>type level calculations</em> from <a href="https://github.com/milessabin/shapeless">shapeless</a> to calculte the tuple and <code>HList</code> types for piped processes. This is all done using the technique I described earlier, but may look a bit shocking first. Let’s take a look!</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">implicit</span> <span class="kw">def</span> startPipedProcess[</a>
<a class="sourceLine" id="cb17-2" title="2">  Out, Err,</a>
<a class="sourceLine" id="cb17-3" title="3">  PN1 &lt;: ProcessNode[_, _, _, _, _],</a>
<a class="sourceLine" id="cb17-4" title="4">  PN2 &lt;: ProcessNode[_, _, _, _, _],</a>
<a class="sourceLine" id="cb17-5" title="5">  IRS &lt;: RedirectionState, ORS &lt;: RedirectionState, ERS &lt;: RedirectionState,</a>
<a class="sourceLine" id="cb17-6" title="6">  RP1, RPL1 &lt;: HList, RP1Last &lt;: RunningProcess[_, _, _],</a>
<a class="sourceLine" id="cb17-7" title="7">  RP2, RPL2 &lt;: HList, RP2Head &lt;: RunningProcess[_, _, _], RP2Tail &lt;: HList,</a>
<a class="sourceLine" id="cb17-8" title="8">  RPT, RPL &lt;: HList]</a>
<a class="sourceLine" id="cb17-9" title="9">  (<span class="kw">implicit</span></a>
<a class="sourceLine" id="cb17-10" title="10">   start1: Start.<span class="fu">Aux</span>[PN1, RP1, RPL1],</a>
<a class="sourceLine" id="cb17-11" title="11">   start2: Start.<span class="fu">Aux</span>[PN2, RP2, RPL2],</a>
<a class="sourceLine" id="cb17-12" title="12">   last1: Last.<span class="fu">Aux</span>[RPL1, RP1Last],</a>
<a class="sourceLine" id="cb17-13" title="13">   rp1LastType: RP1Last &lt;:&lt; RunningProcess[Byte, _, _],</a>
<a class="sourceLine" id="cb17-14" title="14">   hcons2: IsHCons.<span class="fu">Aux</span>[RPL2, RP2Head, RP2Tail],</a>
<a class="sourceLine" id="cb17-15" title="15">   prepend: Prepend.<span class="fu">Aux</span>[RPL1, RPL2, RPL],</a>
<a class="sourceLine" id="cb17-16" title="16">   tupler: Tupler.<span class="fu">Aux</span>[RPL, RPT]):</a>
<a class="sourceLine" id="cb17-17" title="17">  Aux[PipedProcess[Out, Err, Byte, PN1, PN2, IRS, ORS, ERS], RPT, RPL] =</a>
<a class="sourceLine" id="cb17-18" title="18"></a>
<a class="sourceLine" id="cb17-19" title="19">    <span class="kw">new</span> Start[PipedProcess[Out, Err, Byte, PN1, PN2, IRS, ORS, ERS]] {</a>
<a class="sourceLine" id="cb17-20" title="20">      <span class="kw">override</span> <span class="kw">type</span> RunningProcesses = RPT</a>
<a class="sourceLine" id="cb17-21" title="21">      <span class="kw">override</span> <span class="kw">type</span> RunningProcessList = RPL</a>
<a class="sourceLine" id="cb17-22" title="22"></a>
<a class="sourceLine" id="cb17-23" title="23">      <span class="co">// ...</span></a>
<a class="sourceLine" id="cb17-24" title="24">    }</a></code></pre></div>
<p>The way to parse this is to follow the type level computations performed through the <em>Aux types</em> in the implicit parameter list:</p>
<ul>
<li><code>PN1</code> and <code>PN2</code> are the types of the two processes piped together</li>
<li>The first two implicit definition calculates the <em>running process tuple</em> and the <em>running process HList</em> types of these inidividual process nodes and “stores” the results in <code>RP1</code>, <code>RPL1</code>, <code>RP2</code> and <code>RPL2</code> type parameters. For example if the two processes pipe together are single <code>Process</code> instances, then <code>RP1</code> and <code>RP2</code> would be some kind of <code>RunningProcess</code>, and the HLists would be one element long, like <code>RunningProcess :: HNil</code>.</li>
<li>The <code>last1</code> implicit parameter is a type level <em>last</em> functinon on the first process’s <code>HList</code>. This is required because <code>PN1</code> itself can also be a sequence of piped processes, and we are connecting <code>PN2</code> to the <strong>last</strong> of these. The <code>RP1Last</code> type parameter becomes the <em>type</em> of the <em>last running process</em> of the first process node.</li>
<li>The next line, <code>rp1LastType</code> is an additional constraint fixing the <em>output stream element type</em> of <code>RP1Last</code> to <code>Byte</code>. The piping implementation is not able to connect streams of arbitrary element types, as the <em>process input</em> is always required to be a <em>byte stream</em>.</li>
<li><code>hcons2</code> is similar to the <code>last1</code> but here we are calculating the type level <em>head type</em> of the <code>HList</code> called <code>RPL2</code>. The head will be in <code>RP2Head</code> and the tail <code>HList</code> in <code>RP2Tail</code>.</li>
<li>In the <code>prepend</code> step we concatenate <code>RPL1</code> with <code>RPL2</code> using the <code>Prepend</code> operation, the result <code>HList</code> type is in <code>RPL</code>. This is the <code>HList</code> representation of the piped running process.</li>
<li>Finally we use the <code>Tupler</code> operation to calculate the tuple type from the <code>HList</code>, and store it in <code>RPT</code>.</li>
</ul>
<p>The compiler perform the type level calculations and we can use the result types <code>RPT</code> and <code>RPL</code> to actually implement the <em>start typeclass</em>. This is the most complicated type level calculation in the library.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>As we’ve seen, Scala’s type system can bring us quite far in expressing a dependent typed interface. On the other hand writing and reading code in this style is really hard, and if things go wrong, decoding the compiler’s error messages is not an easy task either. This is a serious tradeoff that has to be considered and in many cases a more dynamic but much more readable and maintainable approach can be better.</p>
<p>With <a href="https://github.com/vigoo/prox">prox</a> I explicitly wanted to explore these features of the Scala language.</p>
<p>In the next posts we will ignore the type level parts of the library and focus on different <em>streaming</em> and <em>effect</em> libraries.</p>
]]></summary>
</entry>
<entry>
    <title>AWS rate limits vs prezidig</title>
    <link href="http://vigoo.github.io/posts/2018-09-21-aws-rate-limits-prezidig.html" />
    <id>http://vigoo.github.io/posts/2018-09-21-aws-rate-limits-prezidig.html</id>
    <published>2018-09-21T00:00:00Z</published>
    <updated>2018-09-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 21, 2018
    
</div>

<p>At <a href="https://prezi.com">Prezi</a>, we have an internal tool called <strong>prezidig</strong> for discovering AWS resources. I like it a lot so I was quite annoyed recently that it always fails with a <em>throttling exception</em> because of our increased use of the AWS API. It made it completely unusable, so I decided to try to fix this.</p>
<p>Then I decided to write the story in this blog post, as the steps I had to made to achieve the results I aimed for can be useful for writing maintainable, fast and safe Scala code in the future.</p>
<p>I will describe the phases as they happened, as I did not really know anything about this codebase so the path to the success was not exactly clear immediately.</p>
<h2 id="wrapping-the-calls">Wrapping the calls</h2>
<p>So my initial thought was to just find the AWS API calls and wrap them in a helper function which catches the throttling error and retries with an increasing delay.</p>
<p>I basically wrote this in the base class of all the <em>mirrors</em> (the classes which are responsible for fetching AWS and other resource data for <strong>prezidig</strong>):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"> <span class="kw">protected</span> <span class="kw">def</span> byHandlingThrottling[T](awsCall: =&gt; T): Future[T] = {</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="kw">def</span> <span class="fu">call</span>(remainingTries: Int, wait: FiniteDuration): Future[T] = {</a>
<a class="sourceLine" id="cb1-3" title="3">      Future(<span class="fu">Try</span>(awsCall)).<span class="fu">flatMap</span> {</a>
<a class="sourceLine" id="cb1-4" title="4">        <span class="kw">case</span> <span class="fu">Success</span>(result) =&gt; Future.<span class="fu">successful</span>(result)</a>
<a class="sourceLine" id="cb1-5" title="5">        <span class="kw">case</span> <span class="fu">Failure</span>(awsException: AmazonServiceException) <span class="kw">if</span> awsException.<span class="fu">getErrorCode</span> == <span class="st">&quot;Throttling&quot;</span> &amp;&amp; remainingTries &gt; <span class="dv">0</span> =&gt;</a>
<a class="sourceLine" id="cb1-6" title="6">          akka.<span class="fu">pattern</span>.<span class="fu">after</span>(wait, actorSystem.<span class="fu">scheduler</span>) {</a>
<a class="sourceLine" id="cb1-7" title="7">            <span class="fu">call</span>(remainingTries - <span class="dv">1</span>, wait * <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-8" title="8">          }</a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="kw">case</span> <span class="fu">Failure</span>(reason) =&gt; Future.<span class="fu">failed</span>(reason)</a>
<a class="sourceLine" id="cb1-10" title="10">      }</a>
<a class="sourceLine" id="cb1-11" title="11">    }</a>
<a class="sourceLine" id="cb1-12" title="12">     <span class="fu">call</span>(<span class="dv">10</span>, <span class="fl">100.</span>millis) <span class="co">// TODO: make configurable</span></a>
<a class="sourceLine" id="cb1-13" title="13">  }</a></code></pre></div>
<p>Then the only thing I had to do was to was wrapping all the existing AWS calls with this. Then I realized that this won’t be this simple, as these calls were not always asynchronous, just sometimes. To see an example, for an <em>ElasticBeanstalk application</em>, it fetches the <em>application metadata</em> with synchronous call, then fetches the related <em>EB environments</em> asynchronously. The whole thing might be wrapped in another future somewhere else, but that’s a different story.</p>
<p>While making these discoveries I also found several synchronization points, like the code waiting for some futures to complete in a blocking way. Also that the model is mutable. So… just for trying this out, I <em>still <strong>wrapped</strong></em> all the AWS calls with this stuff, by converting the future back to a synchronous call by immediately blocking on it.</p>
<p>What did I achieve with this? Well, some throttling errors were fixed, the code became extremely ugly, and I could not even wrap everything so the errors remained, and because of the tons of blocking, timeouts, etc. it was basically impossible to understand whether this would work or deadlock or just be slow.</p>
<p>That was the point I decided to do this properly</p>
<h2 id="reflection">Reflection</h2>
<p>Before solving the real problem I found that the mirrors are initialized via reflection, something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> buildMirrors[A &lt;: RegionAwareAWSMirror[_, _]](<span class="kw">implicit</span> mf: Manifest[A]): Seq[A] =</a>
<a class="sourceLine" id="cb2-2" title="2">    Config.<span class="fu">regions</span>.<span class="fu">map</span>(region =&gt; mf.<span class="fu">runtimeClass</span>.<span class="fu">getConstructor</span>(classOf[String]).<span class="fu">newInstance</span>(region).<span class="fu">asInstanceOf</span>[A])</a></code></pre></div>
<p>This is something that you should avoid, as it leads to problems that are not detected by the compiler, only at runtime, every time you refactor something around these classes. There are some use cases where this may be required, like dynamically loading plugins or stuff like this, but to just have a factory for something, it is must simple to use… <strong>functions</strong>!</p>
<p>So I could not hold myself back and quickly changed this to:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> buildMirrors[A &lt;: RegionAwareAWSMirror[_, _]](factory: (String, ActorSystem) =&gt; A)</a>
<a class="sourceLine" id="cb3-2" title="2">    Config.<span class="fu">regions</span>.<span class="fu">map</span>(region =&gt; <span class="fu">factory</span>(region, system))</a></code></pre></div>
<p>(Since then even this has disappeared, but don’t run that much forward).</p>
<h2 id="async-fetching">Async fetching</h2>
<p>Ok so the first obvious step was to refactor the whole fetching code in a way that it is just a chain of <strong>futures</strong>. By making everything async in the process, the AWS calls would be simply replaceable with the throttling function above or anything more sophisticated!</p>
<p>But I knew that I cannot safely do this while the model we are building itself is mutable - there is no way I want to debug what happens with it once all the steps are really becoming parallel!</p>
<h3 id="immutable-model">Immutable model</h3>
<p>I believe the following GitHub diff captures the core change of this step:</p>
<p><img src="/images/prezidig-img-1.png" width="800"/></p>
<p>Of course I had to change all the subtypes of Model, and I went through the code looking for</p>
<ul>
<li><strong>var</strong>s</li>
<li>mutable collections</li>
</ul>
<p>and got rid of them. Except for the caching constructs, because I planned to refactor those in the next step, so for now I left them alone.</p>
<h3 id="async-mirrors">Async mirrors</h3>
<p>Once I felt the model is safe enough, I went to the next big change, making everything asynchronous.</p>
<p><img src="/images/prezidig-img-2.png" width="800"/></p>
<p>This took some hours, to be honest. But really, the core idea is only that the result must be a <code>Future[T]</code>, not <code>T</code>.</p>
<p>So how do you refactor a code that was previously half synchronous, half asynchronous to achieve this? Let’s see an example! It will be the <em>key-pair mirror</em> as it is the smallest.</p>
<p>Originally (with my ugly wrapping in the previous step) it looked like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1">  <span class="kw">override</span> <span class="kw">protected</span> <span class="kw">def</span> <span class="fu">fetch</span>(input: SimpleParsedInput, context: Context): Seq[KeyPair] =</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">try</span> {</a>
<a class="sourceLine" id="cb4-3" title="3">      <span class="kw">val</span> futureResult = <span class="fu">byHandlingThrottling</span>(</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="fu">buildClient</span>(AmazonEC2ClientBuilder.<span class="fu">standard</span>()).<span class="fu">describeKeyPairs</span>(</a>
<a class="sourceLine" id="cb4-5" title="5">          <span class="kw">new</span> <span class="fu">DescribeKeyPairsRequest</span>().<span class="fu">withKeyNames</span>(input.<span class="fu">id</span>)</a>
<a class="sourceLine" id="cb4-6" title="6">        ))</a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8">      <span class="kw">val</span> result = Await.<span class="fu">result</span>(futureResult, <span class="fl">10.</span>seconds)</a>
<a class="sourceLine" id="cb4-9" title="9">      result.<span class="fu">getKeyPairs</span>.<span class="fu">asScala</span>.<span class="fu">map</span>(info =&gt; KeyPair(info, region)).<span class="fu">seq</span></a>
<a class="sourceLine" id="cb4-10" title="10">        .<span class="fu">map</span>(keypair =&gt; keypair.<span class="fu">withFutureChildren</span>(<span class="fu">LaunchConfigurationMirror</span>(region, actorSystem).<span class="fu">apply</span>(context.<span class="fu">withInput</span>(keypair.<span class="fu">description</span>.<span class="fu">getKeyName</span>))))</a>
<a class="sourceLine" id="cb4-11" title="11">    } <span class="kw">catch</span> {</a>
<a class="sourceLine" id="cb4-12" title="12">      <span class="kw">case</span> _: AmazonEC2Exception =&gt; Seq()</a>
<a class="sourceLine" id="cb4-13" title="13">    }</a></code></pre></div>
<p>So as you can see fetching the key pairs by name was a synchronous request, but then the <em>launch configurations</em> are fetched asynchronously and are being updated back the result model in a mutable way. We want to transform this function so it does not have any side effects, just performs a chain of asynchronous operations and in the end have a fully fetched <em>key pair</em> with the related <em>launch configurations</em>.</p>
<p>In every case the only thing needed was a combination of <code>map</code> and <code>flatMap</code> on futures, and of course the <em>for syntax</em> can also be used to make the code more readable:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1"> <span class="kw">private</span> <span class="kw">def</span> <span class="fu">fetchKeyPair</span>(client: AmazonEC2, context: Context, info: KeyPairInfo): Future[KeyPair] = {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb5-3" title="3">      launchConfigurations &lt;- <span class="fu">LaunchConfigurationMirror</span>(region, actorSystem).<span class="fu">apply</span>(context.<span class="fu">withInput</span>(info.<span class="fu">getKeyName</span>))</a>
<a class="sourceLine" id="cb5-4" title="4">    } <span class="kw">yield</span> KeyPair(</a>
<a class="sourceLine" id="cb5-5" title="5">      description = info,</a>
<a class="sourceLine" id="cb5-6" title="6">      region = region,</a>
<a class="sourceLine" id="cb5-7" title="7">      children = launchConfigurations</a>
<a class="sourceLine" id="cb5-8" title="8">    )</a>
<a class="sourceLine" id="cb5-9" title="9">  }</a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11">  <span class="kw">override</span> <span class="kw">protected</span> <span class="kw">def</span> <span class="fu">fetch</span>(input: SimpleParsedInput, context: Context): Future[List[KeyPair]] = {</a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="kw">val</span> client = <span class="fu">buildClient</span>(AmazonEC2ClientBuilder.<span class="fu">standard</span>())</a>
<a class="sourceLine" id="cb5-13" title="13"></a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="fu">byHandlingThrottling</span>(client.<span class="fu">describeKeyPairs</span>(<span class="kw">new</span> <span class="fu">DescribeKeyPairsRequest</span>().<span class="fu">withKeyNames</span>(input.<span class="fu">id</span>))).<span class="fu">flatMap</span> { result =&gt;</a>
<a class="sourceLine" id="cb5-15" title="15">      Future.<span class="fu">sequence</span>(</a>
<a class="sourceLine" id="cb5-16" title="16">        result.<span class="fu">getKeyPairs</span>.<span class="fu">asScala</span>.<span class="fu">toList</span>.<span class="fu">map</span>(<span class="fu">fetchKeyPair</span>(client, context, _))</a>
<a class="sourceLine" id="cb5-17" title="17">      )</a>
<a class="sourceLine" id="cb5-18" title="18">    }.<span class="fu">recover</span> {</a>
<a class="sourceLine" id="cb5-19" title="19">      <span class="kw">case</span> _: AmazonEC2Exception =&gt; List() <span class="co">// TODO: log?</span></a>
<a class="sourceLine" id="cb5-20" title="20">    }</a>
<a class="sourceLine" id="cb5-21" title="21">  }</a></code></pre></div>
<p>Note that the <code>Future.sequence</code> function is quite useful in these scenarios, as it makes a <code>Future[List[T]]</code> from <code>List[Future[T]]</code>.</p>
<p>Of course the code became more verbose because of all this chaining, this is the price of this transformation. And why I don’t like to express complex logic with a chain of futures, rather with some higher level abstraction such as actors (or for this use case, streams would fit even better).</p>
<p>But I wanted to make iterative changes, so I did this transformation on all the mirrors and eventually got a <code>Future[List[Model]]</code> in the main function that I could await for. I also thrown out the global atomic integer that counted the running stuff for completion, as in this model the completion of the composed future should mark the end of the whole computation.</p>
<p>So did I succeed at this point? Of course not. Actually this whole thing is a big deadlock :)</p>
<h2 id="caching-and-circular-references">Caching and circular references</h2>
<p>It was not immediately obvious what causes the deadlock. In a system like this it can happen in different ways. For example I knew that there are global singleton caches in the code, protected by <strong>locks</strong>. This <em>could</em> cause deadlocks if all the executors got blocked and no new threads can be spawned by the active executor. I did not know if this is happening, but would not have been surprised at all, as much more things were happening in parallel because of the previous refactoring step.</p>
<p>And circular references in the huge chained future graph can also lead to this. Let’s consider this simplified example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">trait</span> Cache { </a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="kw">def</span> <span class="fu">get</span>(key: String): Future[Work]</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="kw">def</span> <span class="fu">put</span>(key: String, compute: () =&gt; Future[Work]): Unit</a>
<a class="sourceLine" id="cb6-4" title="4">}</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">val</span> cache: Cache = ???</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">val</span> work1: Future[Work] = cache.<span class="fu">get</span>(<span class="st">&quot;work2&quot;</span>).<span class="fu">map</span> { w2 =&gt; <span class="fu">Work</span>(s<span class="st">&quot;Hello $w2&quot;</span>)) }</a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">val</span> work2: Future[Work] = cache.<span class="fu">get</span>(<span class="st">&quot;work1&quot;</span>).<span class="fu">map</span> { w1 =&gt; <span class="fu">Work</span>(s<span class="st">&quot;Hello $w1&quot;</span>)) }</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10">cache.<span class="fu">put</span>(work1)</a>
<a class="sourceLine" id="cb6-11" title="11">cache.<span class="fu">put</span>(work2)</a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="fu">println</span>(Await.<span class="fu">result</span>(work1), <span class="fl">1.</span>second)</a></code></pre></div>
<p>This can never work. If you think about what <strong>prezidig</strong> does, you will have a feeling that this happens. A lot.</p>
<p>But let’s go in order.</p>
<h3 id="non-blocking-cache">Non-blocking cache</h3>
<p>First I wanted to get rid of the global, lock-protected mutable maps used as caches, and have a non-blocking implementation with more control and better performance and safety. This is the kind of job that an <strong>actor</strong> can model nicely, so I created a <em>model cache actor</em> that is spawned for <em>each mirror</em> and can store and retrieve lists of AWS models for a given key.</p>
<p>I won’t list the whole actor’s code here, let’s see the messages it consumes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1">  <span class="kw">sealed</span> <span class="kw">trait</span> ModelCacheMessage[M &lt;: Model]</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Put[M &lt;: Model](key: String, value: List[M])</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">extends</span> ModelCacheMessage[M]</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> FetchFailed[M &lt;: Model](key: String, failure: Failure[_])</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="kw">extends</span> ModelCacheMessage[M]</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> GetOrFetch[M &lt;: Model](key: String, fetch: () =&gt; Future[List[M]], respondTo: ActorRef[Try[List[M]]])</a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="kw">extends</span> ModelCacheMessage[M]</a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12">  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> GetRefOrFetch[M &lt;: Model](key: String, fetch: () =&gt; Future[List[M]], respondTo: ActorRef[ModelRef[M]])</a>
<a class="sourceLine" id="cb7-13" title="13">    <span class="kw">extends</span> ModelCacheMessage[M]</a>
<a class="sourceLine" id="cb7-14" title="14"></a>
<a class="sourceLine" id="cb7-15" title="15">  <span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> Dump[M &lt;: Model](respondTo: ActorRef[Map[String, List[M]]])</a>
<a class="sourceLine" id="cb7-16" title="16">    <span class="kw">extends</span> ModelCacheMessage[M]</a></code></pre></div>
<p>This cache itself is responsible for executing the <em>fetch function</em> only if needed, when the value for the given key is not cached yet. It is done by using the <strong>pipe pattern</strong>: it starts the asynchronous fetch function on a configured worker executor (which can be the actor system, or a fix thread pool, etc.) and registers an <code>onFinish</code> callback for the future which <em>pipes back</em> the future’s result to the actor as actor messages (<code>Put</code> and <code>FetchFailed</code>).</p>
<p>I will talk about references and cache dumps in the next section.</p>
<p>There was one more big problem with the existing code that prevented introducing these cache actors: that the mirrors were not really singletons but some mirrors created new instances of existing mirrors (without any difference to the ones created in the main function). These shared the singleton mutable lock-protected cache map in the original version, that’s why it worked. But in the new implementation each mirror spawned its own cache actor, so it was no longer allowed to create multiple instances of the same thing.</p>
<p>So in this step I collected all the mirrors to a class called <code>Mirrors</code>, which later became the collection of all the resources needed to perform the “dig”, so in the final version it is called <code>DigSite</code>.</p>
<p>With this change the caching could be replaced, and with the <strong>ask pattern</strong> I was able to fit it to the chain of futures created in the previous step.</p>
<p>Did it solve the deadlock? No, of course not</p>
<h3 id="circular-references">Circular references</h3>
<p>But now it was obvious that there are some circular references. And by simply drawing it, I could see that this is actually the core concept of the whole thing :)</p>
<p>Let me show you <em>the drawing</em>:</p>
<p><img src="/images/prezidig-img-3.png" width="800"/></p>
<p>So everything refers back to everything, not a surprise that this chained-together code cannot finish.</p>
<p>To be honest, I was not sure how exactly did it work in the original version, whether the boundary of sync and async calls were carefully designed to make this work or just accidentally, whatever.</p>
<p>I wanted to have a solution where you don’t have to think about it so nobody will fuck it up next time when it has to be modified.</p>
<p>The chosen solution can be summarized in the following way:</p>
<ul>
<li>The <em>models</em> are only storing <strong>references to other models</strong> encoded by the <code>ModelRef</code> type. A reference is basically selecting a mirror (by its <em>cache</em>) and an item in it by its <em>key</em></li>
<li>When fetching a model, you immediately get back a <em>model reference</em> from the cache so it can be stored in the owner model, even with circular references. The real data is still fetched and cached as before.</li>
<li>This works because nobody uses the actual child models until the <strong>rendering</strong> of the output. So we have the asynchronous, parallel fetching of all the models, and then a completely separate, non-async step where we need the real connections to actually render the output based on the templates. I could change how the rendering works to query the model references from the cache, but I did not want to touch that part. So I introduced a middle step where all the <em>model cache actors</em> <strong>dump</strong> their state to simple immutable maps, and then the model gets <em>updated</em> by selecting the referenced models from this map and changing a field. Yes, a mutable field. It is a non-threadsafe operation that has a single, well defined place to be called, and this way the whole third part (rendering the output) could remain untouched.</li>
<li>Because of decoupling the actual fetching from the result future (it is completed earlier, as it only needs the references!), I had to have something that keeps track of the ongoing tasks ran by the cache actors, so there is also a <em>work monitor actor</em> that notifies the main logic once everything is complete.</li>
</ul>
<p>Considering all this, the main steps before starting to render the output looks like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">val</span> result = <span class="kw">for</span> {</a>
<a class="sourceLine" id="cb8-2" title="2">    models &lt;- <span class="fu">runRelevantMirrors</span>(digSite.<span class="fu">allMirrors</span>, Context.<span class="fu">initial</span>(input))</a>
<a class="sourceLine" id="cb8-3" title="3">    fetchingDone &lt;- digSite.<span class="fu">workMonitor</span> ? WorkMonitor.<span class="fu">WaitForReady</span></a>
<a class="sourceLine" id="cb8-4" title="4">    cacheDumps &lt;- CacheDumps.<span class="fu">fromMirrors</span>(digSite.<span class="fu">allMirrors</span>)</a>
<a class="sourceLine" id="cb8-5" title="5">    _ = models.<span class="fu">foreach</span>(_.<span class="fu">resolveChildren</span>(cacheDumps)) <span class="co">// side effect!</span></a>
<a class="sourceLine" id="cb8-6" title="6">} <span class="kw">yield</span> models</a></code></pre></div>
<h2 id="anyone-else-blocking">Anyone else blocking?</h2>
<p>At this point the tool started to work again and produce results. So I went back checking if any other blocking code remained that can be implemented in other ways. The progress tracker was like that, it had mutable state and locks, so I converted that to an actor too. It was quite simple, and on the usage side almost nothing changed compared to the original.</p>
<h2 id="and-what-about-the-throttling">And what about the throttling?</h2>
<p>Ok so at this point I refactored the whole stuff but still did not solve the throttling issue, right?</p>
<p>Right.</p>
<p>But now finally I knew how to do it!</p>
<p>I already wrapped all AWS calls with that specific function (and at this point it was really <em>all</em> calls, not just <em>almost)</em>. So I just had to write it in a better way.</p>
<p>I wanted to:</p>
<ul>
<li>Have control on how many AWS requests are we doing in parallel</li>
<li>In case of throttling errors delay <strong>everything</strong> as soon as possible</li>
</ul>
<p>This can be achieved easily by some standard patterns like treating AWS as an encapsulated resource and putting some circuit breaking logic in it, and explicitly distributing the work among multiple workers.</p>
<p>Let’s see the designed solution on a drawing:</p>
<p><img src="/images/prezidig-img-4.png" width="800"/></p>
<p><strong>Note</strong>: the <em>classic Akka</em> has built-in support for this routing and circuit breaking, but I prefer <em>Akka-typed</em> because of its type safety, where there are no official reusable higher level components like this yet. The one I implemented here is quite specific, later could be refactored to be built from more reusable typed actor components.</p>
<p>So how does this work?</p>
<ul>
<li>There is a single coordinator actor called <strong>AWS</strong> and multiple (32 by default) worker actors called <strong>AWS Worker</strong>.</li>
<li>The number of worker actors control the maximum number of parallel AWS operations, because each worker actor is guaranteed to run maximum one such operation at the same time. All the other incoming requests are distributed among the workers and gets enqueued.</li>
<li>The AWS calls are executed on a different thread pool, not blocking the actors. Their result is sent back by the already mentioned <em>pipe to</em> pattern</li>
<li>AWS throttling errors are detected on the worker nodes, and the worker node immediately switches to <strong>open circuit state</strong> in which it does not start any new AWS command. The length of the open state increases with every throttling error, and gets reseted after a number of successful requests.</li>
<li>Opening the circuit breaker on one worker node is immediately followed by opening it on <strong>all other</strong> worker nodes too, to stop overloading AWS.</li>
</ul>
<p>This could be further improved with more advanced logic but I believe it is good enough for our current purposes, and now we can use <strong>prezidig</strong> again!</p>
]]></summary>
</entry>
<entry>
    <title>Bari with Visual Studio Code</title>
    <link href="http://vigoo.github.io/posts/2016-01-21-bari-vscode.html" />
    <id>http://vigoo.github.io/posts/2016-01-21-bari-vscode.html</id>
    <published>2016-01-21T00:00:00Z</published>
    <updated>2016-01-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 21, 2016
    
</div>

<h2 id="intro">Intro</h2>
<p>A few weeks ago I discovered <a href="https://code.visualstudio.com/">Visual Studio Code</a> and started using it for some of my work. <em>(Note: I’m using multiple editors/IDEs all the time, based on the task; Emacs, Sublime, Atom, IntelliJ, VS, etc.)</em> So far <em>Code</em> is my favourite among the set of similar editors, such as Atom. I was pleasently surprised how well it works with its integrated <a href="http://www.omnisharp.net/">OmniSharp</a> plugin on <a href="http://vigoo.github.io/bari/">bari’s</a> codebase, so I decided to try to write a <em>bari plugin</em> for it.</p>
<p>Writing an extension for <em>Code</em> was a nice experience. The outcome is the <a href="https://marketplace.visualstudio.com/items/vigoo.bari">bari build management extension</a>, which I’ll demonstrate in the next section.</p>
<h2 id="developing-.net-applications-with-visual-studio-code-and-bari">Developing .NET applications with Visual Studio Code and bari</h2>
<p>As <em>Code</em> is multiplatform, and <em>bari</em> also works with <a href="http://www.mono-project.com/">Mono</a>, I’ll demonstrate how you can use these tools to develop a .NET application (actually <em>bari</em> itself) on a Mac. The steps here (except installing Mono) would be the same on Windows or Linux as well.</p>
<h3 id="installing-the-tools">Installing the tools</h3>
<p>First, if you are not on Windows, you’ll have to install the latest <a href="http://www.mono-project.com/">Mono</a> framework. On OSX I recommed to use <a href="http://brew.sh/"><code>brew</code></a> to do that:</p>
<pre><code>brew install mono
mono --version</code></pre>
<p>Then get the latest <a href="https://code.visualstudio.com/">Visual Studio Code</a> version, either by downloading it from its homepage or with <a href="https://github.com/caskroom/homebrew-cask"><code>brew cask</code></a>:</p>
<pre><code>brew cask install visual-studio-code</code></pre>
<p>Get the latest <em>bari</em>. On Windows I recommend downloading and extracting the <a href="https://github.com/vigoo/bari/releases/latest">latest official release</a> and adding it to the <code>PATH</code>. On OSX, with <code>mono</code> we already have <code>nuget</code>, so let’s use that:</p>
<pre><code>cd /opt
nuget install bari-mono
ln -s bari-mono.1.0.2.2 bari</code></pre>
<p>and create a script to execute it somewhere in your <code>PATH</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="co">#!/bin/sh</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ex">mono</span> /opt/bari/tools/bari.exe <span class="va">$@</span></a></code></pre></div>
<p>That’s it. Future versions of the <em>bari extension</em> will probably be able to install <em>bari</em> itself.</p>
<p>Let’s start <em>Code</em> now!</p>
<h3 id="installing-the-extension">Installing the extension</h3>
<p>Open the <em>command palette</em> (F1, or ⇧⌘P) and type <code>ext install bari</code> <a href="/images/baricode1.png" class="zimg"><img width="600" src="/images/baricode1.png" alt="bari-code-1"></a></p>
<h3 id="loading-the-project">Loading the project</h3>
<p>After that restart the editor. Have your bari-built project available somewhere. As we are going to develop bari itself, let’s clone its repository:</p>
<pre><code>git clone https://github.com/vigoo/bari.git</code></pre>
<p>Then open the result <code>bari</code> directory with <em>Code</em>. This should look like the following:</p>
<p><a href="/images/baricode2.png" class="zimg"><img width="800" src="/images/baricode2.png" alt="bari-code-2"></a></p>
<p>The <em>bari plugin</em> automatically detected that the opened folder has a <code>suite.yaml</code> in its root, and loaded it. That’s why we can see the two sections on the statusbar’s right side: <code>full</code> and <code>debug</code>. The first one is the <a href="https://github.com/vigoo/bari/wiki/Product">selected target product</a> and the second one is the <a href="https://github.com/vigoo/bari/wiki/Goal">selected goal</a>. All the <em>bari commands</em> provided by the extension will be executed with these settings.</p>
<h3 id="changing-the-target">Changing the target</h3>
<p>To change the active product or goal, you can click on the statusbar or use the <em>command palette</em> (F1, or ⇧⌘P) and choose <code>bari: Change goal</code> or <code>bari: Change target product</code>.</p>
<p>Let’s change the <em>goal</em> to <code>debug-mono</code>, as we are working on a non-Windows environment:</p>
<p><a href="/images/baricode3.png" class="zimg"><img width="800" src="/images/baricode3.png" alt="bari-code-3"></a></p>
<h3 id="generating-the-solution">Generating the solution</h3>
<p>The next step before starting coding is to actually <strong>generate</strong> the solution and projects files (and fetch the dependencies, etc.) so <em>OmniSharp</em> can load it and provide code completion, analysis, etc. features.</p>
<p>To do so, just use the <em>command palette</em> and choose <code>bari: Regenerate solution</code>, which <a href="https://github.com/vigoo/bari/wiki/VsCommand">runs the <code>bari vs</code> command</a> with the correct parameters. The command’s output is displayed in an <em>output panel</em> called <code>bari</code>. This looks like the following:</p>
<p><a href="/images/baricode4.png" class="zimg"><img width="800" src="/images/baricode4.png" alt="bari-code-4"></a></p>
<p>There’s nothing else left than pointing <em>OmniSharp</em> to the generated solution, with the following command:</p>
<p><a href="/images/baricode5.png" class="zimg"><img width="800" src="/images/baricode5.png" alt="bari-code-5"></a></p>
<p>It will automatically find the generated <code>.sln</code> file, just select the correct one:</p>
<p><a href="/images/baricode6.png" class="zimg"><img width="800" src="/images/baricode6.png" alt="bari-code-6"></a></p>
<p>In a few seconds (and with a few warnings for this project), <em>OmniSharp</em> works. To see what it can do, <a href="https://code.visualstudio.com/Docs/languages/csharp">check this page</a>. A simple example is to jump to a given class or interface with ⌘P:</p>
<p><a href="/images/baricode7.png" class="zimg"><img width="600" src="/images/baricode7.png" alt="bari-code-7"></a></p>
<h3 id="working-on-the-project">Working on the project</h3>
<p>You can work on the project and build it from <em>Code</em> or run its tests using the <code>bari: Build</code> and <code>bari: Test</code> commands. The build output will be shown just like in the <em>solution generation step</em>.</p>
<p><a href="/images/baricode8.png" class="zimg"><img width="600" src="/images/baricode8.png" alt="bari-code-8"></a></p>
<p>Whenever the suite definition itself must be modified, you can jump there with the <code>bari: Open suite.yaml</code> command and then just regenerate the solution as it was shown above.</p>
<h2 id="implementation">Implementation</h2>
<p>The implementation was really straightforward. The source code <a href="https://github.com/vigoo/bari-code">can be found here</a>. It’s basically a <em>JSON</em> defining how the plugin is integrated and some implementation code in <em>TypeScript</em>. It’s easy to run and debug the plugin from <em>Code</em> itself.</p>
<p>For example the following section from the extension definition describes what events triggers the extension:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb6-1" title="1"><span class="er">&quot;activationEvents&quot;:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="st">&quot;onCommand:bari.build&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="st">&quot;onCommand:bari.test&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="st">&quot;onCommand:bari.vs&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="st">&quot;onCommand:bari.openSuiteYaml&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="st">&quot;onCommand:bari.selfUpdate&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="st">&quot;onCommand:bari.goal.changeCurrentGoal&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="st">&quot;onCommand:bari.goal.changeCurrentProduct&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="st">&quot;workspaceContains:suite.yaml&quot;</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="ot">]</span><span class="er">,</span></a></code></pre></div>
<p>It’s either done by invoking one of the defined commands from the <em>command palette</em>, or if the opened workspace contains a <code>suite.yaml</code>. The latter enables the extension to parse the suite definition and initialize the statusbar immediately one the suite has been opened.</p>
<p>The package definition also specifies the provided configuration values, such as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb7-1" title="1"><span class="er">&quot;bari.commandLine&quot;:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">	<span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;string&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb7-3" title="3">	<span class="dt">&quot;default&quot;</span><span class="fu">:</span> <span class="st">&quot;bari&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb7-4" title="4">	<span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Command line to execute bari&quot;</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="fu">}</span><span class="er">,</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="er">&quot;bari.verboseOutput&quot;:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb7-7" title="7">	<span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;boolean&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb7-8" title="8">	<span class="dt">&quot;default&quot;</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb7-9" title="9">	<span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Turns on verbose output for all the executed bari commands&quot;</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="fu">}</span></a></code></pre></div>
<p>The implementation itself is really simple, all the user interface elements involved such as the console output window, the command palette, the statusbar panels can be easily managed.</p>
<p>For example the panel showing <code>bari</code>’s output is created by the following code snippet:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">var</span> channel <span class="op">=</span> <span class="va">vscode</span>.<span class="va">window</span>.<span class="at">createOutputChannel</span>(<span class="st">&#39;bari&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="va">channel</span>.<span class="at">show</span>()<span class="op">;</span></a></code></pre></div>
<p>Or to display the result of an operation:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="va">vscode</span>.<span class="va">window</span>.<span class="at">showErrorMessage</span>(<span class="st">&quot;No suite.yaml in the current workspace!&quot;</span>)</a></code></pre></div>
<p>or to create the statusbar panel:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">this</span>.<span class="at">goals</span> <span class="op">=</span> <span class="va">vscode</span>.<span class="va">window</span>.<span class="at">createStatusBarItem</span>(<span class="va">vscode</span>.<span class="va">StatusBarAlignment</span>.<span class="at">Right</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">this</span>.<span class="va">goals</span>.<span class="at">command</span> <span class="op">=</span> <span class="st">&#39;bari.goal.changeCurrentGoal&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">this</span>.<span class="va">goals</span>.<span class="at">show</span>()<span class="op">;</span></a></code></pre></div>
<p>This API is simple and well documented enough so basic integrations like this can be done in an hour.</p>
]]></summary>
</entry>
<entry>
    <title>Gradle-Haskell-plugin with experimental Stack support</title>
    <link href="http://vigoo.github.io/posts/2015-12-22-gradle-haskell-plugin-stack.html" />
    <id>http://vigoo.github.io/posts/2015-12-22-gradle-haskell-plugin-stack.html</id>
    <published>2015-12-22T00:00:00Z</published>
    <updated>2015-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December 22, 2015
    
</div>

<p>I’ve released a <strong>new version (0.4)</strong> of <a href="https://github.com/prezi/gradle-haskell-plugin">gradle-haskell-plugin</a> today, with <strong>experimental stack support</strong>. It is not enabled by default, but I used it exclusively for months and it seems to get quite stable. To use it you need <a href="https://haskellstack.com">stack</a>, have it enabled with <code>-Puse-stack</code> and have to keep some rules in your <code>.cabal</code> file, as explained <a href="https://github.com/prezi/gradle-haskell-plugin#explanation-stack-mode">in the README</a>.</p>
<h2 id="how-does-it-work">How does it work?</h2>
<p>The core idea did not change <a href="http://vigoo.github.io/posts/2015-04-22-gradle-haskell-plugin.html">compared to the original, cabal based solution</a>.</p>
<p>To support chaining the binary artifacts, I had to add a new option to <em>stack</em> called <a href="https://github.com/commercialhaskell/stack/pull/990">extra package databases</a>. The databases listed in this section are passed <em>after the global</em> but <strong>before</strong> the snapshot and the local databases, which means that the snapshot database cannot be used (the packages in the binary artifacts are not “seeing” them). This sounds bad, but <em>gradle-haskell-plugin</em> does a workaround; it <strong>generates</strong> the <code>stack.yaml</code> automatically, and in a way that:</p>
<ul>
<li>it disables snapshots on stack level (uses a resolver like <code>ghc-7.10.2</code>)</li>
<li>lists all the dependencies explicitly in <code>extra-deps</code></li>
<li>but it still figures out the <em>versions</em> of the dependencies (to be listed in <code>extra-deps</code>) based on a given <em>stackage snapshot</em>!</li>
</ul>
<p>With this approach we get the same behavior that was already proven in cabal mode, but with the advantage that the generated <code>stack.yaml</code> completely defines the project for any tool that knows stack. So after gradle extracted the dependencies and generated the <code>stack.yaml</code>, it is no longer needed to succesfully compile/run/test the project, which means that tools like IDE integration will work much better than with the more hacky cabal mode of the plugin.</p>
]]></summary>
</entry>
<entry>
    <title>Case Study - Haskell at Prezi</title>
    <link href="http://vigoo.github.io/posts/2015-09-21-haskell-case-study.html" />
    <id>http://vigoo.github.io/posts/2015-09-21-haskell-case-study.html</id>
    <published>2015-09-21T00:00:00Z</published>
    <updated>2015-09-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 21, 2015
    
</div>

<p>I wrote a <em>case study</em> for <a href="http://www.fpcomplete.com">FPComplete</a> on how we use Haskell at <a href="https://prezi.com">Prezi</a>. It is published <a href="https://www.fpcomplete.com/page/case-study-prezi">here</a>, but I’m just posting it here as well:</p>
<p><a href="https://prezi.com">Prezi</a> is a cloud-based presentation and storytelling tool, based on a zoomable canvas. The company was founded in 2009, and today we have more than 50 million users, with more than 160 million prezis created.</p>
<p>The company is using several different platforms and technologies; one of these is <em>Haskell</em>, which we are using server side, for code generation and for testing.</p>
<h2 id="pdom">PDOM</h2>
<p>Prezi’s document format is continuously evolving as we add features to the application. It is very important for us that this format is handled correctly on all our supported platforms, and both on client and server side. To achieve this, we created an eDSL in Haskell that defines the schema of a Prezi. From this schema we are able to generate several artifacts.</p>
<p>Most importantly we are generating a <em>Prezi Document Object Model (PDOM)</em> library for multiple platforms - Haxe (compiled to JS) code for the web, C++ code for the native platforms, and Haskell code for our tests, tools and the server side. These libraries are responsible for loading, updating, maintaining consistency and saving Prezis.</p>
<p>This API also implements <em>collaborative editing</em> functionality by transparently synchronising document changes between multiple clients. This technique is called <a href="https://en.wikipedia.org/wiki/Operational_transformation">operational transformation (OT)</a>. We implemented the server side of this in Haskell; it supports clients from any of the supported platforms and it is connected to several other backend services.</p>
<h2 id="benefits">Benefits</h2>
<p>Using <em>Haskell</em> for this project turned out to have huge benefits.</p>
<p>We are taking advantage of Haskell’s capabilities to create embedded domain specific languages, using it to define the document’s schema in our own eDSL which is used not only by Haskell developers but many others too.</p>
<p>Haskell’s clean and terse code allows us to describe document invariants and rules in a very readable way and the type system guarantees that we handle all the necessary cases, providing a stable base Haskell implementation which we can compare the other language backends to.</p>
<p>It was also possible to define a set of merge laws for OT, which are verified whenever we introduce a new element to the document schema, guaranteeing that the collaboration functionality works correctly.</p>
<p>We use the <em>QuickCheck</em> testing library on all levels. We can generate arbitrary Prezi documents and test serialization on all the backends. We are even generating arbitrary JavaScript code which uses our generated API to test random collaborative network sessions. These tests turned out to be critical for our success as they caught many interesting problems before we deployed anything to production</p>
]]></summary>
</entry>
<entry>
    <title>Haskell plugin for Gradle</title>
    <link href="http://vigoo.github.io/posts/2015-04-22-gradle-haskell-plugin.html" />
    <id>http://vigoo.github.io/posts/2015-04-22-gradle-haskell-plugin.html</id>
    <published>2015-04-22T00:00:00Z</published>
    <updated>2015-04-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on April 22, 2015
    
</div>

<p>My team at <a href="https://prezi.com">Prezi</a> uses <strong>Haskell</strong> for several projects, which usually depend on each other, often with build steps using other languages such as Scala, C++ or Haxe. As <a href="https://gradle.org/">Gradle</a> is used heavily in the company, we decided to try to integrate our Haskell projects within Gradle.</p>
<p>The result is <a href="https://github.com/prezi/gradle-haskell-plugin">Gradle Haskell Plugin</a>, which we were using succesfully in the last 2 months in our daily work, and we have <em>open-sourced</em> recently.</p>
<p>What makes this solution interesting is that it not just simply wraps <em>cabal</em> within Gradle tasks, but implements a way to define <strong>dependencies</strong> between Haskell projects and to upload the binary Haskell artifacts to a <em>repository</em> such as <a href="http://www.jfrog.com/open-source/">artifactory</a>.</p>
<p>This makes it easy to modularize our projects, publish them, and also works perfectly with <a href="https://github.com/prezi/pride">pride</a>, an other <em>open-source</em> Prezi project. This means that we can work on a subset of our Haskell projects while the other dependencies are built on Jenkins, and it also integrates well with our non-Haskell projects.</p>
<h2 id="how-does-it-work">How does it work?</h2>
<p>The main idea is that we let <em>cabal</em> manage the Haskell packages, and handle whole Haskell <em>sandboxes</em> on Gradle level. So if you have a single Haskell project, it will be built using <em>cabal</em> and the result sandbox (the built project together with all the dependent cabal packages which are not installed in the <em>global package database</em>) will be packed/published as a Gradle <em>artifact</em>.</p>
<p>This is not very interesting so far, but when you introduce dependencies on Gradle level, the plugin does something which (as far as I know) is not really done by anyone else, which I call <em>sandbox chaining</em>. This basically means that to compile the haskell project, the plugin will pass all the dependent sandboxes’ package database to cabal and GHC, so for the actual sandbox only the packages which are <strong>not</strong> in any of the dependent sandboxes will be installed.</p>
<h2 id="example">Example</h2>
<p>Let’s see an example scenario with <em>4 gradle-haskell projects</em>.</p>
<p><a href="https://raw.githubusercontent.com/prezi/gradle-haskell-plugin/master/doc/gradle-haskell-plugin-drawing1.png" class="zimg"><img width="600" src="https://raw.githubusercontent.com/prezi/gradle-haskell-plugin/master/doc/gradle-haskell-plugin-drawing1.png" alt="gradle-haskell-plugin"></a></p>
<p>The project called <em>Haskell project</em> depends on two other projects, which taking into accound the transitive dependencies means it depends on <em>three other haskell projects</em>. Each project has its own haskell source and <em>cabal file</em>. Building this suite consists of the following steps:</p>
<ul>
<li><strong>dependency 1</strong> is built using only the <em>global package database</em>, everything <strong>not</strong> in that database, together with the compiled project goes into its <code>build/sandbox</code> directory, which is a combination of a <em>GHC package database</em> and the project’s build output. This is packed as <strong>dependency 1</strong>’s build artifact.</li>
<li>For <strong>dependency 2</strong>, Gradle first downloads the build artifact of <em>dependency 1</em> and extracts it to <code>build/deps/dependency1</code>.</li>
<li>Then it runs <a href="https://github.com/exFalso/sandfix">SandFix</a> on it</li>
<li>And compiles the second project, now passing <strong>both</strong> the <em>global package database</em> and <strong>dependency 1</strong>’s sandbox to cabal/ghc. The result is that only the packages which are <strong>not</strong> in any of these two package databases will be installed in the project’s own sandbox, which becomes the build artifact of <strong>dependency 2</strong>.</li>
<li>For <strong>dependency 3</strong>, Gradle extracts both the direct dependency and the transitive dependency’s sandbox, to <code>build/deps/dependency2</code> and <code>build/deps/dependency3</code>.</li>
<li>Then it runs <a href="https://github.com/exFalso/sandfix">SandFix</a> on both the dependencies</li>
<li>And finally passes three package databases to cabal/ghc to compile the project. Only those cabal dependencies will be installed into this sandbox which are not in global, neither in any of the dependent sandboxes.</li>
<li>Finally, for <strong>Haskell project</strong> it goes the same way, but here we have three sandboxes, all chained together to make sure only the built sandbox only contains what is not in the dependent sandboxes yet.</li>
</ul>
<p>For more information, check out <a href="https://github.com/prezi/gradle-haskell-plugin">the documentation</a>.</p>
]]></summary>
</entry>
<entry>
    <title>bari 1.0 released</title>
    <link href="http://vigoo.github.io/posts/2014-12-08-bari-1-0.html" />
    <id>http://vigoo.github.io/posts/2014-12-08-bari-1-0.html</id>
    <published>2014-12-08T00:00:00Z</published>
    <updated>2014-12-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on December  8, 2014
    
</div>

<p>I already wrote about <a href="http://vigoo.github.io/bari">bari</a> in <a href="http://vigoo.github.io/2014/05/16/introducing-bari.html">May</a>.</p>
<p>As a reminder, <a href="http://vigoo.github.io/bari">bari</a> is a <em>build management system</em> primarily for .NET, trying to fix Visual Studio’s bad parts while keeping the good ones.</p>
<p>After more than two years of development, and being in production at <a href="http://www.kotem.com/">KOTEM</a> for almost half a year, bari reached a state when it can be considered as a <em>stable</em> and <em>usable</em> first version.</p>
<p>To indicate this today I released <strong>bari 1.0</strong>.</p>
<p>Try it out and feel free to give any kind of feedback or ask any questions!</p>
<p><img src="http://vigoo.github.io/bari/img/barilogo-small.png" /></p>
]]></summary>
</entry>
<entry>
    <title>ScalaFXML 0.2.2 available</title>
    <link href="http://vigoo.github.io/posts/2014-10-22-scalafxml-0-2-2.html" />
    <id>http://vigoo.github.io/posts/2014-10-22-scalafxml-0-2-2.html</id>
    <published>2014-10-22T00:00:00Z</published>
    <updated>2014-10-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October 22, 2014
    
</div>

<p>I’ve released a new version of <a href="https://github.com/vigoo/scalafxml">ScalaFXML</a>, which now supports <em>both</em> <a href="https://github.com/scalafx/scalafx">ScalaFX 8</a> with <em>JavaFX 8</em> on Java 8, and <a href="https://github.com/scalafx/scalafx">ScalaFX 2.2</a> with <em>JavaFX 2.x</em> on Java 7.</p>
<p>The two branches are separated by the <code>sfx2</code> and <code>sfx8</code> postfixes, and both are available for <em>Scala</em> <code>2.10.x</code> and <code>2.11.x</code>.</p>
<p>To use it with <a href="http://www.scala-sbt.org/">sbt</a> on Java 7:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">addCompilerPlugin</span>(<span class="st">&quot;org.scalamacros&quot;</span> % <span class="st">&quot;paradise&quot;</span> % <span class="st">&quot;2.0.1&quot;</span> cross CrossVersion.<span class="fu">full</span>)</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">libraryDependencies += <span class="st">&quot;org.scalafx&quot;</span> %% <span class="st">&quot;scalafx&quot;</span> % <span class="st">&quot;2.2.67-R10&quot;</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">libraryDependencies += <span class="st">&quot;org.scalafx&quot;</span> %% <span class="st">&quot;scalafxml-core-sfx2&quot;</span> % <span class="st">&quot;0.2.2&quot;</span></a></code></pre></div>
<p>And on Java 8:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">addCompilerPlugin</span>(<span class="st">&quot;org.scalamacros&quot;</span> % <span class="st">&quot;paradise&quot;</span> % <span class="st">&quot;2.0.1&quot;</span> cross CrossVersion.<span class="fu">full</span>)</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">libraryDependencies += <span class="st">&quot;org.scalafx&quot;</span> %% <span class="st">&quot;scalafx&quot;</span> % <span class="st">&quot;8.0.20-R6&quot;</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">libraryDependencies += <span class="st">&quot;org.scalafx&quot;</span> %% <span class="st">&quot;scalafxml-core-sfx8&quot;</span> % <span class="st">&quot;0.2.2&quot;</span></a></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>A python/thrift profiling story</title>
    <link href="http://vigoo.github.io/posts/2014-09-15-thrift-profiling.html" />
    <id>http://vigoo.github.io/posts/2014-09-15-thrift-profiling.html</id>
    <published>2014-09-15T00:00:00Z</published>
    <updated>2014-09-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on September 15, 2014
    
</div>

<p>A few weeks ago I met a problem where a script, running once every night sending out some emails did not run correctly because a remote thrift call timed out in it. As I started investigating it, turned out that it’s a <em>search</em> call:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">staff_users <span class="op">=</span> RemoteUserFactory().search(is_staff<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<p>The details here are not really important, what this call does is that it asks a service to return a <em>set of users</em>, and the communication is going on <a href="https://thrift.apache.org/">thrift</a>.</p>
<p>Executing it manually on the server revealed that it should return <em>5649</em> users. Checking out the logs I could see that the call took extremely long time, between 8 to 12 seconds. Even when the cron job was moved from 3:00 AM to a less busy time (several other jobs were executing at the same time), it took more than 6 seconds!</p>
<p>This was suspicious so I also checked the log of a <em>proxy</em> which runs on the same host as the script itself and provides client side load balancing, circuit breaking, retry logic etc. for thrift connections. This log showed that the service replied in <em>2.5 seconds</em>, but it took almost 4 seconds to get this response from the proxy to the client on localhost! This seemed to be completely unacceptable, and also the 2.5 second response time from the service seemed to be too big (I ran the query on one of the server nodes and it returned the users from the database almost instantly). I also had similar experience (but without measurements) before.</p>
<p>So I decided to find out what’s going on. And I found the process interesting enough to write this post about it :)</p>
<h2 id="test-environment">Test environment</h2>
<p>I started by adding a test method to the service’s thrift API called <code>test_get_users(count, sleep)</code> which returns <code>count</code> fake users after waiting <code>sleep</code> seconds. Then in the following experiments I called it with <code>(5499, 1)</code>. The 1 second sleep was intended to simulate the network latency and database query; there was no advantage from having it at the end, but as it is visible everywhere in the results, I had to mention.</p>
<p>For finding out what’s going on I used <a href="https://docs.python.org/2/library/profile.html">cProfile</a> with <a href="https://code.google.com/p/jrfonseca/">gprof2dot</a>, calling the remote test method from a django shell, while everything is running on localhost.</p>
<h3 id="first-measurement">First measurement</h3>
<p>Without touching anything, returning 5499 dummy users on localhost took <strong>5.272 seconds</strong>!</p>
<p>The client side of the call looked like this:</p>
<p><a href="/images/profile1.png" class="zimg"><img width="600" src="/images/profile1.png" alt="profile1"></a></p>
<p>Here we can see that the call has two major phases:</p>
<ul>
<li>The thrift call itself (65%)</li>
<li>Converting the raw results to model objects with <code>_row_to_model</code> (35%)</li>
</ul>
<p>Let’s see first the thrift call (the green branch on the picture). Once again it has two, nearly equivalent branches:</p>
<ul>
<li><code>send_test_get_users</code> which sends the request and waits for the response. This includes the 1 second sleep as well.</li>
<li><code>recv_test_get_users</code> processes the response</li>
</ul>
<p>What’s interesting here is that <code>recv_test_get_users</code> took ~32% of the overall time which is around ~1.6 seconds for simple data deserialization.</p>
<h3 id="optimizing-thrift-deserialization">Optimizing thrift deserialization</h3>
<p>I did not want to believe that the python thrift deserialization is that slow, so I did a search and found that the <code>TBinaryProtocol</code> which we are using is really that slow.</p>
<p>But the thrift library contains a class called <code>TBinaryProtocolAccelerated</code> which is about 10x faster (according to a stackoverflow post).</p>
<p>First I simply changed the used protocol to this, but nothing happened. Digging deeper I found that this is not a real protocol implementation, but a lower level hack.</p>
<p>The documentation of the protocol class says:</p>
<pre><code>  C-Accelerated version of TBinaryProtocol.

  This class does not override any of TBinaryProtocol&#39;s methods,
  but the generated code recognizes it directly and will call into
  our C module to do the encoding, bypassing this object entirely.
  We inherit from TBinaryProtocol so that the normal TBinaryProtocol
  encoding can happen if the fastbinary module doesn&#39;t work for some
  reason.  (TODO(dreiss): Make this happen sanely in more cases.)

  In order to take advantage of the C module, just use
  TBinaryProtocolAccelerated instead of TBinaryProtocol.</code></pre>
<p>So why didn’t it work? The answer is in <a href="https://github.com/apache/thrift/blob/master/lib/py/src/protocol/TBase.py#L52-L58">TBase.py</a>.</p>
<p>The following conditions have to met in order to use the fast deserializer:</p>
<ul>
<li>Protocol must be <code>TBinaryProtocolAccelerated</code> (I changed that)</li>
<li>Protocol’s transport implementation must implement the <code>TTransport.CReadableTransport</code> interface</li>
<li><code>thrift_spec</code> must be available (this was true in this case)</li>
<li><code>fastbinary</code> must be available (also true)</li>
</ul>
<p>The problem was that we were replacing the <code>TTransport</code> implementation with a custom class called <code>ThriftifyTransport</code> in order to do thrift logging, HMAC authentication, etc.</p>
<p>Fortunately all the default transport implementations implement the <code>CReadableTransport</code> interface, and one of them, <code>TBufferedTransport</code> can be used to wrap another transport to add buffering around it. That’s what I did, and it immediately started using the fast deserialization code.</p>
<p>The test call now ran in <strong>3.624 seconds</strong>.</p>
<p>And the new profiling results with this change:</p>
<p><a href="/images/profile2.png" class="zimg"><img width="600" src="/images/profile2.png" alt="profile2"></a></p>
<p>The left-hand side of the call graph remained the same, but <code>recv_test_get_users</code> is now only 2.35% of the overall time which is ~0.08 seconds (to be compared with the 1.6 seconds with the original deserializer!)</p>
<h3 id="optimizing-thrift-serialization">Optimizing thrift serialization</h3>
<p>The obvious next step was to apply this change on the server side as well, so our service can use the fast binary protocol for serialization too. For this I simply copied the change and remeasured everything.</p>
<p>The test call now ran in <strong>3.328 seconds</strong>!</p>
<p>Let’s see the call graph of this stage:</p>
<p><a href="/images/profile3.png" class="zimg"><img width="600" src="/images/profile3.png" alt="profile3"></a></p>
<h3 id="optimizing-result-processing">Optimizing result processing</h3>
<p>The client side of the test method was written similar to how the original API method is written:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> test_get_users_thrift(<span class="va">self</span>, count, sleep):</a>
<a class="sourceLine" id="cb3-2" title="2">    rpc <span class="op">=</span> ThriftRPC(UserDataService, <span class="va">self</span>.name, service_name<span class="op">=</span><span class="va">self</span>.service_name, client_config<span class="op">=</span>client_config)</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4">    result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="cf">for</span> row <span class="kw">in</span> rpc.test_get_users(count, sleep).iteritems():</a>
<a class="sourceLine" id="cb3-6" title="6">        user <span class="op">=</span> <span class="va">self</span>._row_to_model(<span class="va">self</span>.user_factory, row)</a>
<a class="sourceLine" id="cb3-7" title="7">        result.append(user)</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="cf">return</span> result</a></code></pre></div>
<p>It is clearly visible on the call graph that the 5499 call to <code>_row_to_model</code> takes 53% of the total time, which is ~1.7 seconds. There are two main branches of this call. The left hand side (<code>row_to_model</code>) seemed to be simple data conversion, and its slowest part is date-time deserialization.</p>
<p>The other branch however looked like a real problem; why should we resolve HMAC host, or parse configuration for each row?</p>
<p>It turned out to be a bug, <code>_row_to_model</code> created a new <em>model factory</em> in each call, which involves a lot of initialization, config parsing, and similar things.</p>
<p>So the simple fix was to create a <code>_rows_to_model</code> helper function which does the same for multiple rows with a single factory.</p>
<p>Running my test code once again showed that the optimization makes sense. Now it ran in <strong>2.448 seconds</strong>, with the following call graph:</p>
<p><a href="/images/profile4.png" class="zimg"><img width="600" src="/images/profile4.png" alt="profile4"></a></p>
<h3 id="further-optimizations">Further optimizations</h3>
<p>I saw two possible ways to further optimize this case:</p>
<ol type="1">
<li><p>Lazy conversion of raw thrift data to model data (per field). This would make sense because many times only a few fields (the id for example) are used, but it seemed to be a too complex change</p></li>
<li><p>Checking the server side as well</p></li>
</ol>
<p>To profile the server side and only measure the thrift request processing I had to add profiling code to the django view class in the following way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="im">import</span> cProfile</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">cProfile.runctx(<span class="st">&#39;self._call_processor(op_data)&#39;</span>, <span class="bu">globals</span>(), <span class="bu">locals</span>(), <span class="st">&#39;callstats&#39;</span>)</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"># self._call_processor(op_data)</span></a></code></pre></div>
<p>The server-side call took <strong>1.691 seconds</strong> and looked like this:</p>
<p><a href="/images/profile5.png" class="zimg"><img width="600" src="/images/profile5.png" alt="profile5"></a></p>
<p>As expected, 60% of this was the 1 second sleep. The rest of the calls are data conversion with no obvious point to improve.</p>
<h2 id="summary">Summary</h2>
<p>These optimizations are decreasing the response time significantly, especially for calls returning multiple rows.</p>
<p>The interesting was that the extremely slow performance was caused by both the slow perfomance of the python thrift serializer and a bug in our code.</p>
]]></summary>
</entry>
<entry>
    <title>Conditional blocks in Distributed Documentor</title>
    <link href="http://vigoo.github.io/posts/2014-07-13-conditional-blocks-in-ddoc.html" />
    <id>http://vigoo.github.io/posts/2014-07-13-conditional-blocks-in-ddoc.html</id>
    <published>2014-07-13T00:00:00Z</published>
    <updated>2014-07-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on July 13, 2014
    
</div>

<p>I’ve added a new feature to <a href="https://github.com/vigoo/distributed-documentor">Distributed Documentor</a> today, <em>conditional blocks</em>.</p>
<p>The idea is that parts of the documents can be enabled when a given <em>condition</em> is present. This is very similar to <a href="http://gcc.gnu.org/onlinedocs/cpp/Ifdef.html">C’s ifdef blocks</a>. To use it with the <em>MediaWiki syntax</em>, put <code>[When:X]</code> and <code>[End]</code> commands in separate lines:</p>
<pre><code>Unconditional

[When:FIRST]
First conditional

[When:SECOND]
First and second conditional
[End]
[End]

[When:SECOND]
Second conditional
[End]</code></pre>
<p><em>Snippets</em> can also have conditional blocks.</p>
<p>There are two possibilities to set which conditionals are enabled:</p>
<ol type="1">
<li><p>Specifying it with command line arguments, such as</p>
<pre><code> java -jar DistributedDocumentor.jar -D FIRST -D SECOND</code></pre>
<p>This is useful when exporting a documentation from command line, or to launch the documentation editor with a predefined set of enabled conditions.</p></li>
<li><p>On the user interface, using <em>View</em> menu’s <em>Enabled conditions…</em> menu item:</p></li>
</ol>
<p><img src="/images/enabled-conditions-dialog.png" /></p>
]]></summary>
</entry>
<entry>
    <title>Introducing bari</title>
    <link href="http://vigoo.github.io/posts/2014-05-16-introducing-bari.html" />
    <id>http://vigoo.github.io/posts/2014-05-16-introducing-bari.html</id>
    <published>2014-05-16T00:00:00Z</published>
    <updated>2014-05-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on May 16, 2014
    
</div>

<p>In the past two years I worked on a project called <a href="https://github.com/vigoo/bari">bari</a> which now reached an usable state. <strong>bari</strong> is a <em>build management system</em>, trying to fix Visual Studio’s bad parts while keeping the good ones.</p>
<p>Basically it tries to make .NET development more convenient, when</p>
<ul>
<li>The application may consist of a <em>large number of projects</em></li>
<li>There may be several different <em>subsets</em> of these projects defining valuable target <em>products</em></li>
<li><em>Custom build steps</em> may be required</li>
<li>It is important to be able to <em>reproduce</em> the build environment as easily as possible</li>
<li>The developers want to use the full power of their <em>IDE</em></li>
</ul>
<p>The main idea is to generate Visual Studio solutions and projects <em>on the fly</em> as needed, from a concise <em>declarative</em> build description. I tried to optimize this build description for human readability. Let’s see an example, a short section from <strong>bari</strong>’s own build definition:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> bari</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="fu">type:</span><span class="at"> executable</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">references:</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="kw">-</span> gac://System</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="kw">-</span> nuget://log4net</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">-</span> nuget://Ninject/3.0.1.10</a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="kw">-</span> nuget://QuickGraph</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">-</span> module://Bari.Core</a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="fu">csharp:</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="fu">root-namespace:</span><span class="at"> Bari.Console</span></a></code></pre></div>
<p>The main advantage of generating solutions and projects on the fly is that each developer can work on the subset he needs for his current task keeping the IDE fast, but can also open everything in one solution if it is useful for performing a refactoring.</p>
<p>To keep build definitions short and readable, <strong>bari</strong> prefers <em>convention</em> over <em>configuration</em>. For example the directory stucture in which the source code lays defines not only the name of the modules to build, but also the way it is built. For example, in a simple <em>hello world</em> example the C# source code would be put in the <code>src/TestModule/HelloWorld/cs</code> directory, and <strong>bari</strong> would build <code>target/TestModule/HelloWorld.exe</code>.</p>
<p><strong>bari</strong> unifies the handling of <em>project references</em> in a way that referencing projects within a suite, from the GAC, using <a href="http://www.nuget.org">Nuget</a> or from a custom repository works exactly the same. It is also possible to write <em>custom builders</em> in Python.</p>
<p>For more information check out <a href="https://github.com/vigoo/bari/wiki/GettingStarted">the getting started page</a>.</p>
]]></summary>
</entry>
<entry>
    <title>ScalaFX with FXML</title>
    <link href="http://vigoo.github.io/posts/2014-01-12-scalafx-with-fxml.html" />
    <id>http://vigoo.github.io/posts/2014-01-12-scalafx-with-fxml.html</id>
    <published>2014-01-12T00:00:00Z</published>
    <updated>2014-01-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 12, 2014
    
</div>

<p><a href="https://code.google.com/p/scalafx/">ScalaFX</a> is a nice wrapper around JavaFX for Scala, but currently it lacks support for using <a href="http://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html">FXML</a> instead of Scala code for defining the user interfaces. This can be understood as <em>ScalaFX</em> is in fact a DSL for defining the UI in Scala instead of an XML file. Still I believe that using FXML instead may have its advantages; first of all it has a visual designer (<a href="http://www.oracle.com/technetwork/java/javafx/tools/index.html">JavaFX Scene Builder</a>). For me, designing an UI without immediate visual feedback is hard, and involves a lot of iterations of tweaking the code, running it and checking the results. I also expect that in the future there will be more tools available which work on FXML data.</p>
<p>It is not impossible to use FXML user interfaces from Scala, but the ScalaFX wrappers does not help and the code for the controller classes is not clean enough. See <a href="https://github.com/jpsacha/ProScalaFX/blob/master/src/proscalafx/ch10/fxml/AdoptionFormController.scala">the following example</a> to get a feeling how it looks like.</p>
<p>To make it better I wrote a small library called <a href="https://github.com/vigoo/scalafxml">ScalaFXML</a>. In this post I’ll go through a small example to explain how it works.</p>
<p>The following image shows how our sample application will look like:</p>
<p><img src="/images/unit-conversion-shot.png" /></p>
<p>The <em>From</em> fiels is editable, and the result in the <em>To</em> field is filled as you type using <em>data binding</em>. The <em>Close</em> button’s only purpose is to demonstrate event handlers.</p>
<p>The conversion logic itself is implemented by <a href="https://github.com/vigoo/scalafxml/blob/master/demo/src/main/scala/scalafxml/demo/unitconverter/UnitConverter.scala">small classes</a> sharing the same trait:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">trait</span> UnitConverter {</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">val</span> description: String</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">def</span> <span class="fu">run</span>(input: String): String</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="kw">override</span> <span class="kw">def</span> toString = description</a>
<a class="sourceLine" id="cb1-6" title="6">}</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">object</span> MMtoInches <span class="kw">extends</span> UnitConverter {</a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="kw">val</span> description: String = <span class="st">&quot;Millimeters to inches&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="kw">def</span> <span class="fu">run</span>(input: String): String = </a>
<a class="sourceLine" id="cb1-11" title="11">      <span class="kw">try</span> { </a>
<a class="sourceLine" id="cb1-12" title="12">          (input.<span class="fu">toDouble</span> / <span class="fl">25.4</span>).<span class="fu">toString</span> </a>
<a class="sourceLine" id="cb1-13" title="13">      } <span class="kw">catch</span> { </a>
<a class="sourceLine" id="cb1-14" title="14">          <span class="kw">case</span> ex: Throwable =&gt; ex.<span class="fu">toString</span> </a>
<a class="sourceLine" id="cb1-15" title="15">      }</a>
<a class="sourceLine" id="cb1-16" title="16">}</a>
<a class="sourceLine" id="cb1-17" title="17"></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="kw">object</span> InchesToMM <span class="kw">extends</span> UnitConverter {</a>
<a class="sourceLine" id="cb1-19" title="19">  <span class="kw">val</span> description: String = <span class="st">&quot;Inches to millimeters&quot;</span></a>
<a class="sourceLine" id="cb1-20" title="20">  <span class="kw">def</span> <span class="fu">run</span>(input: String): String = </a>
<a class="sourceLine" id="cb1-21" title="21">      <span class="kw">try</span> { </a>
<a class="sourceLine" id="cb1-22" title="22">          (input.<span class="fu">toDouble</span> * <span class="fl">25.4</span>).<span class="fu">toString</span> </a>
<a class="sourceLine" id="cb1-23" title="23">      } <span class="kw">catch</span> { </a>
<a class="sourceLine" id="cb1-24" title="24">          <span class="kw">case</span> ex: Throwable =&gt; ex.<span class="fu">toString</span> </a>
<a class="sourceLine" id="cb1-25" title="25">      }</a>
<a class="sourceLine" id="cb1-26" title="26">}</a></code></pre></div>
<p>To describe the set of available <em>unit converters</em>, we define one more helper class:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> <span class="fu">UnitConverters</span>(converters: UnitConverter*) {</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">val</span> available = List(converters : _*)</a>
<a class="sourceLine" id="cb2-3" title="3">}</a></code></pre></div>
<p>Now let’s start with a <a href="https://github.com/vigoo/scalafxml/blob/master/demo/src/main/scala/scalafxml/demo/unitconverter/PureScalaFX.scala">pure ScalaFX solution</a>, where the user interface is defined in Scala. I’ve implemented the view itself in a class called <code>PureScalaFXView</code>, which gets the set of available <em>unit converters</em> as a dependency through its constructor. This makes the main application object very simple:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">object</span> PureScalaFX <span class="kw">extends</span> JFXApp {</a>
<a class="sourceLine" id="cb3-2" title="2">  stage = <span class="kw">new</span> <span class="fu">PureScalaFXView</span>(</a>
<a class="sourceLine" id="cb3-3" title="3">      <span class="kw">new</span> <span class="fu">UnitConverters</span>(InchesToMM, MMtoInches))</a>
<a class="sourceLine" id="cb3-4" title="4">}</a></code></pre></div>
<p>The <code>PureScalaFXView</code> class consists of two distinct parts. First we define the user interface using the <em>ScalaFX UI DSL</em>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> <span class="fu">PureScalaFXView</span>(converters: UnitConverters) <span class="kw">extends</span> JFXApp.<span class="fu">PrimaryStage</span> {</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="co">// UI Definition</span></a>
<a class="sourceLine" id="cb4-4" title="4">  title = <span class="st">&quot;Unit conversion&quot;</span></a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="kw">private</span> <span class="kw">val</span> types = <span class="kw">new</span> ComboBox[UnitConverter]() {</a>
<a class="sourceLine" id="cb4-7" title="7">    maxWidth = Double.<span class="fu">MaxValue</span></a>
<a class="sourceLine" id="cb4-8" title="8">    margin = Insets(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-9" title="9">  }</a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="kw">private</span> <span class="kw">val</span> from = <span class="kw">new</span> TextField {</a>
<a class="sourceLine" id="cb4-12" title="12">    margin = Insets(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-13" title="13">    prefWidth = <span class="fl">200.0</span></a>
<a class="sourceLine" id="cb4-14" title="14">  }</a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16">  <span class="kw">private</span> <span class="kw">val</span> to = <span class="kw">new</span> TextField {</a>
<a class="sourceLine" id="cb4-17" title="17">    prefWidth = <span class="fl">200.0</span></a>
<a class="sourceLine" id="cb4-18" title="18">    margin = Insets(<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-19" title="19">    editable = <span class="kw">false</span></a>
<a class="sourceLine" id="cb4-20" title="20">  }</a>
<a class="sourceLine" id="cb4-21" title="21"></a>
<a class="sourceLine" id="cb4-22" title="22">  scene = <span class="kw">new</span> Scene {</a>
<a class="sourceLine" id="cb4-23" title="23">    content = <span class="kw">new</span> GridPane {</a>
<a class="sourceLine" id="cb4-24" title="24">      padding = Insets(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb4-25" title="25"></a>
<a class="sourceLine" id="cb4-26" title="26">      <span class="fu">add</span>(<span class="kw">new</span> Label(<span class="st">&quot;Conversion type:&quot;</span>), <span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-27" title="27">      <span class="fu">add</span>(<span class="kw">new</span> Label(<span class="st">&quot;From:&quot;</span>), <span class="dv">0</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-28" title="28">      <span class="fu">add</span>(<span class="kw">new</span> Label(<span class="st">&quot;To:&quot;</span>), <span class="dv">0</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-29" title="29"></a>
<a class="sourceLine" id="cb4-30" title="30">      <span class="fu">add</span>(types, <span class="dv">1</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb4-31" title="31">      <span class="fu">add</span>(from, <span class="dv">1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-32" title="32">      <span class="fu">add</span>(to, <span class="dv">1</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb4-33" title="33"></a>
<a class="sourceLine" id="cb4-34" title="34">      <span class="fu">add</span>(<span class="kw">new</span> Button(<span class="st">&quot;Close&quot;</span>) {</a>
<a class="sourceLine" id="cb4-35" title="35">        <span class="co">// inline event handler binding</span></a>
<a class="sourceLine" id="cb4-36" title="36">        onAction = (e: ActionEvent) =&gt; Platform.<span class="fu">exit</span>()</a>
<a class="sourceLine" id="cb4-37" title="37">      }, <span class="dv">1</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-38" title="38"></a>
<a class="sourceLine" id="cb4-39" title="39">      columnConstraints = List(</a>
<a class="sourceLine" id="cb4-40" title="40">        <span class="kw">new</span> ColumnConstraints {</a>
<a class="sourceLine" id="cb4-41" title="41">          halignment = HPos.<span class="fu">LEFT</span></a>
<a class="sourceLine" id="cb4-42" title="42">          hgrow = Priority.<span class="fu">SOMETIMES</span></a>
<a class="sourceLine" id="cb4-43" title="43">          margin = Insets(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb4-44" title="44">        },</a>
<a class="sourceLine" id="cb4-45" title="45">        <span class="kw">new</span> ColumnConstraints {</a>
<a class="sourceLine" id="cb4-46" title="46">          halignment = HPos.<span class="fu">RIGHT</span></a>
<a class="sourceLine" id="cb4-47" title="47">          hgrow = Priority.<span class="fu">ALWAYS</span></a>
<a class="sourceLine" id="cb4-48" title="48">          margin = Insets(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb4-49" title="49">        }</a>
<a class="sourceLine" id="cb4-50" title="50">      )</a>
<a class="sourceLine" id="cb4-51" title="51">    }</a>
<a class="sourceLine" id="cb4-52" title="52">  }</a></code></pre></div>
<p>This is not 100% pure UI definition, because it also contains an inline event handler definition for the <em>Close</em> button.</p>
<p>The next part fills the <em>combo box</em> and defines the data binding. Filling the combo box is a simple procedural loop:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1">  <span class="kw">for</span> (converter &lt;- converters.<span class="fu">available</span>) {</a>
<a class="sourceLine" id="cb5-2" title="2">    types += converter</a>
<a class="sourceLine" id="cb5-3" title="3">  }</a>
<a class="sourceLine" id="cb5-4" title="4">  types.<span class="fu">getSelectionModel</span>.<span class="fu">selectFirst</span>()</a></code></pre></div>
<p>For the data binding we define a <a href="http://docs.oracle.com/javafx/2/binding/jfxpub-binding.htm">low level data binding</a> which depends on the combo box’s selected value and the <em>From</em> field’s text, and produces the output for the <em>To</em> field:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1">  to.<span class="fu">text</span> &lt;== <span class="kw">new</span> StringBinding {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="fu">bind</span>(from.<span class="fu">text</span>.<span class="fu">delegate</span>, types.<span class="fu">getSelectionModel</span>.<span class="fu">selectedItemProperty</span>)</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">def</span> <span class="fu">computeValue</span>() = types.<span class="fu">getSelectionModel</span>.<span class="fu">getSelectedItem</span>.<span class="fu">run</span>(from.<span class="fu">text</span>.<span class="fu">value</span>)</a>
<a class="sourceLine" id="cb6-4" title="4">  }</a></code></pre></div>
<p>That’s all, the application is fully functional. The next thing is to split this class so the UI definition and the UI logic got separated. This <a href="https://github.com/vigoo/scalafxml/blob/master/demo/src/main/scala/scalafxml/demo/unitconverter/RefactoredPureScalaFX.scala">refactored ScalaFX solution</a> is very similar to the previous one, but the initialization of the combo box, the data binding and the event handler are all encapsulated by a new, separate class:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="fu">RawUnitConverterPresenter</span>(</a>
<a class="sourceLine" id="cb7-2" title="2">                              <span class="kw">private</span> <span class="kw">val</span> from: TextField,</a>
<a class="sourceLine" id="cb7-3" title="3">                              <span class="kw">private</span> <span class="kw">val</span> to: TextField,</a>
<a class="sourceLine" id="cb7-4" title="4">                              <span class="kw">private</span> <span class="kw">val</span> types: ComboBox[UnitConverter],</a>
<a class="sourceLine" id="cb7-5" title="5">                              <span class="kw">private</span> <span class="kw">val</span> converters: UnitConverters) {</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="co">// Filling the combo box</span></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="kw">for</span> (converter &lt;- converters.<span class="fu">available</span>) {</a>
<a class="sourceLine" id="cb7-9" title="9">    types += converter</a>
<a class="sourceLine" id="cb7-10" title="10">  }</a>
<a class="sourceLine" id="cb7-11" title="11">  types.<span class="fu">getSelectionModel</span>.<span class="fu">selectFirst</span>()</a>
<a class="sourceLine" id="cb7-12" title="12"></a>
<a class="sourceLine" id="cb7-13" title="13">  <span class="co">// Data binding</span></a>
<a class="sourceLine" id="cb7-14" title="14">  to.<span class="fu">text</span> &lt;== <span class="kw">new</span> StringBinding {</a>
<a class="sourceLine" id="cb7-15" title="15">    <span class="fu">bind</span>(from.<span class="fu">text</span>.<span class="fu">delegate</span>, types.<span class="fu">getSelectionModel</span>.<span class="fu">selectedItemProperty</span>)</a>
<a class="sourceLine" id="cb7-16" title="16">    <span class="kw">def</span> <span class="fu">computeValue</span>() = types.<span class="fu">getSelectionModel</span>.<span class="fu">getSelectedItem</span>.<span class="fu">run</span>(from.<span class="fu">text</span>.<span class="fu">value</span>)</a>
<a class="sourceLine" id="cb7-17" title="17">  }</a>
<a class="sourceLine" id="cb7-18" title="18"></a>
<a class="sourceLine" id="cb7-19" title="19">  <span class="co">// Close button event handler</span></a>
<a class="sourceLine" id="cb7-20" title="20">  <span class="kw">def</span> <span class="fu">onClose</span>(event: ActionEvent) {</a>
<a class="sourceLine" id="cb7-21" title="21">    Platform.<span class="fu">exit</span>()</a>
<a class="sourceLine" id="cb7-22" title="22">  }</a>
<a class="sourceLine" id="cb7-23" title="23">}</a></code></pre></div>
<p>What I wanted is to be able to define the controller class exactly like this while building the user interface from FXML. Without <a href="https://github.com/vigoo/scalafxml">ScalaFXML</a> the controller class have some serious limitations:</p>
<ul>
<li>It must implement the <a href="http://docs.oracle.com/javafx/2/api/javafx/fxml/Initializable.html">Initializable</a> interface</li>
<li>It cannot have any constructor arguments</li>
<li>The user interface objects must be variable fields of the class</li>
<li>And they have to have the type of the JavaFX controls, so to be able to use the ScalaFX wrappers, they have to be explicitly wrapped in the <code>initialize</code> method.</li>
</ul>
<p>With <a href="https://github.com/vigoo/scalafxml">ScalaFXML</a> the process is really simple. First we create the FXML, for example with the <a href="http://www.oracle.com/technetwork/java/javafx/tools/index.html">JavaFX Scene Builder</a>:</p>
<p><img src="/images/unit-conversion-scenebuilder.png" /></p>
<p>In the FXML we give the <code>from</code>, <code>to</code>, and <code>types</code> identifiers to our controls using the <code>fx:id</code> attribute, for example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb8-1" title="1">    <span class="kw">&lt;TextField</span><span class="ot"> fx:id=</span><span class="st">&quot;from&quot;</span><span class="ot"> prefWidth=</span><span class="st">&quot;200.0&quot;</span> </a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">               GridPane.columnIndex=</span><span class="st">&quot;1&quot;</span> </a>
<a class="sourceLine" id="cb8-3" title="3"><span class="ot">               GridPane.margin=</span><span class="st">&quot;$x1&quot;</span> </a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ot">               GridPane.rowIndex=</span><span class="st">&quot;1&quot;</span> <span class="kw">/&gt;</span></a></code></pre></div>
<p>The event handlers can be specified simply by their name:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">&lt;Button</span><span class="ot"> onAction=</span><span class="st">&quot;#onClose&quot;</span><span class="ot"> text=</span><span class="st">&quot;Close&quot;</span> </a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">        mnemonicParsing=</span><span class="st">&quot;false&quot;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">        GridPane.columnIndex=</span><span class="st">&quot;1&quot;</span> </a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ot">        GridPane.halignment=</span><span class="st">&quot;RIGHT&quot;</span> </a>
<a class="sourceLine" id="cb9-5" title="5"><span class="ot">        GridPane.rowIndex=</span><span class="st">&quot;3&quot;</span> <span class="kw">/&gt;</span></a></code></pre></div>
<p>and the controller class must be referenced on the root node</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb10-1" title="1">fx:controller=&quot;scalafxml.demo.unitconverter.UnitConverterPresenter&quot;</a></code></pre></div>
<p>The controller class <a href="https://github.com/vigoo/scalafxml/blob/master/demo/src/main/scala/scalafxml/demo/unitconverter/ScalaFXML.scala">can be exactly the same as the <code>RawUnitConverterPresenter</code></a>, adding an additional <code>@sfxml</code> annotation for it. Everything else is handled by the library, as we will see.</p>
<p>The application object itself looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">object</span> ScalaFXML <span class="kw">extends</span> JFXApp {</a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="kw">val</span> root = <span class="fu">FXMLView</span>(getClass.<span class="fu">getResource</span>(<span class="st">&quot;unitconverter.fxml&quot;</span>),</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="kw">new</span> <span class="fu">DependenciesByType</span>(Map(</a>
<a class="sourceLine" id="cb11-5" title="5">      typeOf[UnitConverters] -&gt; <span class="kw">new</span> <span class="fu">UnitConverters</span>(InchesToMM, MMtoInches))))</a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7">  stage = <span class="kw">new</span> JFXApp.<span class="fu">PrimaryStage</span>() {</a>
<a class="sourceLine" id="cb11-8" title="8">    title = <span class="st">&quot;Unit conversion&quot;</span></a>
<a class="sourceLine" id="cb11-9" title="9">    scene = <span class="kw">new</span> <span class="fu">Scene</span>(root)</a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11">  }</a>
<a class="sourceLine" id="cb11-12" title="12">}</a></code></pre></div>
<p>Beside giving the URI for the FXML file we also has to provide the <em>additional dependencies</em> of the controller class. This is an easily extensible part of the library, and it already has support for <a href="https://github.com/dickwall/subcut">SubCut</a> and <a href="https://code.google.com/p/google-guice/">Guice</a> as well. Here we are using a simple <em>type-&gt;value</em> mapping instead.</p>
<p>How does this work? What happens behind the scenes?</p>
<p>The <code>@sfxml</code> is a <a href="http://docs.scala-lang.org/overviews/macros/annotations.html">macro annotation</a>. In <em>compile-time</em>, the class definition itself is transformed by the <a href="https://github.com/vigoo/scalafxml/blob/master/core-macros/src/main/scala/scalafxml/core/macros/sfxmlMacro.scala"><code>sfxmlMacro.impl</code> function</a>.</p>
<p>The transformation’s result is a class definition with the source class’ name, but with a completely different content. The original class is added as an inner class, always called <code>Controller</code>. In our example, the generated class definition would look like something similar:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">class</span> <span class="fu">UnitConverterPresenter</span>(<span class="kw">private</span> <span class="kw">val</span> dependencyResolver: ControllerDependencyResolver)</a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="kw">extends</span> javafx.<span class="fu">fxml</span>.<span class="fu">Initializable</span> </a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="kw">with</span> FxmlProxyGenerator.<span class="fu">ProxyDependencyInjection</span> {</a>
<a class="sourceLine" id="cb12-4" title="4">    </a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="kw">class</span> <span class="fu">Controller</span>(</a>
<a class="sourceLine" id="cb12-6" title="6">        <span class="kw">private</span> <span class="kw">val</span> from: TextField,</a>
<a class="sourceLine" id="cb12-7" title="7">        <span class="kw">private</span> <span class="kw">val</span> to: TextField,</a>
<a class="sourceLine" id="cb12-8" title="8">        <span class="kw">private</span> <span class="kw">val</span> types: ComboBox[UnitConverter],</a>
<a class="sourceLine" id="cb12-9" title="9">        <span class="kw">private</span> <span class="kw">val</span> converters: UnitConverters) {</a>
<a class="sourceLine" id="cb12-10" title="10">        <span class="co">// …</span></a>
<a class="sourceLine" id="cb12-11" title="11">    }</a>
<a class="sourceLine" id="cb12-12" title="12">    </a>
<a class="sourceLine" id="cb12-13" title="13">    <span class="kw">private</span> <span class="kw">var</span> impl: Controller = <span class="kw">null</span></a>
<a class="sourceLine" id="cb12-14" title="14">    </a>
<a class="sourceLine" id="cb12-15" title="15">    <span class="co">// …</span></a>
<a class="sourceLine" id="cb12-16" title="16">}   </a></code></pre></div>
<p>The class have four distinct parts:</p>
<ol type="1">
<li>Getting the additional dependencies from the <em>dependency resolver</em></li>
<li>Variable fields for binding the JavaFX controls defined in the FXML</li>
<li>Event handler methods</li>
<li>The <code>initializable</code> method’s implementation</li>
</ol>
<p>The first one is simple - for each constructor argument of the controller class which is <em>not</em> a ScalaFX control, we query the <em>dependency resolver</em> to get a value for it. These are performed when the outer, generated class is instantiated and stored through the <code>ProxyDependencyInjection</code> trait.</p>
<p>The variable fields are simple fields for all the ScalaFX constructor arguments of the controller class, but converted to their JavaFX counterpart. For example the generated field for the controller’s <code>from</code> argument will look like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1">@javafx.<span class="fu">fxml</span>.<span class="fu">FXML</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">private</span> <span class="kw">var</span> from: javafx.<span class="fu">scene</span>.<span class="fu">control</span>.<span class="fu">TextField</span> = <span class="kw">null</span></a></code></pre></div>
<p>The <em>event handler</em>’s are proxies for all the public methods of the controller, but the ScalaFX event argument types are replaced with JavaFX event argument types and they are wrapped automatically when forwarding the call to the real implementation. For the <code>onClose</code> event handler it would look like the following:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1">@javafx.<span class="fu">fxml</span>.<span class="fu">FXML</span> <span class="kw">def</span> <span class="fu">onClose</span>(e: javafx.<span class="fu">event</span>.<span class="fu">ActionEvent</span>) {</a>
<a class="sourceLine" id="cb14-2" title="2">    impl.<span class="fu">onClose</span>(<span class="kw">new</span> scalafx.<span class="fu">event</span>.<span class="fu">ActionEvent</span>(e))</a>
<a class="sourceLine" id="cb14-3" title="3">}</a></code></pre></div>
<p>When JavaFX calls the generated controller’s <code>initialize</code> method, the control fields are already set up, and the additional dependencies were already gathered from the dependency resolver so we have all the values required to instantiate the real controller class. For ScalaFX arguments we wrap the JavaFX controls, for the additional dependencies we use the <code>ProxyDependencyInjection</code> trait’s <code>getDependency</code> method:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">def</span> <span class="fu">initialize</span>(url: java.<span class="fu">net</span>.<span class="fu">URL</span>, rb: java.<span class="fu">util</span>.<span class="fu">ResourceBundle</span>) {</a>
<a class="sourceLine" id="cb15-2" title="2">    impl = <span class="kw">new</span> <span class="fu">Controller</span>(</a>
<a class="sourceLine" id="cb15-3" title="3">        <span class="kw">new</span> scalafx.<span class="fu">scene</span>.<span class="fu">control</span>.<span class="fu">TextField</span>(from),</a>
<a class="sourceLine" id="cb15-4" title="4">        <span class="kw">new</span> scalafx.<span class="fu">scene</span>.<span class="fu">control</span>.<span class="fu">TextField</span>(to),        </a>
<a class="sourceLine" id="cb15-5" title="5">        <span class="kw">new</span> scalafx.<span class="fu">scene</span>.<span class="fu">control</span>.<span class="fu">ComboBox</span>[UnitConverter](types),</a>
<a class="sourceLine" id="cb15-6" title="6">        getDependencies[UnitConverters](<span class="st">&quot;converters&quot;</span>))</a>
<a class="sourceLine" id="cb15-7" title="7">}</a></code></pre></div>
<p>That’s all. The final interesting bit is the <code>FXMLView</code> object, which overrides JavaFX’s default controller factory. This is only necessary to be able to pass the given <code>ControllerDependencyResolver</code> to the generated controller’s constructor:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" title="1">  <span class="kw">def</span> <span class="fu">apply</span>(fxml: URL, dependencies: ControllerDependencyResolver): jfxs.<span class="fu">Parent</span> =</a>
<a class="sourceLine" id="cb16-2" title="2">    jfxf.<span class="fu">FXMLLoader</span>.<span class="fu">load</span>(</a>
<a class="sourceLine" id="cb16-3" title="3">      fxml, </a>
<a class="sourceLine" id="cb16-4" title="4">      <span class="kw">null</span>,</a>
<a class="sourceLine" id="cb16-5" title="5">      <span class="kw">new</span> jfxf.<span class="fu">JavaFXBuilderFactory</span>(),</a>
<a class="sourceLine" id="cb16-6" title="6">      <span class="kw">new</span> jfxu.<span class="fu">Callback</span>[Class[_], Object] {</a>
<a class="sourceLine" id="cb16-7" title="7">        <span class="kw">override</span> <span class="kw">def</span> <span class="fu">call</span>(cls: Class[_]): Object = </a>
<a class="sourceLine" id="cb16-8" title="8">            <span class="fu">FxmlProxyGenerator</span>(cls, dependencies)</a>
<a class="sourceLine" id="cb16-9" title="9">      })</a></code></pre></div>
<p><code>FxmlProxyGenerator</code> uses reflection to create a new instance of the generated controller, and pass the dependency resolver as its only constructor argument.</p>
]]></summary>
</entry>
<entry>
    <title>Trying out Ceylon - Part 1</title>
    <link href="http://vigoo.github.io/posts/2013-11-17-trying-out-ceylon-part-1.html" />
    <id>http://vigoo.github.io/posts/2013-11-17-trying-out-ceylon-part-1.html</id>
    <published>2013-11-17T00:00:00Z</published>
    <updated>2013-11-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on November 17, 2013
    
</div>

<p>Ceylon’s first production release was announced on 12th of November. I decided to try it out after going through the quick introduction, as it looked quite promising. In a series of posts I’d like to share my first attempts to use this interesting language.</p>
<p>This first release came with an eclipse plugin as well - after installing it I was immediately able to start working on my test project. In this few hours the plugin seemed to be stable enough, I did not experience any problems.</p>
<p>I have a <code>JVLT</code> file which I created while attending a foreign language course about a year ago. I was using only a limited subset of this application, so basically what I have is a .jvlt file, which is in fact a ZIP archive, in which a <code>dict.xml</code> stores a set of words and for each word one or more translation and the lesson we have learnt it.</p>
<p>See the following example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode xml"><code class="sourceCode xml"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">&lt;dictionary</span><span class="ot"> language=</span><span class="st">&quot;french&quot;</span><span class="ot"> version=</span><span class="st">&quot;1.4&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">&lt;entry</span><span class="ot"> id=</span><span class="st">&quot;e275&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">&lt;orth&gt;</span>à côté de<span class="kw">&lt;/orth&gt;</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="kw">&lt;sense</span><span class="ot"> id=</span><span class="st">&quot;e275-s1&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb1-5" title="5">      <span class="kw">&lt;trans&gt;</span>mellett<span class="kw">&lt;/trans&gt;</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">&lt;/sense&gt;</span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="kw">&lt;sense</span><span class="ot"> id=</span><span class="st">&quot;e275-s2&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb1-8" title="8">      <span class="kw">&lt;trans&gt;</span>mellé<span class="kw">&lt;/trans&gt;</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="kw">&lt;/sense&gt;</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="kw">&lt;lesson&gt;</span>8<span class="kw">&lt;/lesson&gt;</span></a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="kw">&lt;/entry&gt;</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">&lt;/dictionary&gt;</span></a></code></pre></div>
<p>My idea was to write an application that helps me learning and practicing these words.</p>
<p>In this first post I’m going to load the dictionary from the JVLT file.</p>
<p>To get started, I created a new Ceylon module with the help of the IDE called jvlt. This immediately created three program units: <code>module.ceylon</code>, <code>package.ceylon</code> and <code>run.ceylon</code>. The <code>module.ceylon</code> contains the module definition, which also describes the module’s dependencies. As I was trying to implement the dictionary reader, I ended up with the following module definition:</p>
<pre class="ceylon"><code>module jvlt &quot;1.0.0&quot; {
    shared import ceylon.file &quot;1.0.0&quot;;
	import ceylon.collection &quot;1.0.0&quot;;
    import ceylon.interop.java &quot;1.0.0&quot;;
 
    import javax.xml &quot;7&quot;; 
 
    import ceylon.test &quot;1.0.0&quot;;
}</code></pre>
<p>Let’s start with the data model we want to build up! The dictionary consists of words:</p>
<pre class="ceylon"><code>&quot;Represents a foreign word with one or more senses&quot;
shared class Word(shared String word, shared Set&lt;string&gt; senses, shared Integer lesson){ 
}</code></pre>
<p>The word, senses and lessons are all shared attributes of this class, accessible from the outside. To make it easy to access the word objects by their foreign word, I’m currently storing them in a map:</p>
<pre class="ceylon"><code>&quot;Represents a dictionary of words in a given language&quot;
shared class Dictionary(shared String language, shared Map&lt;string word=&quot;&quot;&gt; words) {
}</code></pre>
<p>Basically that’s the data model, but I wrapped the whole thing in an abstract JVLT class which looks like this:</p>
<pre class="ceylon"><code>&quot;Represents a JVLT file&quot;
abstract shared class JVLT() {
 
	&quot;The dictionary stored in this JVLT&quot;
 	formal shared Dictionary dictionary;
}</code></pre>
<p>The idea is that you get a JVLT instance from one of the helper functions and then use it as a root of the data model.</p>
<p>The next thing is to create this data model from the JVLT files. For this, I needed two things:</p>
<ul>
<li>Reading a ZIP archive</li>
<li>Parsing XML</li>
</ul>
<p>It turned out that Ceylon’s file module has ZIP support, with the <code>createZipFileSystem</code> function as an entry point. I made two module-level functions beside the JVLT class for creating instances deriving from the abstract JVLT class:</p>
<ul>
<li><code>loadJVLT</code> which loads a JVLT ZIP archive from the file system</li>
<li><code>loadJVLTFromDictionaryString</code> oads directly a dict.xml-like XML passed as a simple string. I’m using this for unit testing the XML parser.</li>
</ul>
<p>Let’s see the ZIP handling first:</p>
<pre class="ceylon"><code>&quot;Loads a JVLT file from a `.jvlt` ZIP archive, if possible.&quot;
shared JVLT? loadJVLT(File file) {
	value zip = createZipFileSystem(file);
 	value dictPath = zip.parsePath(&quot;/dict.xml&quot;);
 	if (is File dictFile = dictPath.resource) {  
  		try (reader = dictFile.Reader()) {
   
   			return loadJVLTFromDictionaryString(readAll(reader));
  		}
 	} else {
  		return null;
 	}
}</code></pre>
<p>Well, the error handling is not too sophisticated in this case, it either returns a JVLT or returns <code>null</code> if the given file did not have a <code>dict.xml</code> in it. Other error conditions such as a <code>dict.xml</code> with a wrong format, etc., are not handled currently. As you can see, I’m reusing my other load function here, once the <code>dict.xml</code> is read.</p>
<p>There are two interesting things here. First, the if statement where we check if the resource is an instance of <code>File</code> and immediately store it in the value called <code>dictFile</code>. The <code>dictPath.resource</code> attribute has the type <code>Resource</code> which is a Ceylon interface. It is either an <code>ExistingResource</code>: <code>Directory</code>, <code>File</code> or <code>Link</code>, or <code>Nil</code>. In any case if it is not a <code>File</code> instance, we just return <code>null</code>.</p>
<p>For simplicity, I’m reading the full <code>dict.xml</code> into a string before parsing it. For this purpose I wrote a small helper function <code>readAll</code>:</p>
<pre class="ceylon"><code>&quot;Reads all lines from a file reader and returns the concatenated string&quot;
String readAll(File.Reader reader) { 
	variable String result = &quot;&quot;;
 
 	while (exists line = reader.readLine()) {
  		result += line; 
 	}
 
 	return result;
}</code></pre>
<p>Probably it’s not an optimal solution, but works :)</p>
<p>Now that we have our data model and have a way to build it up from XML, we can write some unit tests to see how it works. The Ceylon SDK has a test module and the Ceylon IDE supports running the tests. There is a <a href="http://ceylon-lang.org/documentation/1.0/ide/test-plugin/">separate page in the documentation</a> describing how. It is really simple, I had to add the test module as a dependency, and I created a separate file to hold my test definitions. The class groups the tests together and optionally supports running extra code before/after each test case, as in other test frameworks:</p>
<pre class="ceylon"><code>class DictionaryParserTests() {

	shared test void emptyDictionary() {
	  	value dic = loadJVLTFromDictionaryString(&quot;&lt;dictionary&gt;&quot;);
	  
	  	assert (dic.dictionary.words.empty);
	  	assert (dic.dictionary.language == &quot;unknown&quot;);
	}

 	shared test void languageAttributeRead() {
  		value dic = loadJVLTFromDictionaryString(&quot;&lt;dictionary language=&quot;testlang&quot;&gt;&quot;);
  		assert (dic.dictionary.language == &quot;testlang&quot;);
 	}

	// ...
</code></pre>
<p>I won’t paste here all the test code, only a few samples to get the feeling how the Ceylon code looks like. To test whether a given word’s translations are loaded correctly, I wrote a helper function:</p>
<pre class="ceylon"><code>void assertSenses(JVLT jvlt, String w, [String+] expectedSenses) {
  
    Word? word = jvlt.dictionary.words[w];
    if (exists word) {
    	assert (word.senses.equals(HashSet(expectedSenses)));  
    } else {
     	fail(&quot;Word does not exists&quot;);
    }
}</code></pre>
<p>This helper function can be used to assert that a word has been loaded correctly:</p>
<pre class="ceylon"><code>shared test void wordWithMultipleSenses() {
	value dic = loadJVLTFromDictionaryString(
  		&quot;&lt;dictionary&gt;
   			&lt;entry id=&quot;e1&quot;&gt;
    			&lt;orth&gt;src1&lt;/orth&gt;
    			&lt;sense id=&quot;e1-s1&quot;&gt;
     				&lt;trans&gt;dst1&lt;/trans&gt;
    			&lt;/sense&gt;
    			&lt;sense id=&quot;e1-s2&quot;&gt;
     				&lt;trans&gt;dst2&lt;/trans&gt;
    			&lt;/sense&gt;    
   			&lt;/entry&gt;  
   		&lt;/dictionary&gt;&quot;);
 
 	assertSenses(dic, &quot;src1&quot;, [&quot;dst1&quot;, &quot;dst2&quot;]);
}</code></pre>
<p>Now the only problem is that there is no XML parsing support in the Ceylon SDK currently, so it has to be done using Java interop. As I wrote the code to build up the data model from the XML, I wrote several helper functions to make it easier to fit into the language. So let’s see first how the dictionary loading is defined, and then I’ll show the helper functions.</p>
<p>The XML parsing is done by two module level functions which are not shared - only used by the JVLT constructor functions I shown before. The first one creates a map entry for a single word:</p>
<pre class="ceylon"><code>&quot;Creates a word entry for the dictionary&quot;
String-&gt;Word loadEntry(Element elem) {
 
 	value w = Word {
  		word = selectNodeText(elem, &quot;orth&quot;) else &quot;???&quot;;
  		lesson = selectNodeInteger(elem, &quot;lesson&quot;) else 0;
  		senses = HashSet(selectNodes(elem, &quot;sense/trans&quot;)
  					.map((Node n) =&gt; n.textContent));
 	};
 	return w.word-&gt;w;
}</code></pre>
<p>and the second one loads all the words from the XML document:</p>
<pre class="ceylon"><code>&quot;Loads a dictionary from JVLT&#39;s `dict.xml` format.&quot;
Dictionary loadDictionaryFromXML(Document doc) { 

	doc.documentElement.normalize();

 	return Dictionary { 
  		language = getAttribute(doc.documentElement, &quot;language&quot;) else &quot;unknown&quot;;
  		words = HashMap({ 
     		for (node in selectNodes(doc, &quot;dictionary/entry&quot;))
       			if (is Element elem = node)
             		loadEntry(elem) });   
 	};
}</code></pre>
<p>The function which returns the JVLT instance uses this function and Java interop to read the dictionary:</p>
<pre class="ceylon"><code>&quot;Loads a JVLT file by the parsing the dictionary XML directly from a string&quot;
shared JVLT loadJVLTFromDictionaryString(String dictXML) {
	value docBuilderFactory = DocumentBuilderFactory.newInstance();
 	value builder = docBuilderFactory.newDocumentBuilder();
 	value doc = builder.parse(ByteArrayInputStream(javaString(dictXML).bytes));
 
 	object result extends JVLT() { 
  		dictionary = loadDictionaryFromXML(doc);
 	}
 	return result;
}</code></pre>
<p>There are two things to notice here: we had to convert from Ceylon’s string to Java string. This is not done automatically and we need the <code>ceylon.interop.java</code> module to do it. In the last lines we define an anonymous class extending from JVLT and overwriting it’s abstract dictionary attribute. Then this anonymous class instance is returned as the loaded JVLT.</p>
<p>To make the XML parsing less painful, I defined a few helper functions in a separate compilation unit (<code>XmlHelper.ceylon</code>). I won’t show here the full file but there are some interesting parts. First, from Ceylon you cannot call static methods, but you can import them. I’m using the following two import statements:</p>
<pre class="ceylon"><code>import org.w3c.dom { Node, NodeList, Element }
import javax.xml.xpath { XPathFactory { newXPathFactory = newInstance },
       XPathConstants { nodeSet = \iNODESET }}</code></pre>
<p>The first one is straightforward. It imports three DOM interfaces. The second one first imports the <code>XPathFactory.newInstance</code> static method and also renames it, as newInstance is a too generic name without its class name as a prefix. The third line imports a constant value and gives it a Ceylon-compatible name. Because in Ceylon only the types can start with an uppercase character, we have to use a special and ugly syntax which helps the interoperability - prefixing it with <code>\i</code>.</p>
<p>The <code>ceylon.interop.java</code> module has helper classes to make Java Iterable objects iterable in Ceylon, but unfortunately the <code>NodeList</code> interface is not iterable in Java either. So I wrote a simple wrapper that iterates through a node list:</p>
<pre class="ceylon"><code>class NodeListIterator(NodeList nodes) satisfies Iterable&lt;Node&gt; {
	shared actual default Iterator&lt;Node&gt; iterator() {
  		object it satisfies Iterator&lt;Node&gt; {   
   			variable Integer i = 0;
   
   			shared actual Node|Finished next() {
    			if (i &lt; nodes.length) {
     				return nodes.item(i++);
    			} else {
     				return finished;
    			}
   			}
  		}
  		return it;
 	}
}</code></pre>
<p>Using this iterator and the imports I wrote a <code>selectNodes</code> function to run XPath expressions and return the result as a Ceylon iterable:</p>
<pre class="ceylon"><code>{Node*} selectNodes(Node root, String xpath) { 
	value factory = newXPathFactory();
 	value xpathCompiler = factory.newXPath();
 	value expr = xpathCompiler.compile(xpath);
 	value nodeList = expr.evaluate(root, nodeSet); 
 	if (is NodeList nodeList) {  
  		return NodeListIterator(nodeList);
 	}
 	else {
  		return [];
 	}
}</code></pre>
<p>Using this function it is very easy to write a variant that selects a single node:</p>
<pre class="ceylon"><code>Node? selectNode(Node root, String xpath) { 
	return selectNodes(root, xpath).first;
}</code></pre>
<p>There are some other helper functions returning the node’s text, converting it to integer, etc. but I think they are not that interesting. Now that I have my data model which is built from my JVLT file, the next thing is to make a user interface somehow where the vocabulary can be shown an the user’s knowledge can be tested/improved. This will be the topic of some future posts, as soon as I have time to experiment more with this new language.</p>
]]></summary>
</entry>
<entry>
    <title>Cloning WPF flow document fragments</title>
    <link href="http://vigoo.github.io/posts/2013-10-25-cloning-wpf-flow-document-fragments.html" />
    <id>http://vigoo.github.io/posts/2013-10-25-cloning-wpf-flow-document-fragments.html</id>
    <published>2013-10-25T00:00:00Z</published>
    <updated>2013-10-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October 25, 2013
    
</div>

<p>Today I had to write such an ugly hack to fix a bug that I decided to start writing a blog where I can show it to the world :)</p>
<p>The software I’m working on has some sort of context sensitive help panel, which is implemented using dynamically generated <a href="http://msdn.microsoft.com/en-us/library/aa970909.aspx">flow documents</a>. The software loads a large set of flow document sections from a XAML file runtime, and later builds documents from a subset of them.</p>
<p>For some reason (which belong to a separate post), it is not possible to reuse these flow document elements in multiple flow documents, not even if there is only one at a time. To work around this, I was cloning these sections before adding them to the document.</p>
<p>As WPF elements are not <em>cloneable</em>, I was using the method recommended many places, for example <a href="http://stackoverflow.com/questions/32541/how-can-you-clone-a-wpf-object">in this StackOverflow post</a>: saving the object tree to an in-memory XAML stream, and loading it back.</p>
<p>This worked quite well.. until we discovered a bug, which I still cannot explain. In some cases which were easily reproducible for any developer, but the code running in those cases being exactly the same as in other, working cases, the clone method simply stopped working.</p>
<p>Stopped working here means that the following code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cs"><code class="sourceCode cs"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">var</span> xaml = XamlWriter.<span class="fu">Save</span>(block);</a></code></pre></div>
<p>would write out the correct object hierarchy, but without any properties (no attributes, no content properties, nothing but the element names)! In the same time the objects in the memory were untouched and still had all the relevant properties set.</p>
<p>I also tried to write my own XAML serializer based on the code found <a href="http://go4answers.webhost4life.com/Example/xaml-serialization-replacement-75133.aspx">at this site</a>, but this was only good to find out that the problem lies deep within the <code>MarkupWriter</code> class, which is the same what the <code>XamlWriter</code> uses internally. When the <code>XamlWriter</code> failed, my own code could not find any properties using the returned <a href="http://msdn.microsoft.com/en-us/library/system.windows.markup.primitives.markupobject.aspx">MarkupObject</a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cs"><code class="sourceCode cs"><a class="sourceLine" id="cb2-1" title="1">MarkupObject markupObj = MarkupWriter.<span class="fu">GetMarkupObjectFor</span>(obj);</a></code></pre></div>
<p>For the same object, in the working scenarios it returned a markup object with a working <code>Properties</code> collection.</p>
<p>So here is the final <em>“solution”</em> which I’m not really proud of, but solved the problem. Maybe with some modifications it is useful for someone struggling with the framework:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cs"><code class="sourceCode cs"><a class="sourceLine" id="cb3-1" title="1"><span class="co">/// </span><span class="kw">&lt;summary&gt;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">/// Horrible ugly clone hack to issues where XamlWriter/XamlReader based</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">/// clone method did not work.</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">/// </span><span class="kw">&lt;/summary&gt;</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">public</span> <span class="kw">static</span> <span class="kw">class</span> CloneHelper</a>
<a class="sourceLine" id="cb3-6" title="6">{</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="kw">public</span> <span class="kw">static</span> Block Clone&lt;t&gt;(<span class="kw">this</span> T block)</a>
<a class="sourceLine" id="cb3-8" title="8">        where T : Block</a>
<a class="sourceLine" id="cb3-9" title="9">    {</a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="dt">var</span> result = (T)<span class="fu">DeepClone</span>(block);</a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="kw">return</span> result;</a>
<a class="sourceLine" id="cb3-13" title="13">    }</a>
<a class="sourceLine" id="cb3-14" title="14"></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="kw">private</span> <span class="kw">static</span> <span class="dt">object</span> <span class="fu">DeepClone</span>(<span class="dt">object</span> obj)</a>
<a class="sourceLine" id="cb3-16" title="16">    {</a>
<a class="sourceLine" id="cb3-17" title="17">        <span class="kw">if</span> (obj != <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb3-18" title="18">        {</a>
<a class="sourceLine" id="cb3-19" title="19">            <span class="co">// Replacing ResourceDictionary and Style values with null. </span></a>
<a class="sourceLine" id="cb3-20" title="20">            <span class="co">// In this particular use case it is correct to do</span></a>
<a class="sourceLine" id="cb3-21" title="21">            <span class="kw">if</span> (obj.<span class="fu">GetType</span>() == <span class="kw">typeof</span>(ResourceDictionary) ||</a>
<a class="sourceLine" id="cb3-22" title="22">                obj.<span class="fu">GetType</span>() == <span class="kw">typeof</span>(Style))</a>
<a class="sourceLine" id="cb3-23" title="23">            {</a>
<a class="sourceLine" id="cb3-24" title="24">                <span class="kw">return</span> <span class="kw">null</span>;</a>
<a class="sourceLine" id="cb3-25" title="25">            }</a>
<a class="sourceLine" id="cb3-26" title="26">            <span class="kw">else</span></a>
<a class="sourceLine" id="cb3-27" title="27">            {</a>
<a class="sourceLine" id="cb3-28" title="28">                <span class="co">// Value types and some special cases where we don&#39;t want to clone</span></a>
<a class="sourceLine" id="cb3-29" title="29">                <span class="kw">if</span> (obj.<span class="fu">GetType</span>().<span class="fu">IsValueType</span> ||</a>
<a class="sourceLine" id="cb3-30" title="30">                    obj.<span class="fu">GetType</span>() == <span class="kw">typeof</span> (Cursor) ||</a>
<a class="sourceLine" id="cb3-31" title="31">                    obj.<span class="fu">GetType</span>() == <span class="kw">typeof</span> (XmlLanguage))</a>
<a class="sourceLine" id="cb3-32" title="32">                {</a>
<a class="sourceLine" id="cb3-33" title="33">                    <span class="kw">return</span> obj;</a>
<a class="sourceLine" id="cb3-34" title="34">                }</a>
<a class="sourceLine" id="cb3-35" title="35">                <span class="kw">else</span></a>
<a class="sourceLine" id="cb3-36" title="36">                {</a>
<a class="sourceLine" id="cb3-37" title="37">                    <span class="co">// If it is cloneable, use it</span></a>
<a class="sourceLine" id="cb3-38" title="38">                    <span class="dt">var</span> cloneable = obj <span class="kw">as</span> ICloneable;</a>
<a class="sourceLine" id="cb3-39" title="39">                    <span class="kw">if</span> (cloneable != <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb3-40" title="40">                    {</a>
<a class="sourceLine" id="cb3-41" title="41">                        <span class="kw">return</span> cloneable.<span class="fu">Clone</span>();</a>
<a class="sourceLine" id="cb3-42" title="42">                    }</a>
<a class="sourceLine" id="cb3-43" title="43">                    <span class="kw">else</span></a>
<a class="sourceLine" id="cb3-44" title="44">                    {</a>
<a class="sourceLine" id="cb3-45" title="45">                        <span class="co">// Creating the clone with reflection</span></a>
<a class="sourceLine" id="cb3-46" title="46">                        <span class="dt">var</span> typ = obj.<span class="fu">GetType</span>();</a>
<a class="sourceLine" id="cb3-47" title="47">                        <span class="dt">var</span> clone = Activator.<span class="fu">CreateInstance</span>(typ);                     </a>
<a class="sourceLine" id="cb3-48" title="48"></a>
<a class="sourceLine" id="cb3-49" title="49">                        <span class="co">// Property names which are known locally set </span></a>
<a class="sourceLine" id="cb3-50" title="50">                        <span class="co">// dependency properties</span></a>
<a class="sourceLine" id="cb3-51" title="51">                        <span class="dt">var</span> usedNames = <span class="kw">new</span> HashSet&lt;<span class="dt">string</span>&gt;();                        </a>
<a class="sourceLine" id="cb3-52" title="52"></a>
<a class="sourceLine" id="cb3-53" title="53">                        <span class="co">// Copying locally set dependency properties from the </span></a>
<a class="sourceLine" id="cb3-54" title="54">                        <span class="co">// source to the target</span></a>
<a class="sourceLine" id="cb3-55" title="55">                        <span class="dt">var</span> dobjSource = obj <span class="kw">as</span> DependencyObject;</a>
<a class="sourceLine" id="cb3-56" title="56">                        <span class="dt">var</span> dobjTarget = clone <span class="kw">as</span> DependencyObject;</a>
<a class="sourceLine" id="cb3-57" title="57">                        <span class="kw">if</span> (dobjSource != <span class="kw">null</span> &amp;&amp; dobjTarget != <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb3-58" title="58">                        {</a>
<a class="sourceLine" id="cb3-59" title="59">                            <span class="dt">var</span> locallySetProperties = </a>
<a class="sourceLine" id="cb3-60" title="60">                                dobjSource.<span class="fu">GetLocalValueEnumerator</span>();</a>
<a class="sourceLine" id="cb3-61" title="61">                            <span class="kw">while</span> (locallySetProperties.<span class="fu">MoveNext</span>())</a>
<a class="sourceLine" id="cb3-62" title="62">                            {</a>
<a class="sourceLine" id="cb3-63" title="63">                                DependencyProperty dp = </a>
<a class="sourceLine" id="cb3-64" title="64">                                    locallySetProperties.<span class="fu">Current</span>.<span class="fu">Property</span>;</a>
<a class="sourceLine" id="cb3-65" title="65">                                <span class="kw">if</span> (!dp.<span class="fu">ReadOnly</span>)</a>
<a class="sourceLine" id="cb3-66" title="66">                                {</a>
<a class="sourceLine" id="cb3-67" title="67">                                    dobjTarget.<span class="fu">SetValue</span>(dp, dobjSource.<span class="fu">GetValue</span>(dp));</a>
<a class="sourceLine" id="cb3-68" title="68">                                    usedNames.<span class="fu">Add</span>(dp.<span class="fu">Name</span>);</a>
<a class="sourceLine" id="cb3-69" title="69">                                }</a>
<a class="sourceLine" id="cb3-70" title="70">                            }</a>
<a class="sourceLine" id="cb3-71" title="71">                        }                        </a>
<a class="sourceLine" id="cb3-72" title="72"></a>
<a class="sourceLine" id="cb3-73" title="73">                        <span class="co">// Getting all the public, non-static properties of the source</span></a>
<a class="sourceLine" id="cb3-74" title="74">                        <span class="kw">foreach</span> (<span class="dt">var</span> pi <span class="kw">in</span> typ.<span class="fu">GetProperties</span>(</a>
<a class="sourceLine" id="cb3-75" title="75">                                            BindingFlags.<span class="fu">Instance</span> | </a>
<a class="sourceLine" id="cb3-76" title="76">                                            BindingFlags.<span class="fu">Public</span> | </a>
<a class="sourceLine" id="cb3-77" title="77">                                            BindingFlags.<span class="fu">FlattenHierarchy</span>))</a>
<a class="sourceLine" id="cb3-78" title="78">                        {</a>
<a class="sourceLine" id="cb3-79" title="79">                            <span class="co">// If it is not a dependency property </span></a>
<a class="sourceLine" id="cb3-80" title="80">                            <span class="co">// and not the default property...</span></a>
<a class="sourceLine" id="cb3-81" title="81">                            <span class="kw">if</span> (pi.<span class="fu">CanRead</span> &amp;&amp;</a>
<a class="sourceLine" id="cb3-82" title="82">                                !usedNames.<span class="fu">Contains</span>(pi.<span class="fu">Name</span>) &amp;&amp;</a>
<a class="sourceLine" id="cb3-83" title="83">                                !<span class="fu">IsDependencyProperty</span>(dobjSource, pi) &amp;&amp;</a>
<a class="sourceLine" id="cb3-84" title="84">                                pi.<span class="fu">Name</span> != <span class="st">&quot;Item&quot;</span>)</a>
<a class="sourceLine" id="cb3-85" title="85">                            {                                    </a>
<a class="sourceLine" id="cb3-86" title="86">                                <span class="dt">var</span> val = pi.<span class="fu">GetValue</span>(obj, <span class="kw">null</span>);</a>
<a class="sourceLine" id="cb3-87" title="87"></a>
<a class="sourceLine" id="cb3-88" title="88">                                <span class="co">// ..and it is writeable, then we recursively clone </span></a>
<a class="sourceLine" id="cb3-89" title="89">                                <span class="co">// the value and set the property:</span></a>
<a class="sourceLine" id="cb3-90" title="90">                                <span class="kw">if</span> (pi.<span class="fu">CanWrite</span>)</a>
<a class="sourceLine" id="cb3-91" title="91">                                {                                        </a>
<a class="sourceLine" id="cb3-92" title="92">                                    pi.<span class="fu">SetValue</span>(clone, <span class="fu">DeepClone</span>(val), <span class="kw">null</span>);</a>
<a class="sourceLine" id="cb3-93" title="93">                                }</a>
<a class="sourceLine" id="cb3-94" title="94">                                <span class="kw">else</span></a>
<a class="sourceLine" id="cb3-95" title="95">                                {</a>
<a class="sourceLine" id="cb3-96" title="96">                                    <span class="co">// ..otherwise if it is a readonly list property, </span></a>
<a class="sourceLine" id="cb3-97" title="97">                                    <span class="co">// go through each item,  clone it and add to </span></a>
<a class="sourceLine" id="cb3-98" title="98">                                    <span class="co">// the clone&#39;s list property</span></a>
<a class="sourceLine" id="cb3-99" title="99">                                    <span class="kw">if</span> (pi.<span class="fu">PropertyType</span></a>
<a class="sourceLine" id="cb3-100" title="100">                                          .<span class="fu">GetInterfaces</span>()</a>
<a class="sourceLine" id="cb3-101" title="101">                                          .<span class="fu">Contains</span>(<span class="kw">typeof</span> (IList)))</a>
<a class="sourceLine" id="cb3-102" title="102">                                    {</a>
<a class="sourceLine" id="cb3-103" title="103">                                        <span class="dt">var</span> source = val <span class="kw">as</span> IList;</a>
<a class="sourceLine" id="cb3-104" title="104">                                        <span class="dt">var</span> target = pi.<span class="fu">GetValue</span>(clone, <span class="kw">null</span>) <span class="kw">as</span> IList;</a>
<a class="sourceLine" id="cb3-105" title="105"></a>
<a class="sourceLine" id="cb3-106" title="106">                                        <span class="kw">if</span> (source != <span class="kw">null</span> &amp;&amp; target != <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb3-107" title="107">                                        {</a>
<a class="sourceLine" id="cb3-108" title="108">                                            <span class="kw">foreach</span> (<span class="dt">var</span> item <span class="kw">in</span> source)</a>
<a class="sourceLine" id="cb3-109" title="109">                                                target.<span class="fu">Add</span>(<span class="fu">DeepClone</span>(item));</a>
<a class="sourceLine" id="cb3-110" title="110">                                        }</a>
<a class="sourceLine" id="cb3-111" title="111">                                    }</a>
<a class="sourceLine" id="cb3-112" title="112">                                }</a>
<a class="sourceLine" id="cb3-113" title="113">                            }</a>
<a class="sourceLine" id="cb3-114" title="114">                        }                        </a>
<a class="sourceLine" id="cb3-115" title="115"></a>
<a class="sourceLine" id="cb3-116" title="116">                        <span class="kw">return</span> clone;</a>
<a class="sourceLine" id="cb3-117" title="117">                    }</a>
<a class="sourceLine" id="cb3-118" title="118">                }</a>
<a class="sourceLine" id="cb3-119" title="119">            }</a>
<a class="sourceLine" id="cb3-120" title="120">        }</a>
<a class="sourceLine" id="cb3-121" title="121">        <span class="kw">else</span></a>
<a class="sourceLine" id="cb3-122" title="122">        {</a>
<a class="sourceLine" id="cb3-123" title="123">            <span class="kw">return</span> <span class="kw">null</span>;</a>
<a class="sourceLine" id="cb3-124" title="124">        }</a>
<a class="sourceLine" id="cb3-125" title="125">    }    </a>
<a class="sourceLine" id="cb3-126" title="126"></a>
<a class="sourceLine" id="cb3-127" title="127">    <span class="co">/// </span><span class="kw">&lt;summary&gt;</span></a>
<a class="sourceLine" id="cb3-128" title="128">    <span class="co">/// Tries to determine if a property is a dependency property, by reflection and </span></a>
<a class="sourceLine" id="cb3-129" title="129">    <span class="co">/// naming convention</span></a>
<a class="sourceLine" id="cb3-130" title="130">    <span class="co">/// </span><span class="kw">&lt;/summary&gt;</span></a>
<a class="sourceLine" id="cb3-131" title="131">    <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;dobj&quot;</span><span class="kw">&gt;</span><span class="co">Dependency object</span></a>
<a class="sourceLine" id="cb3-132" title="132">    <span class="co">/// </span><span class="kw">&lt;param</span><span class="ot"> name=</span><span class="dt">&quot;pi&quot;</span><span class="kw">&gt;</span><span class="co">Property info</span></a>
<a class="sourceLine" id="cb3-133" title="133">    <span class="co">/// </span><span class="kw">&lt;returns&gt;</span><span class="co">Returns </span><span class="kw">&lt;c&gt;</span><span class="co">true</span><span class="kw">&lt;/c&gt;</span><span class="co"> if the given property seems to be a </span></a>
<a class="sourceLine" id="cb3-134" title="134">    <span class="co">///          CLR access property for a dependency property.</span><span class="kw">&lt;/returns&gt;</span></a>
<a class="sourceLine" id="cb3-135" title="135">    <span class="kw">private</span> <span class="kw">static</span> <span class="dt">bool</span> <span class="fu">IsDependencyProperty</span>(DependencyObject dobj, PropertyInfo pi)</a>
<a class="sourceLine" id="cb3-136" title="136">    {</a>
<a class="sourceLine" id="cb3-137" title="137">        <span class="kw">if</span> (dobj != <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb3-138" title="138">        {</a>
<a class="sourceLine" id="cb3-139" title="139">            <span class="dt">var</span> dpProp = dobj.<span class="fu">GetType</span>().<span class="fu">GetProperty</span>(pi.<span class="fu">Name</span> + <span class="st">&quot;Property&quot;</span>, </a>
<a class="sourceLine" id="cb3-140" title="140">                                                    BindingFlags.<span class="fu">Static</span> |</a>
<a class="sourceLine" id="cb3-141" title="141">                                                    BindingFlags.<span class="fu">Public</span> |</a>
<a class="sourceLine" id="cb3-142" title="142">                                                    BindingFlags.<span class="fu">FlattenHierarchy</span>);</a>
<a class="sourceLine" id="cb3-143" title="143">            <span class="kw">if</span> (dpProp != <span class="kw">null</span> &amp;&amp; dpProp.<span class="fu">PropertyType</span> == <span class="kw">typeof</span> (DependencyProperty))</a>
<a class="sourceLine" id="cb3-144" title="144">                <span class="kw">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb3-145" title="145">            <span class="kw">else</span></a>
<a class="sourceLine" id="cb3-146" title="146">            {</a>
<a class="sourceLine" id="cb3-147" title="147">                <span class="dt">var</span> dpField = dobj.<span class="fu">GetType</span>().<span class="fu">GetField</span>(pi.<span class="fu">Name</span> + <span class="st">&quot;Property&quot;</span>, </a>
<a class="sourceLine" id="cb3-148" title="148">                                                      BindingFlags.<span class="fu">Static</span> | </a>
<a class="sourceLine" id="cb3-149" title="149">                                                      BindingFlags.<span class="fu">Public</span> | </a>
<a class="sourceLine" id="cb3-150" title="150">                                                      BindingFlags.<span class="fu">FlattenHierarchy</span>);</a>
<a class="sourceLine" id="cb3-151" title="151">                <span class="kw">if</span> (dpField != <span class="kw">null</span> &amp;&amp; </a>
<a class="sourceLine" id="cb3-152" title="152">                    dpField.<span class="fu">FieldType</span> == <span class="kw">typeof</span> (DependencyProperty) &amp;&amp; </a>
<a class="sourceLine" id="cb3-153" title="153">                    dpField.<span class="fu">IsInitOnly</span> &amp;&amp; dpField.<span class="fu">IsStatic</span>)</a>
<a class="sourceLine" id="cb3-154" title="154">                    <span class="kw">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb3-155" title="155">            }</a>
<a class="sourceLine" id="cb3-156" title="156">        }        </a>
<a class="sourceLine" id="cb3-157" title="157"></a>
<a class="sourceLine" id="cb3-158" title="158">        <span class="kw">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb3-159" title="159">    }</a>
<a class="sourceLine" id="cb3-160" title="160">}</a></code></pre></div>
]]></summary>
</entry>

</feed>
